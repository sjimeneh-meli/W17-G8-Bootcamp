
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/sajimenezher_meli/meli-frescos-8/cmd/api/main.go (0.0%)</option>
				
				<option value="file1">github.com/sajimenezher_meli/meli-frescos-8/internal/application/application.go (0.0%)</option>
				
				<option value="file2">github.com/sajimenezher_meli/meli-frescos-8/internal/config/config.go (0.0%)</option>
				
				<option value="file3">github.com/sajimenezher_meli/meli-frescos-8/internal/container/container.go (0.0%)</option>
				
				<option value="file4">github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/buyerHandler.go (0.0%)</option>
				
				<option value="file5">github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/carry_handler.go (0.0%)</option>
				
				<option value="file6">github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/employeeHandler.go (0.0%)</option>
				
				<option value="file7">github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/inboundOrderHandler.go (0.0%)</option>
				
				<option value="file8">github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/localityHandler.go (0.0%)</option>
				
				<option value="file9">github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/productBatchHandler.go (0.0%)</option>
				
				<option value="file10">github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/productHandler.go (100.0%)</option>
				
				<option value="file11">github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/productRecordHandler.go (0.0%)</option>
				
				<option value="file12">github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/purchaseOrderHandler.go (0.0%)</option>
				
				<option value="file13">github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/sectionHandler.go (0.0%)</option>
				
				<option value="file14">github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/sellerHandler.go (0.0%)</option>
				
				<option value="file15">github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/warehouse_handler.go (0.0%)</option>
				
				<option value="file16">github.com/sajimenezher_meli/meli-frescos-8/internal/mappers/buyerMapper.go (0.0%)</option>
				
				<option value="file17">github.com/sajimenezher_meli/meli-frescos-8/internal/mappers/carry_mapper.go (0.0%)</option>
				
				<option value="file18">github.com/sajimenezher_meli/meli-frescos-8/internal/mappers/employeeMapper.go (0.0%)</option>
				
				<option value="file19">github.com/sajimenezher_meli/meli-frescos-8/internal/mappers/inboundOrderMapper.go (0.0%)</option>
				
				<option value="file20">github.com/sajimenezher_meli/meli-frescos-8/internal/mappers/localityMapper.go (0.0%)</option>
				
				<option value="file21">github.com/sajimenezher_meli/meli-frescos-8/internal/mappers/productBatchMapper.go (0.0%)</option>
				
				<option value="file22">github.com/sajimenezher_meli/meli-frescos-8/internal/mappers/productMapper.go (0.0%)</option>
				
				<option value="file23">github.com/sajimenezher_meli/meli-frescos-8/internal/mappers/productRecordMapper.go (0.0%)</option>
				
				<option value="file24">github.com/sajimenezher_meli/meli-frescos-8/internal/mappers/purchaseOrder.go (0.0%)</option>
				
				<option value="file25">github.com/sajimenezher_meli/meli-frescos-8/internal/mappers/sectionMapper.go (0.0%)</option>
				
				<option value="file26">github.com/sajimenezher_meli/meli-frescos-8/internal/mappers/sellerMappers.go (0.0%)</option>
				
				<option value="file27">github.com/sajimenezher_meli/meli-frescos-8/internal/mappers/warehouse_mapper.go (0.0%)</option>
				
				<option value="file28">github.com/sajimenezher_meli/meli-frescos-8/internal/repositories/InboundOrderRepository.go (0.0%)</option>
				
				<option value="file29">github.com/sajimenezher_meli/meli-frescos-8/internal/repositories/buyerRepository.go (0.0%)</option>
				
				<option value="file30">github.com/sajimenezher_meli/meli-frescos-8/internal/repositories/carry_repository.go (0.0%)</option>
				
				<option value="file31">github.com/sajimenezher_meli/meli-frescos-8/internal/repositories/employeeRepository.go (0.0%)</option>
				
				<option value="file32">github.com/sajimenezher_meli/meli-frescos-8/internal/repositories/localityRepository.go (0.0%)</option>
				
				<option value="file33">github.com/sajimenezher_meli/meli-frescos-8/internal/repositories/productBatchRepository.go (0.0%)</option>
				
				<option value="file34">github.com/sajimenezher_meli/meli-frescos-8/internal/repositories/productRecordRepository.go (0.0%)</option>
				
				<option value="file35">github.com/sajimenezher_meli/meli-frescos-8/internal/repositories/productRepository.go (0.0%)</option>
				
				<option value="file36">github.com/sajimenezher_meli/meli-frescos-8/internal/repositories/purchaseOrderRepository.go (0.0%)</option>
				
				<option value="file37">github.com/sajimenezher_meli/meli-frescos-8/internal/repositories/sectionRepository.go (0.0%)</option>
				
				<option value="file38">github.com/sajimenezher_meli/meli-frescos-8/internal/repositories/sellerRepository.go (0.0%)</option>
				
				<option value="file39">github.com/sajimenezher_meli/meli-frescos-8/internal/repositories/warehouse_repository.go (0.0%)</option>
				
				<option value="file40">github.com/sajimenezher_meli/meli-frescos-8/internal/routes/routes.go (0.0%)</option>
				
				<option value="file41">github.com/sajimenezher_meli/meli-frescos-8/internal/services/buyerService.go (0.0%)</option>
				
				<option value="file42">github.com/sajimenezher_meli/meli-frescos-8/internal/services/carry_services.go (0.0%)</option>
				
				<option value="file43">github.com/sajimenezher_meli/meli-frescos-8/internal/services/employeeService.go (0.0%)</option>
				
				<option value="file44">github.com/sajimenezher_meli/meli-frescos-8/internal/services/inboundOrderService.go (0.0%)</option>
				
				<option value="file45">github.com/sajimenezher_meli/meli-frescos-8/internal/services/localityService.go (0.0%)</option>
				
				<option value="file46">github.com/sajimenezher_meli/meli-frescos-8/internal/services/productBatchService.go (0.0%)</option>
				
				<option value="file47">github.com/sajimenezher_meli/meli-frescos-8/internal/services/productRecordService.go (0.0%)</option>
				
				<option value="file48">github.com/sajimenezher_meli/meli-frescos-8/internal/services/productService.go (0.0%)</option>
				
				<option value="file49">github.com/sajimenezher_meli/meli-frescos-8/internal/services/purchaseOrderService.go (0.0%)</option>
				
				<option value="file50">github.com/sajimenezher_meli/meli-frescos-8/internal/services/sectionService.go (0.0%)</option>
				
				<option value="file51">github.com/sajimenezher_meli/meli-frescos-8/internal/services/sellerService.go (0.0%)</option>
				
				<option value="file52">github.com/sajimenezher_meli/meli-frescos-8/internal/services/warehouse_service.go (0.0%)</option>
				
				<option value="file53">github.com/sajimenezher_meli/meli-frescos-8/internal/tests/product_service_mock.go (0.0%)</option>
				
				<option value="file54">github.com/sajimenezher_meli/meli-frescos-8/internal/validations/ProductRecordValidation.go (0.0%)</option>
				
				<option value="file55">github.com/sajimenezher_meli/meli-frescos-8/internal/validations/buyerValidations.go (0.0%)</option>
				
				<option value="file56">github.com/sajimenezher_meli/meli-frescos-8/internal/validations/carry_validation.go (0.0%)</option>
				
				<option value="file57">github.com/sajimenezher_meli/meli-frescos-8/internal/validations/employeeValidatioin.go (0.0%)</option>
				
				<option value="file58">github.com/sajimenezher_meli/meli-frescos-8/internal/validations/inboundOrderValidations.go (0.0%)</option>
				
				<option value="file59">github.com/sajimenezher_meli/meli-frescos-8/internal/validations/localityValidations.go (0.0%)</option>
				
				<option value="file60">github.com/sajimenezher_meli/meli-frescos-8/internal/validations/productBatchValidations.go (0.0%)</option>
				
				<option value="file61">github.com/sajimenezher_meli/meli-frescos-8/internal/validations/productValidation.go (0.0%)</option>
				
				<option value="file62">github.com/sajimenezher_meli/meli-frescos-8/internal/validations/purchaseOrderValidations.go (0.0%)</option>
				
				<option value="file63">github.com/sajimenezher_meli/meli-frescos-8/internal/validations/sectionValidation.go (0.0%)</option>
				
				<option value="file64">github.com/sajimenezher_meli/meli-frescos-8/internal/validations/sellerValidation.go (0.0%)</option>
				
				<option value="file65">github.com/sajimenezher_meli/meli-frescos-8/internal/validations/warehouse_validation.go (0.0%)</option>
				
				<option value="file66">github.com/sajimenezher_meli/meli-frescos-8/pkg/database/mysql.go (0.0%)</option>
				
				<option value="file67">github.com/sajimenezher_meli/meli-frescos-8/pkg/tools.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import "github.com/sajimenezher_meli/meli-frescos-8/internal/application"

func main() <span class="cov0" title="0">{
        app := application.Application{
                PortServer: "localhost:8080",
        }

        app.InitApplication()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package application

import (
        "fmt"
        "log"
        "net/http"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/config"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/container"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/routes"
        "github.com/sajimenezher_meli/meli-frescos-8/pkg/database"
)

type Application struct {
        PortServer string
}

func (app *Application) InitApplication() <span class="cov0" title="0">{
        // 1. Load configuration
        cfg := config.LoadConfig()

        // 2. Initialize database
        db := database.InitDB(cfg)
        defer db.Close()

        c, err := container.NewContainer(db)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error initialized container dependencies %v", err)
        }</span>

        <span class="cov0" title="0">router := routes.SetupRoutes(c)

        log.Printf("Server starting on port http://%s/api/v1", app.PortServer)

        if err := http.ListenAndServe(app.PortServer, router); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Error starting server: %v", err))</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "log"
        "os"

        "github.com/joho/godotenv"
)

type Database struct {
        DBUser     string
        DBPassword string
        DBHost     string
        DBPort     string
        DBName     string
}

type ConfigApplication struct {
        Port string
}

// Config holds the application configuration
type Config struct {
        Database    Database
        Application ConfigApplication
}

// LoadConfig loads configuration from .env file
func LoadConfig() *Config <span class="cov0" title="0">{
        err := godotenv.Load("config.env")

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error loading .env file%v", err)
        }</span>

        <span class="cov0" title="0">return &amp;Config{
                Database: Database{
                        DBUser:     os.Getenv("DB_USER"),
                        DBPassword: os.Getenv("DB_PASSWORD"),
                        DBHost:     os.Getenv("DB_HOST"),
                        DBPort:     os.Getenv("DB_PORT"),
                        DBName:     os.Getenv("DB_NAME"),
                },
                Application: ConfigApplication{
                        Port: os.Getenv("APP_PORT"),
                },
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// internal/container/container.go
package container

import (
        "database/sql"
        "fmt"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/repositories"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/services"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/validations"
)

type Container struct {
        EmployeeHandler      handlers.EmployeeHandlerI
        BuyerHandler         handlers.BuyerHandlerI
        WarehouseHandler     *handlers.WarehouseHandler
        SellerHandler        *handlers.SellerHandler
        SectionHandler       handlers.SectionHandlerI
        ProductBatchHandler  handlers.ProductBatchHandlerI
        ProductHandler       *handlers.ProductHandler
        PurchaseOrderHandler handlers.PurchaseOrderHandlerI
        ProductRecordHandler handlers.ProductRecordHandlerI
        LocalityHandler      *handlers.LocalityHandler
        CarryHandler         *handlers.CarryHandler
        InboundOrderHandler  handlers.InboundOrderHandlerI
        StorageDB            *sql.DB
}

// Strategy para manejo de errores
type ErrorHandler interface {
        Execute(tasks []Task) error
}

type Task struct {
        Name string
        Func func() error
}

// Implementación concreta que maneja los errores
type InitializationErrorHandler struct{}

func (h InitializationErrorHandler) Execute(tasks []Task) error <span class="cov0" title="0">{
        for _, task := range tasks </span><span class="cov0" title="0">{
                if err := task.Func(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to initialize %s: %w", task.Name, err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func NewContainer(storeDB *sql.DB) (*Container, error) <span class="cov0" title="0">{
        container := &amp;Container{
                StorageDB: storeDB,
        }
        errorHandler := InitializationErrorHandler{}

        tasks := []Task{
                {"employee handler", container.initializeEmployeeHandler},
                {"buyer handler", container.initializeBuyerHandler},
                {"warehouse handler", container.initializeWarehouseHandler},
                {"seller handler", container.initializeSellerHandler},
                {"section handler", container.initializeSectionHandler},
                {"product handler", container.initializeProductHandler},
                {"productBatch handler", container.initializeProductBatchHandler},
                {"purchase order handler", container.initializePurchaseOrderHandler},
                {"product record handler", container.initializeProductRecordHandler},
                {"locality handler", container.initializeLocalityHandler},
                {"carry handler", container.initializeCarryHandler},
                {"inbound order handler", container.initializeInboundOrderHandler},
        }

        if err := errorHandler.Execute(tasks); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return container, nil</span>
}

func (c *Container) initializeEmployeeHandler() error <span class="cov0" title="0">{
        employeeRepository := repositories.GetNewEmployeeMySQLRepository(c.StorageDB)
        employeeService := services.GetEmployeeService(employeeRepository)
        employeeValidation := validations.GetEmployeeValidation()
        c.EmployeeHandler = handlers.GetEmployeeHandler(employeeService, employeeValidation)
        return nil
}</span>

func (c *Container) initializeBuyerHandler() error <span class="cov0" title="0">{
        buyerRepository := repositories.GetNewBuyerMySQLRepository(c.StorageDB)
        buyerService := services.GetBuyerService(buyerRepository)
        c.BuyerHandler = handlers.GetBuyerHandler(buyerService)
        return nil
}</span>

func (c *Container) initializeWarehouseHandler() error <span class="cov0" title="0">{
        repository := repositories.NewWarehouseRepository(c.StorageDB)
        service := services.NewWarehouseService(repository)
        c.WarehouseHandler = handlers.NewWarehouseHandler(service)
        return nil
}</span>

func (c *Container) initializeSellerHandler() error <span class="cov0" title="0">{
        sellerRepo := repositories.NewSQLSellerRepository(c.StorageDB)
        sellerService := services.NewJSONSellerService(sellerRepo)
        c.SellerHandler = handlers.NewSellerHandler(sellerService)
        return nil
}</span>
func (c *Container) initializeLocalityHandler() error <span class="cov0" title="0">{
        localityRepo := repositories.NewSQLLocalityRepository(c.StorageDB)
        localityService := services.NewSQLLocalityService(localityRepo)
        c.LocalityHandler = handlers.NewLocalityHandler(localityService)
        return nil
}</span>

func (c *Container) initializeSectionHandler() error <span class="cov0" title="0">{
        warehouseRepository := repositories.NewWarehouseRepository(c.StorageDB)
        warehouseService := services.NewWarehouseService(warehouseRepository)

        sectionRepository := repositories.GetSectionRepository(c.StorageDB)
        sectionService := services.GetSectionService(sectionRepository)
        sectionValidation := validations.GetSectionValidation()
        c.SectionHandler = handlers.GetSectionHandler(sectionService, warehouseService, sectionValidation)
        return nil
}</span>

func (c *Container) initializeProductHandler() error <span class="cov0" title="0">{
        productDB := c.StorageDB
        productRepository := repositories.NewProductRepository(productDB)
        productService := services.NewProductService(productRepository)
        c.ProductHandler = handlers.NewProductHandler(productService)
        return nil
}</span>

func (c *Container) initializeProductRecordHandler() error <span class="cov0" title="0">{
        productRecordDb := c.StorageDB
        productRecordRepository := repositories.NewProductRecordRepository(productRecordDb)

        productRepository := repositories.NewProductRepository(productRecordDb)
        productService := services.NewProductService(productRepository)

        productRecordService := services.NewProductRecordService(productRecordRepository, productService)
        productRecordHandler := handlers.NewProductRecordHandler(productRecordService)

        c.ProductRecordHandler = productRecordHandler

        return nil
}</span>

func (c *Container) initializeProductBatchHandler() error <span class="cov0" title="0">{
        sectionRepository := repositories.GetSectionRepository(c.StorageDB)
        sectionService := services.GetSectionService(sectionRepository)

        productRepository := repositories.NewProductRepository(c.StorageDB)
        productService := services.NewProductService(productRepository)

        productBatchRepository := repositories.GetProductBatchRepository(c.StorageDB)
        productBatchService := services.GetProductBatchService(productBatchRepository)
        productBatchValidation := validations.GetProductBatchValidation()
        c.ProductBatchHandler = handlers.GetProductBatchHandler(productBatchService, sectionService, productService, *productBatchValidation)
        return nil
}</span>

func (c *Container) initializePurchaseOrderHandler() error <span class="cov0" title="0">{
        purchaseOrderRepository := repositories.GetNewPurchaseOrderMySQLRepository(c.StorageDB)
        buyerRepository := repositories.GetNewBuyerMySQLRepository(c.StorageDB)
        productRecordsRepository := repositories.NewProductRecordRepository(c.StorageDB)

        purchaseOrderService := services.GetPurchaseOrderService(purchaseOrderRepository, buyerRepository, productRecordsRepository)
        c.PurchaseOrderHandler = handlers.GetPurchaseOrderHandler(purchaseOrderService)
        return nil
}</span>
func (c *Container) initializeCarryHandler() error <span class="cov0" title="0">{
        carryRepo := repositories.NewCarryRepository(c.StorageDB)
        localityRepo := repositories.NewSQLLocalityRepository(c.StorageDB)
        carryService := services.NewCarryService(carryRepo, localityRepo)
        c.CarryHandler = handlers.NewCarryHandler(carryService)
        return nil
}</span>
func (c *Container) initializeInboundOrderHandler() error <span class="cov0" title="0">{
        inboundOrderRepository := repositories.GetNewInboundOrderMySQLRepository(c.StorageDB)
        employeeRepository := repositories.GetNewEmployeeMySQLRepository(c.StorageDB)
        inboundOrderService := services.GetInboundOrdersService(inboundOrderRepository, employeeRepository)
        c.InboundOrderHandler = handlers.GetInboundOrderHandler(inboundOrderService)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package handlers

import (
        "context"
        "errors"
        "net/http"
        "strconv"
        "time"

        "github.com/bootcamp-go/web/request"
        "github.com/bootcamp-go/web/response"
        "github.com/go-chi/chi/v5"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/error_message"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/responses"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/mappers"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/services"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/validations"
)

// GetBuyerHandler creates and returns a new instance of BuyerHandler with the required service
// GetBuyerHandler crea y retorna una nueva instancia de BuyerHandler con el servicio requerido
func GetBuyerHandler(service services.BuyerServiceI) BuyerHandlerI <span class="cov0" title="0">{
        return &amp;BuyerHandler{
                service: service,
        }
}</span>

// BuyerHandlerI defines the contract for buyer HTTP handlers with RESTful operations
// BuyerHandlerI define el contrato para los manejadores HTTP de compradores con operaciones RESTful
type BuyerHandlerI interface {
        GetAll() http.HandlerFunc
        GetById() http.HandlerFunc
        DeleteById() http.HandlerFunc
        PostBuyer() http.HandlerFunc
        PatchBuyer() http.HandlerFunc
}

// BuyerHandler implements BuyerHandlerI and handles HTTP requests for buyer operations
// BuyerHandler implementa BuyerHandlerI y maneja las solicitudes HTTP para operaciones de compradores
type BuyerHandler struct {
        service services.BuyerServiceI // Service layer for buyer business logic / Capa de servicio para lógica de negocio de compradores
}

// GetAll handles HTTP GET requests to retrieve all buyers
// Returns a JSON response with all buyers or appropriate error codes
// GetAll maneja las solicitudes HTTP GET para recuperar todos los compradores
// Retorna una respuesta JSON con todos los compradores o códigos de error apropiados
func (h *BuyerHandler) GetAll() http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Set timeout context for the request / Establecer contexto con timeout para la solicitud
                ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
                defer cancel()

                var (
                        requestResponse *responses.DataResponse = &amp;responses.DataResponse{}
                        buyerResponse   []*responses.BuyerResponse
                        buyers          []*models.Buyer
                )

                // Get all buyers from service layer / Obtener todos los compradores de la capa de servicio
                buyersMap, err := h.service.GetAll(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusInternalServerError, err.Error())
                        return
                }</span>

                // Convert map to slice and map to response format / Convertir mapa a slice y mapear a formato de respuesta
                <span class="cov0" title="0">buyers = buyerMapToBuyerList(buyersMap)
                buyerResponse = mappers.GetListBuyerResponseFromListModel(buyers)
                requestResponse.Data = buyerResponse

                response.JSON(w, http.StatusOK, requestResponse)</span>
        }
}

// GetById handles HTTP GET requests to retrieve a buyer by ID
// Extracts the ID from the URL parameter and returns the buyer data or appropriate error codes
// GetById maneja las solicitudes HTTP GET para recuperar un comprador por ID
// Extrae el ID del parámetro de URL y retorna los datos del comprador o códigos de error apropiados
func (h *BuyerHandler) GetById() http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Set timeout context for the request / Establecer contexto con timeout para la solicitud
                ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
                defer cancel()

                var (
                        requestResponse *responses.DataResponse = &amp;responses.DataResponse{}
                        buyerResponse   *responses.BuyerResponse
                        buyer           models.Buyer
                )

                // Extract and validate ID parameter from URL / Extraer y validar parámetro ID de la URL
                id, err := strconv.Atoi(chi.URLParam(r, "id"))
                if err != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusBadRequest, err.Error())
                        return
                }</span>

                // Get buyer by ID from service layer / Obtener comprador por ID de la capa de servicio
                <span class="cov0" title="0">buyer, err = h.service.GetById(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        // Handle specific error types / Manejar tipos de error específicos
                        if errors.Is(err, error_message.ErrNotFound) </span><span class="cov0" title="0">{
                                response.Error(w, http.StatusNotFound, err.Error())
                                return
                        }</span>

                        <span class="cov0" title="0">response.Error(w, http.StatusInternalServerError, err.Error())
                        return</span>
                }

                // Map model to response format / Mapear modelo a formato de respuesta
                <span class="cov0" title="0">buyerResponse = mappers.GetResponseBuyerFromModel(&amp;buyer)
                requestResponse.Data = buyerResponse
                response.JSON(w, http.StatusOK, requestResponse)</span>
        }
}

// DeleteById handles HTTP DELETE requests to remove a buyer by ID
// Extracts the ID from the URL parameter and deletes the buyer
// DeleteById maneja las solicitudes HTTP DELETE para eliminar un comprador por ID
// Extrae el ID del parámetro de URL y elimina el comprador
func (h *BuyerHandler) DeleteById() http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Set timeout context for the request / Establecer contexto con timeout para la solicitud
                ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
                defer cancel()

                // Extract and validate ID parameter from URL / Extraer y validar parámetro ID de la URL
                id, err := strconv.Atoi(chi.URLParam(r, "id"))
                if err != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusBadRequest, err.Error())
                        return
                }</span>

                // Delete buyer through service layer / Eliminar comprador a través de la capa de servicio
                <span class="cov0" title="0">err = h.service.DeleteById(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        // Handle specific error types / Manejar tipos de error específicos
                        if errors.Is(err, error_message.ErrNotFound) </span><span class="cov0" title="0">{
                                response.Error(w, http.StatusNotFound, err.Error())
                                return
                        }</span>

                        <span class="cov0" title="0">response.Error(w, http.StatusInternalServerError, err.Error())
                        return</span>
                }
                <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
        }
}

// PostBuyer handles HTTP POST requests to create a new buyer
// Validates the request body and returns appropriate HTTP status codes
// PostBuyer maneja las solicitudes HTTP POST para crear un nuevo comprador
// Valida el cuerpo de la solicitud y retorna códigos de estado HTTP apropiados
func (h *BuyerHandler) PostBuyer() http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Set timeout context for the request / Establecer contexto con timeout para la solicitud
                ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
                defer cancel()

                var requestResponse *responses.DataResponse = &amp;responses.DataResponse{}

                // Parse and validate request body / Parsear y validar cuerpo de la solicitud
                requestBuyer := requests.BuyerRequest{}
                request.JSON(r, &amp;requestBuyer)

                err := validations.ValidateBuyerRequestStruct(requestBuyer)
                if err != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusBadRequest, err.Error())
                        return
                }</span>

                // Map request to model and create through service / Mapear solicitud a modelo y crear a través del servicio
                <span class="cov0" title="0">modelBuyer := mappers.GetModelBuyerFromRequest(requestBuyer)
                buyerDb, err := h.service.Create(ctx, *modelBuyer)
                if err != nil </span><span class="cov0" title="0">{
                        // Handle specific error types / Manejar tipos de error específicos
                        if errors.Is(err, error_message.ErrAlreadyExists) </span><span class="cov0" title="0">{
                                response.Error(w, http.StatusConflict, err.Error())
                                return
                        }</span>

                        <span class="cov0" title="0">response.Error(w, http.StatusInternalServerError, err.Error())
                        return</span>
                }

                // Map model to response format / Mapear modelo a formato de respuesta
                <span class="cov0" title="0">buyerResponse := mappers.GetResponseBuyerFromModel(&amp;buyerDb)
                requestResponse.Data = buyerResponse

                response.JSON(w, http.StatusCreated, requestResponse)</span>
        }
}

// PatchBuyer handles HTTP PATCH requests to update an existing buyer
// Extracts the ID from the URL parameter and updates the buyer with partial data
// PatchBuyer maneja las solicitudes HTTP PATCH para actualizar un comprador existente
// Extrae el ID del parámetro de URL y actualiza el comprador con datos parciales
func (h *BuyerHandler) PatchBuyer() http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Set timeout context for the request / Establecer contexto con timeout para la solicitud
                ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
                defer cancel()

                var requestResponse *responses.DataResponse = &amp;responses.DataResponse{}

                // Extract and validate ID parameter from URL / Extraer y validar parámetro ID de la URL
                id, err := strconv.Atoi(chi.URLParam(r, "id"))
                if err != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusBadRequest, err.Error())
                        return
                }</span>

                // Parse and validate request body for partial update / Parsear y validar cuerpo de solicitud para actualización parcial
                <span class="cov0" title="0">requestBuyer := requests.BuyerRequest{}
                request.JSON(r, &amp;requestBuyer)

                err = validations.IsNotAnEmptyBuyer(requestBuyer)
                if err != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusBadRequest, err.Error())
                        return
                }</span>

                // Map request to model and update through service / Mapear solicitud a modelo y actualizar a través del servicio
                <span class="cov0" title="0">modelBuyer := mappers.GetModelBuyerFromRequest(requestBuyer)
                buyerDb, err := h.service.Update(ctx, id, *modelBuyer)
                if err != nil </span><span class="cov0" title="0">{
                        // Handle specific error types / Manejar tipos de error específicos
                        if errors.Is(err, error_message.ErrNotFound) </span><span class="cov0" title="0">{
                                response.Error(w, http.StatusNotFound, err.Error())
                                return
                        }</span>

                        <span class="cov0" title="0">if errors.Is(err, error_message.ErrAlreadyExists) </span><span class="cov0" title="0">{
                                response.Error(w, http.StatusConflict, err.Error())
                                return
                        }</span>

                        <span class="cov0" title="0">response.Error(w, http.StatusInternalServerError, err.Error())
                        return</span>
                }

                // Map model to response format / Mapear modelo a formato de respuesta
                <span class="cov0" title="0">buyerResponse := mappers.GetResponseBuyerFromModel(&amp;buyerDb)
                requestResponse.Data = buyerResponse

                response.JSON(w, http.StatusOK, requestResponse)</span>
        }
}

// buyerMapToBuyerList converts a map of buyers to a slice of buyer pointers
// Helper function for data transformation in the handler layer
// buyerMapToBuyerList convierte un mapa de compradores a un slice de punteros de compradores
// Función auxiliar para transformación de datos en la capa de manejadores
func buyerMapToBuyerList(buyers map[int]models.Buyer) []*models.Buyer <span class="cov0" title="0">{
        buyersList := []*models.Buyer{}
        for _, buyer := range buyers </span><span class="cov0" title="0">{
                buyersList = append(buyersList, &amp;buyer)
        }</span>
        <span class="cov0" title="0">return buyersList</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "context"
        "encoding/json"
        "errors"
        "net/http"
        "strconv"
        "time"

        "github.com/bootcamp-go/web/response"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/error_message"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/responses"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/mappers"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/services"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/validations"
)

// CarryHandler handles HTTP requests for carry operations
// CarryHandler maneja las solicitudes HTTP para operaciones de transporte
type CarryHandler struct {
        carryService services.CarryService // Service layer for carry business logic / Capa de servicio para lógica de negocio de transporte
}

// NewCarryHandler creates and returns a new instance of CarryHandler with the required service
// NewCarryHandler crea y retorna una nueva instancia de CarryHandler con el servicio requerido
func NewCarryHandler(carryService services.CarryService) *CarryHandler <span class="cov0" title="0">{
        return &amp;CarryHandler{carryService: carryService}
}</span>

// Create handles HTTP POST requests to create a new carry
// Validates the request body, creates the carry, and returns appropriate HTTP status codes
// Create maneja las solicitudes HTTP POST para crear un nuevo transporte
// Valida el cuerpo de la solicitud, crea el transporte y retorna códigos de estado HTTP apropiados
func (h *CarryHandler) Create(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Set timeout context for the request / Establecer contexto con timeout para la solicitud
        ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
        defer cancel()

        var request requests.CarryRequest

        // Parse and validate JSON request body / Parsear y validar cuerpo de solicitud JSON
        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid JSON format")
                return
        }</span>

        // Validate request structure and business rules / Validar estructura de solicitud y reglas de negocio
        <span class="cov0" title="0">if err := validations.ValidateCarryRequest(request); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        // Map request to carry model / Mapear solicitud a modelo de transporte
        <span class="cov0" title="0">carry := mappers.MapCarryRequestToCarry(request)

        // Create carry through service layer / Crear transporte a través de la capa de servicio
        newCarry, err := h.carryService.CreateCarry(ctx, carry)

        if err != nil </span><span class="cov0" title="0">{
                // Handle timeout errors / Manejar errores de timeout
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusRequestTimeout, "Request timeout cancelled")
                        return
                }</span>
                // Handle specific business logic errors / Manejar errores específicos de lógica de negocio
                <span class="cov0" title="0">if errors.Is(err, error_message.ErrAlreadyExists) </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusConflict, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">if errors.Is(err, error_message.ErrNotFound) </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusConflict, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">response.Error(w, http.StatusInternalServerError, "Error creating carry")
                return</span>
        }

        // Map model to response format / Mapear modelo a formato de respuesta
        <span class="cov0" title="0">carryResponse := mappers.MapCarryToCreateCarryResponse(newCarry)

        response.JSON(w, http.StatusCreated, responses.DataResponse{
                Data: carryResponse,
        })</span>
}

// GetCarryReportByLocality handles HTTP GET requests to retrieve carry reports by locality
// Accepts an optional 'id' query parameter to filter by locality ID
// GetCarryReportByLocality maneja las solicitudes HTTP GET para recuperar reportes de transporte por localidad
// Acepta un parámetro de consulta 'id' opcional para filtrar por ID de localidad
func (h *CarryHandler) GetCarryReportByLocality(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Set timeout context for the request / Establecer contexto con timeout para la solicitud
        ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
        defer cancel()

        // Get and validate optional locality ID parameter / Obtener y validar parámetro opcional de ID de localidad
        localityIDStr := r.URL.Query().Get("id")
        var localityID int

        if localityIDStr != "" </span><span class="cov0" title="0">{
                // Validate and convert locality ID if provided / Validar y convertir ID de localidad si se proporciona
                var err error
                localityID, err = strconv.Atoi(localityIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusBadRequest, "Invalid locality ID format")
                        return
                }</span>
                <span class="cov0" title="0">if localityID &lt;= 0 </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusBadRequest, "Locality ID must be a positive number")
                        return
                }</span>
        }
        // If localityIDStr is empty, localityID will be 0 (report for all localities)
        // Si localityIDStr está vacío, localityID será 0 (reporte para todas las localidades)

        // Get reports from service layer / Obtener reportes de la capa de servicio
        <span class="cov0" title="0">reports, err := h.carryService.GetCarryReportByLocality(ctx, localityID)

        if err != nil </span><span class="cov0" title="0">{
                // Handle timeout errors / Manejar errores de timeout
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusRequestTimeout, "Request timeout cancelled")
                        return
                }</span>
                // Handle specific business logic errors / Manejar errores específicos de lógica de negocio
                <span class="cov0" title="0">if errors.Is(err, error_message.ErrNotFound) </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusNotFound, "Locality not found")
                        return
                }</span>
                <span class="cov0" title="0">response.Error(w, http.StatusInternalServerError, "Error getting carry report by locality")
                return</span>
        }

        <span class="cov0" title="0">response.JSON(w, http.StatusOK, responses.DataResponse{
                Data: reports,
        })</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        "context"
        "errors"
        "net/http"
        "strconv"
        "time"

        "github.com/bootcamp-go/web/request"
        "github.com/bootcamp-go/web/response"

        "github.com/go-chi/chi/v5"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/error_message"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/responses"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/mappers"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/services"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/validations"
)

// GetEmployeeHandler creates and returns a new instance of EmployeeHandler with the required service and validation
// GetEmployeeHandler crea y retorna una nueva instancia de EmployeeHandler con el servicio y validación requeridos
func GetEmployeeHandler(service services.EmployeeServiceI, validation *validations.EmployeeValidation) EmployeeHandlerI <span class="cov0" title="0">{
        return &amp;EmployeeHandler{
                service: service,
        }
}</span>

// EmployeeHandlerI defines the contract for employee HTTP handlers with RESTful operations
// EmployeeHandlerI define el contrato para los manejadores HTTP de empleados con operaciones RESTful
type EmployeeHandlerI interface {
        GetAllEmployee() http.HandlerFunc
        PostEmployee() http.HandlerFunc
        GetByIdEmployee() http.HandlerFunc
        DeleteByIdEmployee() http.HandlerFunc
        PatchEmployee() http.HandlerFunc
}

// EmployeeHandler implements EmployeeHandlerI and handles HTTP requests for employee operations
// EmployeeHandler implementa EmployeeHandlerI y maneja las solicitudes HTTP para operaciones de empleados
type EmployeeHandler struct {
        service services.EmployeeServiceI // Service layer for employee business logic / Capa de servicio para lógica de negocio de empleados
}

// GetAllEmployee handles HTTP GET requests to retrieve all employees
// Returns a JSON response with all employees or appropriate error codes
// GetAllEmployee maneja las solicitudes HTTP GET para recuperar todos los empleados
// Retorna una respuesta JSON con todos los empleados o códigos de error apropiados
func (h *EmployeeHandler) GetAllEmployee() http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Set timeout context for the request / Establecer contexto con timeout para la solicitud
                ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
                defer cancel()

                var (
                        requestResponse  *responses.DataResponse = &amp;responses.DataResponse{}
                        employeeResponse []*responses.EmployeeResponse
                        employee         []*models.Employee
                )

                // Get all employees from service layer / Obtener todos los empleados de la capa de servicio
                employeeMap, err := h.service.GetAll(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusInternalServerError, err.Error())
                        return
                }</span>

                // Convert map to slice and map to response format / Convertir mapa a slice y mapear a formato de respuesta
                <span class="cov0" title="0">employee = employeeMapToList(employeeMap)
                employeeResponse = mappers.GetListEmployeeResponseFromListModel(employee)
                requestResponse.Data = employeeResponse

                response.JSON(w, http.StatusOK, requestResponse)</span>
        }
}

// GetByIdEmployee handles HTTP GET requests to retrieve an employee by ID
// Extracts the ID from the URL parameter and returns the employee data or appropriate error codes
// GetByIdEmployee maneja las solicitudes HTTP GET para recuperar un empleado por ID
// Extrae el ID del parámetro de URL y retorna los datos del empleado o códigos de error apropiados
func (h *EmployeeHandler) GetByIdEmployee() http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Set timeout context for the request / Establecer contexto con timeout para la solicitud
                ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
                defer cancel()

                var (
                        requestResponse  *responses.DataResponse = &amp;responses.DataResponse{}
                        employeeResponse *responses.EmployeeResponse
                        employee         models.Employee
                )

                // Extract and validate ID parameter from URL / Extraer y validar parámetro ID de la URL
                id, err := strconv.Atoi(chi.URLParam(r, "id"))
                if err != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusBadRequest, err.Error())
                        return
                }</span>

                // Get employee by ID from service layer / Obtener empleado por ID de la capa de servicio
                <span class="cov0" title="0">employee, err = h.service.GetById(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        // Handle specific error types / Manejar tipos de error específicos
                        if errors.Is(err, error_message.ErrNotFound) </span><span class="cov0" title="0">{
                                response.Error(w, http.StatusNotFound, err.Error())
                                return
                        }</span>

                        <span class="cov0" title="0">response.Error(w, http.StatusInternalServerError, err.Error())
                        return</span>
                }

                // Map model to response format / Mapear modelo a formato de respuesta
                <span class="cov0" title="0">employeeResponse = mappers.GetEmployeeResponseFromModel(&amp;employee)
                requestResponse.Data = employeeResponse
                response.JSON(w, http.StatusOK, requestResponse)</span>
        }
}

// PostEmployee handles HTTP POST requests to create a new employee
// Validates the request body and returns appropriate HTTP status codes
// PostEmployee maneja las solicitudes HTTP POST para crear un nuevo empleado
// Valida el cuerpo de la solicitud y retorna códigos de estado HTTP apropiados
func (h *EmployeeHandler) PostEmployee() http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Set timeout context for the request / Establecer contexto con timeout para la solicitud
                ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
                defer cancel()

                var requestResponse *responses.DataResponse = &amp;responses.DataResponse{}

                // Parse and validate request body / Parsear y validar cuerpo de la solicitud
                requestEmployee := requests.EmployeeRequest{}
                request.JSON(r, &amp;requestEmployee)

                err := validations.ValidateEmployeeRequestStruct(requestEmployee)
                if err != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusBadRequest, err.Error())
                        return
                }</span>

                // Map request to model and create through service / Mapear solicitud a modelo y crear a través del servicio
                <span class="cov0" title="0">modelEmployee := mappers.GetEmployeeModelFromRequest(requestEmployee)
                employeeDb, err := h.service.Create(ctx, *modelEmployee)
                if err != nil </span><span class="cov0" title="0">{
                        // Handle specific error types / Manejar tipos de error específicos
                        if errors.Is(err, error_message.ErrAlreadyExists) </span><span class="cov0" title="0">{
                                response.Error(w, http.StatusConflict, err.Error())
                                return
                        }</span>

                        <span class="cov0" title="0">response.Error(w, http.StatusInternalServerError, err.Error())
                        return</span>
                }

                // Map model to response format / Mapear modelo a formato de respuesta
                <span class="cov0" title="0">employeeResponse := mappers.GetEmployeeResponseFromModel(&amp;employeeDb)
                requestResponse.Data = employeeResponse

                response.JSON(w, http.StatusCreated, requestResponse)</span>
        }
}

// PatchEmployee handles HTTP PATCH requests to update an existing employee
// Extracts the ID from the URL parameter and updates the employee with partial data
// PatchEmployee maneja las solicitudes HTTP PATCH para actualizar un empleado existente
// Extrae el ID del parámetro de URL y actualiza el empleado con datos parciales
func (h *EmployeeHandler) PatchEmployee() http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Set timeout context for the request / Establecer contexto con timeout para la solicitud
                ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
                defer cancel()

                var requestResponse *responses.DataResponse = &amp;responses.DataResponse{}

                // Extract and validate ID parameter from URL / Extraer y validar parámetro ID de la URL
                id, err := strconv.Atoi(chi.URLParam(r, "id"))
                if err != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusBadRequest, err.Error())
                        return
                }</span>

                // Parse and validate request body for partial update / Parsear y validar cuerpo de solicitud para actualización parcial
                <span class="cov0" title="0">requestEmployee := requests.EmployeeRequest{}
                request.JSON(r, &amp;requestEmployee)

                err = validations.IsNotAnEmptyEmployee(requestEmployee)
                if err != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusBadRequest, err.Error())
                        return
                }</span>

                // Map request to model and update through service / Mapear solicitud a modelo y actualizar a través del servicio
                <span class="cov0" title="0">modelEmployee := mappers.GetEmployeeModelFromRequest(requestEmployee)
                employeeDb, err := h.service.Update(ctx, id, *modelEmployee)
                if err != nil </span><span class="cov0" title="0">{
                        // Handle specific error types / Manejar tipos de error específicos
                        if errors.Is(err, error_message.ErrNotFound) </span><span class="cov0" title="0">{
                                response.Error(w, http.StatusNotFound, err.Error())
                                return
                        }</span>

                        <span class="cov0" title="0">if errors.Is(err, error_message.ErrAlreadyExists) </span><span class="cov0" title="0">{
                                response.Error(w, http.StatusConflict, err.Error())
                                return
                        }</span>

                        <span class="cov0" title="0">response.Error(w, http.StatusInternalServerError, err.Error())
                        return</span>
                }

                // Map model to response format / Mapear modelo a formato de respuesta
                <span class="cov0" title="0">employeeResponse := mappers.GetEmployeeResponseFromModel(&amp;employeeDb)
                requestResponse.Data = employeeResponse

                response.JSON(w, http.StatusOK, requestResponse)</span>
        }
}

// DeleteByIdEmployee handles HTTP DELETE requests to remove an employee by ID
// Extracts the ID from the URL parameter and deletes the employee
// DeleteByIdEmployee maneja las solicitudes HTTP DELETE para eliminar un empleado por ID
// Extrae el ID del parámetro de URL y elimina el empleado
func (h *EmployeeHandler) DeleteByIdEmployee() http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Set timeout context for the request / Establecer contexto con timeout para la solicitud
                ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
                defer cancel()

                // Extract and validate ID parameter from URL / Extraer y validar parámetro ID de la URL
                id, err := strconv.Atoi(chi.URLParam(r, "id"))
                if err != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusBadRequest, err.Error())
                        return
                }</span>

                // Delete employee through service layer / Eliminar empleado a través de la capa de servicio
                <span class="cov0" title="0">err = h.service.DeleteById(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        // Handle specific error types / Manejar tipos de error específicos
                        if errors.Is(err, error_message.ErrNotFound) </span><span class="cov0" title="0">{
                                response.Error(w, http.StatusNotFound, err.Error())
                                return
                        }</span>

                        <span class="cov0" title="0">response.Error(w, http.StatusInternalServerError, err.Error())
                        return</span>
                }
                <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
        }
}

// employeeMapToList converts a map of employees to a slice of employee pointers
// Helper function for data transformation in the handler layer
// employeeMapToList convierte un mapa de empleados a un slice de punteros de empleados
// Función auxiliar para transformación de datos en la capa de manejadores
func employeeMapToList(employee map[int]models.Employee) []*models.Employee <span class="cov0" title="0">{
        employeeList := []*models.Employee{}
        for _, empl := range employee </span><span class="cov0" title="0">{
                employeeList = append(employeeList, &amp;empl)
        }</span>
        <span class="cov0" title="0">return employeeList</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handlers

import (
        "context"
        "errors"
        "net/http"
        "strconv"
        "time"

        "github.com/bootcamp-go/web/request"
        "github.com/bootcamp-go/web/response"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/error_message"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/responses"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/mappers"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/services"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/validations"
)

// GetInboundOrderHandler creates and returns a new instance of InboundOrderHandler with the required service
// GetInboundOrderHandler crea y retorna una nueva instancia de InboundOrderHandler con el servicio requerido
func GetInboundOrderHandler(service services.InboundOrdersServiceI) InboundOrderHandlerI <span class="cov0" title="0">{
        return &amp;InboundOrderHandler{
                service: service,
        }
}</span>

// InboundOrderHandlerI defines the contract for inbound order HTTP handlers
// InboundOrderHandlerI define el contrato para los manejadores HTTP de órdenes de entrada
type InboundOrderHandlerI interface {
        GetInboundOrdersReport() http.HandlerFunc
        PostInboundOrder() http.HandlerFunc
}

// InboundOrderHandler implements InboundOrderHandlerI and handles HTTP requests for inbound order operations
// InboundOrderHandler implementa InboundOrderHandlerI y maneja las solicitudes HTTP para operaciones de órdenes de entrada
type InboundOrderHandler struct {
        service services.InboundOrdersServiceI // Service layer for inbound order business logic / Capa de servicio para lógica de negocio de órdenes de entrada
}

// GetInboundOrdersReport handles HTTP GET requests to retrieve inbound order reports
// Accepts an optional 'id' query parameter to filter by employee ID
// GetInboundOrdersReport maneja las solicitudes HTTP GET para recuperar reportes de órdenes de entrada
// Acepta un parámetro de consulta 'id' opcional para filtrar por ID de empleado
func (h *InboundOrderHandler) GetInboundOrdersReport() http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Set timeout context for the request / Establecer contexto con timeout para la solicitud
                ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
                defer cancel()

                var requestResponse *responses.DataResponse = &amp;responses.DataResponse{}
                var responseData []models.InboundOrderReport

                // Get and validate optional employee ID query parameter / Obtener y validar parámetro opcional de consulta ID de empleado
                queryId := r.URL.Query().Get("id")
                if queryId != "" </span><span class="cov0" title="0">{
                        // Parse and validate employee ID / Parsear y validar ID de empleado
                        employeeId, err := strconv.Atoi(queryId)
                        if err != nil </span><span class="cov0" title="0">{
                                response.Error(w, http.StatusBadRequest, "Invalid employee ID")
                                return
                        }</span>

                        // Get report for specific employee / Obtener reporte para empleado específico
                        <span class="cov0" title="0">report, err := h.service.GetInboundOrdersReportByEmployeeId(ctx, employeeId)
                        if err != nil </span><span class="cov0" title="0">{
                                response.Error(w, http.StatusInternalServerError, err.Error())
                                return
                        }</span>

                        <span class="cov0" title="0">responseData = append(responseData, report)</span>
                } else<span class="cov0" title="0"> {
                        // Get reports for all employees / Obtener reportes para todos los empleados
                        reports, err := h.service.GetAllInboundOrdersReports(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                response.Error(w, http.StatusInternalServerError, err.Error())
                                return
                        }</span>
                        <span class="cov0" title="0">responseData = reports</span>
                }

                <span class="cov0" title="0">requestResponse.Data = responseData
                response.JSON(w, http.StatusOK, requestResponse)</span>
        }
}

// PostInboundOrder handles HTTP POST requests to create a new inbound order
// Validates the request body and returns appropriate HTTP status codes
// PostInboundOrder maneja las solicitudes HTTP POST para crear una nueva orden de entrada
// Valida el cuerpo de la solicitud y retorna códigos de estado HTTP apropiados
func (h *InboundOrderHandler) PostInboundOrder() http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Set timeout context for the request / Establecer contexto con timeout para la solicitud
                ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
                defer cancel()

                var (
                        reqResponse    *responses.DataResponse      = &amp;responses.DataResponse{}
                        requestInbound requests.InboundOrderRequest = requests.InboundOrderRequest{}
                )

                // Parse and validate JSON request body / Parsear y validar cuerpo de solicitud JSON
                err := request.JSON(r, &amp;requestInbound)
                if err != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusBadRequest, err.Error())
                        return
                }</span>

                // Validate request structure and business rules / Validar estructura de solicitud y reglas de negocio
                <span class="cov0" title="0">err = validations.ValidateInboundOrderRequestStruct(requestInbound)
                if err != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusUnprocessableEntity, err.Error())
                        return
                }</span>

                // Map request to model and create through service / Mapear solicitud a modelo y crear a través del servicio
                <span class="cov0" title="0">modelInbound := mappers.GetModelInboundOrderFromRequest(requestInbound)
                order, err := h.service.Create(ctx, *modelInbound)
                if err != nil </span><span class="cov0" title="0">{
                        // Handle specific error types / Manejar tipos de error específicos
                        switch </span>{
                        case errors.Is(err, error_message.ErrAlreadyExists):<span class="cov0" title="0">
                                response.Error(w, http.StatusConflict, err.Error())
                                return</span>
                        case errors.Is(err, error_message.ErrDependencyNotFound):<span class="cov0" title="0">
                                response.Error(w, http.StatusConflict, err.Error())
                                return</span>
                        default:<span class="cov0" title="0">
                                response.Error(w, http.StatusInternalServerError, err.Error())
                                return</span>
                        }
                }

                // Map model to response format / Mapear modelo a formato de respuesta
                <span class="cov0" title="0">orderResponse := mappers.GetResponseInboundOrderFromModel(&amp;order)
                reqResponse.Data = orderResponse

                response.JSON(w, http.StatusCreated, reqResponse)</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package handlers

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "strconv"
        "time"

        "github.com/bootcamp-go/web/response"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/error_message"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/responses"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/services"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/validations"
)

// LocalityHandler handles HTTP requests for locality operations
// LocalityHandler maneja las solicitudes HTTP para operaciones de localidad
type LocalityHandler struct {
        service services.LocalityService // Service layer for locality business logic / Capa de servicio para lógica de negocio de localidad
}

// NewLocalityHandler creates and returns a new instance of LocalityHandler with the required service
// NewLocalityHandler crea y retorna una nueva instancia de LocalityHandler con el servicio requerido
func NewLocalityHandler(service services.LocalityService) *LocalityHandler <span class="cov0" title="0">{
        return &amp;LocalityHandler{service: service}
}</span>

// Save handles HTTP POST requests to create a new locality
// Validates the request body and returns appropriate HTTP status codes
// Save maneja las solicitudes HTTP POST para crear una nueva localidad
// Valida el cuerpo de la solicitud y retorna códigos de estado HTTP apropiados
func (h *LocalityHandler) Save(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var localityToCreate requests.LocalityRequest

        // Parse and validate JSON request body / Parsear y validar cuerpo de solicitud JSON
        errorBody := json.NewDecoder(r.Body).Decode(&amp;localityToCreate)
        if errorBody != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, errorBody.Error())
                return
        }</span>

        // Extract data from request / Extraer datos de la solicitud
        <span class="cov0" title="0">data := localityToCreate.Data
        fmt.Println(data)

        // Validate request structure and business rules / Validar estructura de solicitud y reglas de negocio
        if err := validations.ValidateLocalityRequestStruct(data); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusUnprocessableEntity, err.Error())
                return
        }</span>

        // Set timeout context for the request / Establecer contexto con timeout para la solicitud
        <span class="cov0" title="0">parentCtx := context.Background()
        ctx, cancel := context.WithTimeout(parentCtx, 2*time.Second)
        defer cancel()

        // Create locality through service layer / Crear localidad a través de la capa de servicio
        localityCreated, err := h.service.Save(ctx, data)
        if err != nil </span><span class="cov0" title="0">{
                // Handle specific error types / Manejar tipos de error específicos
                if errors.Is(err, error_message.ErrQuery) </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">if errors.Is(err, error_message.ErrAlreadyExists) </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusConflict, err.Error())
                }</span>
                <span class="cov0" title="0">if errors.Is(err, context.DeadlineExceeded) </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusGatewayTimeout, err.Error())
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">response.JSON(w, http.StatusOK, responses.DataResponse{Data: localityCreated})</span>
}

// GetSellerReportByLocality handles HTTP GET requests to retrieve seller reports by locality
// Accepts an optional 'id' query parameter to filter by locality ID
// GetSellerReportByLocality maneja las solicitudes HTTP GET para recuperar reportes de vendedores por localidad
// Acepta un parámetro de consulta 'id' opcional para filtrar por ID de localidad
func (h *LocalityHandler) GetSellerReportByLocality(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Set timeout context for the request / Establecer contexto con timeout para la solicitud
        parentCtx := context.Background()
        ctx, cancel := context.WithTimeout(parentCtx, 2*time.Second)
        defer cancel()

        // Get and validate optional locality ID query parameter / Obtener y validar parámetro opcional de consulta ID de localidad
        localityIdStr := r.URL.Query().Get("id")
        var localityId int

        // Validate query parameter format / Validar formato del parámetro de consulta
        if r.URL.RawQuery != "" &amp;&amp; localityIdStr == "" </span><span class="cov0" title="0">{
                response.Error(w, http.StatusInternalServerError, "Invalid query parameter")
                return
        }</span>

        <span class="cov0" title="0">if localityIdStr == "" </span><span class="cov0" title="0">{
                // If no parameter provided, use 0 as default (all localities) / Si no se proporciona parámetro, usar 0 por defecto (todas las localidades)
                localityId = 0
        }</span> else<span class="cov0" title="0"> {
                // If parameter provided, attempt to convert to int / Si se proporciona parámetro, intentar convertir a int
                var err error
                localityId, err = strconv.Atoi(localityIdStr)
                if err != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusBadRequest, err.Error())
                        return
                }</span>
        }

        // Get seller reports from service layer / Obtener reportes de vendedores de la capa de servicio
        <span class="cov0" title="0">result, err := h.service.GetSellerReports(ctx, localityId)

        // Handle specific error types / Manejar tipos de error específicos
        if errors.Is(err, error_message.ErrFailedCheckingExistence) || errors.Is(err, error_message.ErrQueryingReport) || errors.Is(err, error_message.ErrFailedToScan) </span><span class="cov0" title="0">{
                response.Error(w, http.StatusInternalServerError, err.Error())
                return
        }</span>
        <span class="cov0" title="0">if errors.Is(err, error_message.ErrNotFound) </span><span class="cov0" title="0">{
                response.Error(w, http.StatusNotFound, err.Error())
                return
        }</span>
        <span class="cov0" title="0">if errors.Is(err, context.DeadlineExceeded) </span><span class="cov0" title="0">{
                response.Error(w, http.StatusGatewayTimeout, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.JSON(w, http.StatusOK, responses.DataResponse{result})</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package handlers

import (
        "context"
        "encoding/json"
        "net/http"
        "strconv"
        "time"

        "github.com/bootcamp-go/web/response"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/responses"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/mappers"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/services"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/validations"
)

// GetProductBatchHandler creates and returns a new instance of ProductBatchHandler with required services and validation
// GetProductBatchHandler crea y retorna una nueva instancia de ProductBatchHandler con los servicios y validación requeridos
func GetProductBatchHandler(service services.ProductBatchServiceI,
        sectionService services.SectionServiceI,
        productService services.ProductService,
        validation validations.ProductBatchValidation) ProductBatchHandlerI <span class="cov0" title="0">{

        return &amp;ProductBatchHandler{
                service:        service,
                sectionService: sectionService,
                productService: productService,
                validation:     &amp;validation,
        }
}</span>

// ProductBatchHandlerI defines the contract for product batch HTTP handlers
// ProductBatchHandlerI define el contrato para los manejadores HTTP de lotes de productos
type ProductBatchHandlerI interface {
        Create(w http.ResponseWriter, r *http.Request)
        GetReportProduct(w http.ResponseWriter, r *http.Request)
}

// ProductBatchHandler implements ProductBatchHandlerI and handles HTTP requests for product batch operations
// ProductBatchHandler implementa ProductBatchHandlerI y maneja las solicitudes HTTP para operaciones de lotes de productos
type ProductBatchHandler struct {
        service        services.ProductBatchServiceI       // Service layer for product batch business logic / Capa de servicio para lógica de negocio de lotes de productos
        sectionService services.SectionServiceI            // Service layer for section validation / Capa de servicio para validación de secciones
        productService services.ProductService             // Service layer for product validation / Capa de servicio para validación de productos
        validation     *validations.ProductBatchValidation // Validation layer for product batch requests / Capa de validación para solicitudes de lotes de productos
}

// Create handles HTTP POST requests to create a new product batch
// Validates dependencies (section and product) and creates the batch with business rules validation
// Create maneja las solicitudes HTTP POST para crear un nuevo lote de productos
// Valida dependencias (sección y producto) y crea el lote con validación de reglas de negocio
func (h *ProductBatchHandler) Create(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var (
                request      *requests.ProductBatchRequest = &amp;requests.ProductBatchRequest{}
                responseJson *responses.DataResponse       = &amp;responses.DataResponse{}
        )

        // Set timeout context for the request / Establecer contexto con timeout para la solicitud
        ctx, cancel := context.WithTimeout(r.Context(), 3*time.Second)
        defer cancel()

        // Parse and validate JSON request body / Parsear y validar cuerpo de solicitud JSON
        if reqErr := json.NewDecoder(r.Body).Decode(request); reqErr != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusExpectationFailed, reqErr.Error())
                return
        }</span>

        // Validate request structure and business rules / Validar estructura de solicitud y reglas de negocio
        <span class="cov0" title="0">if valErr := h.validation.ValidateProductBatchRequestStruc(*request); valErr != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusUnprocessableEntity, valErr.Error())
                return
        }</span>

        // Validate that section exists / Validar que la sección exista
        <span class="cov0" title="0">if !h.sectionService.ExistWithID(ctx, request.SectionID) </span><span class="cov0" title="0">{
                response.Error(w, http.StatusNotFound, "section not found")
                return
        }</span>

        // Validate that product exists / Validar que el producto exista
        <span class="cov0" title="0">exists, _ := h.productService.ExistById(ctx, int64(request.ProductID))
        if !exists </span><span class="cov0" title="0">{
                response.Error(w, http.StatusNotFound, "product not found")
                return
        }</span>

        // Map request to product batch model / Mapear solicitud a modelo de lote de productos
        <span class="cov0" title="0">productBatch, mapErr := mappers.GetProductBatchModelFromRequest(request)
        if mapErr != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusExpectationFailed, mapErr.Error())
                return
        }</span>

        // Validate batch number uniqueness / Validar unicidad del número de lote
        <span class="cov0" title="0">if h.service.ExistsWithBatchNumber(ctx, productBatch.Id, productBatch.BatchNumber) </span><span class="cov0" title="0">{
                response.Error(w, http.StatusConflict, "already exist a batch with the same number")
                return
        }</span>

        // Create product batch through service layer / Crear lote de productos a través de la capa de servicio
        <span class="cov0" title="0">if srvErr := h.service.Create(ctx, productBatch); srvErr != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusExpectationFailed, srvErr.Error())
                return
        }</span>

        // Map model to response format / Mapear modelo a formato de respuesta
        <span class="cov0" title="0">responseJson.Data = mappers.GetProductBatchResponseFromModel(productBatch)
        response.JSON(w, http.StatusCreated, responseJson)</span>
}

// GetReportProduct handles HTTP GET requests to retrieve product quantity reports by section
// Accepts an optional 'id' query parameter to filter by section ID
// GetReportProduct maneja las solicitudes HTTP GET para recuperar reportes de cantidad de productos por sección
// Acepta un parámetro de consulta 'id' opcional para filtrar por ID de sección
func (h *ProductBatchHandler) GetReportProduct(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var responseJson *responses.DataResponse = &amp;responses.DataResponse{}

        // Set timeout context for the request / Establecer contexto con timeout para la solicitud
        ctx, cancel := context.WithTimeout(r.Context(), 3*time.Second)
        defer cancel()

        // Get and validate optional section ID query parameter / Obtener y validar parámetro opcional de consulta ID de sección
        idParamString := r.URL.Query().Get("id")
        if idParamString != "" </span><span class="cov0" title="0">{
                // Parse and validate section ID / Parsear y validar ID de sección
                idParam, convErr := strconv.Atoi(idParamString)
                if convErr != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusExpectationFailed, convErr.Error())
                        return
                }</span>

                // Get section by ID to validate existence / Obtener sección por ID para validar existencia
                <span class="cov0" title="0">section, srvErr := h.sectionService.GetByID(ctx, idParam)
                if srvErr != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusNotFound, srvErr.Error())
                        return
                }</span>

                // Get product quantity for specific section / Obtener cantidad de productos para sección específica
                <span class="cov0" title="0">quantity := h.service.GetProductQuantityBySectionId(ctx, section.Id)
                responseJson.Data = map[string]any{
                        "section_id":     section.Id,
                        "section_number": section.SectionNumber,
                        "products_count": quantity,
                }
                response.JSON(w, http.StatusCreated, responseJson)</span>

        } else<span class="cov0" title="0"> {
                // Get reports for all sections / Obtener reportes para todas las secciones
                sections, srvErr := h.sectionService.GetAll(ctx)
                data := make([]map[string]any, 0, len(sections))
                if srvErr != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusExpectationFailed, srvErr.Error())
                        return
                }</span>

                // Build report data for each section / Construir datos de reporte para cada sección
                <span class="cov0" title="0">for _, s := range sections </span><span class="cov0" title="0">{
                        quantity := h.service.GetProductQuantityBySectionId(ctx, s.Id)
                        data = append(data, map[string]any{
                                "section_id":     s.Id,
                                "section_number": s.SectionNumber,
                                "products_count": quantity,
                        })
                }</span>
                <span class="cov0" title="0">responseJson.Data = data

                response.JSON(w, http.StatusCreated, responseJson)</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package handlers

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "strconv"
        "time" // Import the time package

        "github.com/bootcamp-go/web/request"
        "github.com/bootcamp-go/web/response"
        "github.com/go-chi/chi/v5"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/error_message"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/responses"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/mappers"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/services"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/validations"
)

// ProductHandler maneja las solicitudes HTTP relacionadas con productos
// ProductHandler handles HTTP requests related to products
type ProductHandler struct {
        service services.ProductService // Dependencia del servicio de productos / Product service dependency
}

// NewProductHandler crea una nueva instancia del handler de productos con inyección de dependencias
// NewProductHandler creates a new instance of the product handler with dependency injection
func NewProductHandler(service services.ProductService) *ProductHandler <span class="cov8" title="1">{
        return &amp;ProductHandler{
                service: service,
        }
}</span>

// GetAll maneja las solicitudes GET para obtener todos los productos
// GetAll handles GET requests to retrieve all products
func (ph *ProductHandler) GetAll(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Establece timeout de 3 segundos para la operación
        // Set a 3-second timeout for the operation
        ctx, cancel := context.WithTimeout(r.Context(), 3*time.Second)
        defer cancel()

        // Obtiene todos los productos del servicio
        // Get all products from the service
        products, err := ph.service.GetAll(ctx)
        if err != nil </span><span class="cov8" title="1">{
                // Manejo de timeout
                // Handle timeout
                if errors.Is(err, context.DeadlineExceeded) </span><span class="cov8" title="1">{
                        response.Error(w, http.StatusGatewayTimeout, "the request took too long to process")
                        return
                }</span>
                // Manejo de errores generales
                // Handle general errors
                <span class="cov8" title="1">response.Error(w, http.StatusInternalServerError, err.Error())
                return</span>
        }

        // Respuesta exitosa con los productos
        // Successful response with products
        <span class="cov8" title="1">response.JSON(w, http.StatusOK, responses.DataResponse{Data: products})</span>
}

// Create maneja las solicitudes POST para crear un nuevo producto
// Create handles POST requests to create a new product
func (ph *ProductHandler) Create(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Establece timeout de 3 segundos para la operación
        // Set a 3-second timeout for the operation
        ctx, cancel := context.WithTimeout(r.Context(), 3*time.Second)
        defer cancel()

        // Decodifica el JSON del request
        // Decode JSON from request
        var productRequest requests.ProductRequest
        if err := request.JSON(r, &amp;productRequest); err != nil </span><span class="cov8" title="1">{
                response.Error(w, http.StatusBadRequest, "Invalid request payload: "+err.Error())
                return
        }</span>

        // Valida la estructura del request
        // Validate request structure
        <span class="cov8" title="1">validation := validations.GetProductValidation()
        if err := validation.ValidateProductRequestStruct(productRequest); err != nil </span><span class="cov8" title="1">{
                response.Error(w, http.StatusUnprocessableEntity, err.Error())
                return
        }</span>

        // Mapea el request a modelo de dominio
        // Map request to domain model
        <span class="cov8" title="1">product := mappers.GetProductFromRequest(productRequest)

        // Crea el producto a través del servicio
        // Create product through service
        newProduct, err := ph.service.Create(ctx, product)
        if err != nil </span><span class="cov8" title="1">{
                // Manejo de timeout
                // Handle timeout
                if errors.Is(err, context.DeadlineExceeded) </span><span class="cov8" title="1">{
                        response.Error(w, http.StatusGatewayTimeout, "the request took too long to process")
                        return
                }</span>
                // Manejo de conflictos (producto ya existe)
                // Handle conflicts (product already exists)
                <span class="cov8" title="1">if errors.Is(err, error_message.ErrAlreadyExists) </span><span class="cov8" title="1">{
                        response.Error(w, http.StatusConflict, err.Error())
                        return
                }</span>
                // Manejo de errores generales
                // Handle general errors
                <span class="cov8" title="1">response.Error(w, http.StatusInternalServerError, err.Error())
                return</span>
        }

        // Mapea el modelo a response y retorna
        // Map model to response and return
        <span class="cov8" title="1">productResponse := mappers.GetProductResponseFromModel(&amp;newProduct)
        response.JSON(w, http.StatusCreated, responses.DataResponse{Data: productResponse})</span>
}

// Get maneja las solicitudes GET para obtener un producto específico por ID
// Get handles GET requests to retrieve a specific product by ID
func (ph *ProductHandler) Get(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Establece timeout de 3 segundos para la operación
        // Set a 3-second timeout for the operation
        ctx, cancel := context.WithTimeout(r.Context(), 3*time.Second)
        defer cancel()

        // Extrae y valida el ID del parámetro de URL
        // Extract and validate ID from URL parameter
        id, err := parseID(r)
        if err != nil </span><span class="cov8" title="1">{
                response.Error(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        // Obtiene el producto por ID del servicio
        // Get product by ID from service
        <span class="cov8" title="1">product, err := ph.service.GetByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                // Manejo de timeout
                // Handle timeout
                if errors.Is(err, context.DeadlineExceeded) </span><span class="cov8" title="1">{
                        response.Error(w, http.StatusGatewayTimeout, "the request took too long to process")
                        return
                }</span>
                // Manejo de producto no encontrado
                // Handle product not found
                <span class="cov8" title="1">if errors.Is(err, error_message.ErrNotFound) </span><span class="cov8" title="1">{
                        response.Error(w, http.StatusNotFound, err.Error())
                        return
                }</span>
                // Manejo de errores generales
                // Handle general errors
                <span class="cov8" title="1">response.Error(w, http.StatusInternalServerError, err.Error())
                return</span>
        }

        // Mapea el modelo a response y retorna
        // Map model to response and return
        <span class="cov8" title="1">productResponse := mappers.GetProductResponseFromModel(&amp;product)
        response.JSON(w, http.StatusOK, responses.DataResponse{Data: productResponse})</span>
}

// Update maneja las solicitudes PUT para actualizar un producto existente
// Update handles PUT requests to update an existing product
func (ph *ProductHandler) Update(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Establece timeout de 3 segundos para la operación
        // Set a 3-second timeout for the operation
        ctx, cancel := context.WithTimeout(r.Context(), 3*time.Second)
        defer cancel()

        // Extrae y valida el ID del parámetro de URL
        // Extract and validate ID from URL parameter
        id, err := parseID(r)
        if err != nil </span><span class="cov8" title="1">{
                response.Error(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        // Decodifica el JSON del request
        // Decode JSON from request
        <span class="cov8" title="1">var productRequest requests.ProductRequest
        if err := request.JSON(r, &amp;productRequest); err != nil </span><span class="cov8" title="1">{
                response.Error(w, http.StatusBadRequest, "Invalid request payload: "+err.Error())
                return
        }</span>

        // Mapea el request a modelo de dominio
        // Map request to domain model
        <span class="cov8" title="1">productToUpdate := mappers.GetProductFromRequest(productRequest)

        // Actualiza el producto a través del servicio
        // Update product through service
        updatedProduct, err := ph.service.Update(ctx, id, productToUpdate)
        if err != nil </span><span class="cov8" title="1">{
                // Manejo de timeout
                // Handle timeout
                if errors.Is(err, context.DeadlineExceeded) </span><span class="cov8" title="1">{
                        response.Error(w, http.StatusGatewayTimeout, "the request took too long to process")
                        return
                }</span>
                // Manejo de producto no encontrado
                // Handle product not found
                <span class="cov8" title="1">if errors.Is(err, error_message.ErrNotFound) </span><span class="cov8" title="1">{
                        response.Error(w, http.StatusNotFound, err.Error())
                        return
                }</span>
                // Manejo de errores generales
                // Handle general errors
                <span class="cov8" title="1">response.Error(w, http.StatusInternalServerError, err.Error())
                return</span>
        }

        // Mapea el modelo a response y retorna
        // Map model to response and return
        <span class="cov8" title="1">productResponse := mappers.GetProductResponseFromModel(&amp;updatedProduct)
        response.JSON(w, http.StatusOK, responses.DataResponse{Data: productResponse})</span>
}

// Delete maneja las solicitudes DELETE para eliminar un producto
// Delete handles DELETE requests to remove a product
func (ph *ProductHandler) Delete(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Establece timeout de 3 segundos para la operación
        // Set a 3-second timeout for the operation
        ctx, cancel := context.WithTimeout(r.Context(), 3*time.Second)
        defer cancel()

        // Extrae y valida el ID del parámetro de URL
        // Extract and validate ID from URL parameter
        id, err := parseID(r)
        if err != nil </span><span class="cov8" title="1">{
                response.Error(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        // Elimina el producto a través del servicio
        // Delete product through service
        <span class="cov8" title="1">if err := ph.service.Delete(ctx, id); err != nil </span><span class="cov8" title="1">{
                // Manejo de timeout
                // Handle timeout
                if errors.Is(err, context.DeadlineExceeded) </span><span class="cov8" title="1">{
                        response.Error(w, http.StatusGatewayTimeout, "the request took too long to process")
                        return
                }</span>
                // Manejo de producto no encontrado
                // Handle product not found
                <span class="cov8" title="1">if errors.Is(err, error_message.ErrNotFound) </span><span class="cov8" title="1">{
                        response.Error(w, http.StatusNotFound, err.Error())
                        return
                }</span>
                // Manejo de errores generales
                // Handle general errors
                <span class="cov8" title="1">response.Error(w, http.StatusInternalServerError, err.Error())
                return</span>
        }

        // Respuesta exitosa sin contenido
        // Successful response with no content
        <span class="cov8" title="1">w.WriteHeader(http.StatusNoContent)</span>
}

// parseID extrae y valida el parámetro ID de la URL
// parseID extracts and validates the ID parameter from the URL
func parseID(r *http.Request) (int64, error) <span class="cov8" title="1">{
        idStr := chi.URLParam(r, "id")
        if idStr == "" </span><span class="cov8" title="1">{
                return 0, errors.New("id parameter is required")
        }</span>
        <span class="cov8" title="1">id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("invalid id parameter: '%s' is not a valid number", idStr)
        }</span>
        <span class="cov8" title="1">return id, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package handlers

import (
        "context"
        "errors"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/bootcamp-go/web/request"
        "github.com/bootcamp-go/web/response"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/error_message"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/responses"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/mappers"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/services"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/validations"
)

// ProductRecordHandlerI - Interface defining the contract for product record HTTP handlers
// ProductRecordHandlerI - Interfaz que define el contrato para los manejadores HTTP de registros de productos
type ProductRecordHandlerI interface {
        // Create - Handles HTTP POST requests for creating product records
        // Create - Maneja las peticiones HTTP POST para crear registros de productos
        Create(w http.ResponseWriter, r *http.Request)

        // GetReportByIdProduct - Handles HTTP GET requests for product record reports
        // GetReportByIdProduct - Maneja las peticiones HTTP GET para reportes de registros de productos
        GetReport(w http.ResponseWriter, r *http.Request)
}

// productRecordHandler - Handler layer implementation for product record HTTP operations
// productRecordHandler - Implementación de la capa de handler para operaciones HTTP de registros de productos
type productRecordHandler struct {
        Service services.ProductRecordServiceI // Service layer dependency for business logic / Dependencia de la capa de servicio para lógica de negocio
}

// NewProductRecordHandler - Constructor function that creates a new handler instance with service dependency injection
// NewProductRecordHandler - Función constructora que crea una nueva instancia del handler con inyección de dependencias del servicio
func NewProductRecordHandler(service services.ProductRecordServiceI) ProductRecordHandlerI <span class="cov0" title="0">{
        return &amp;productRecordHandler{Service: service}
}</span>

// Create - HTTP handler for creating product records with full request processing pipeline
// Create - Manejador HTTP para crear registros de productos con pipeline completo de procesamiento de peticiones
func (prh *productRecordHandler) Create(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // CONTEXT MANAGEMENT: Create context with timeout for request processing
        // GESTIÓN DE CONTEXTO: Crear contexto con timeout para procesamiento de peticiones
        ctx, cancel := context.WithTimeout(r.Context(), 3*time.Second)
        defer cancel() // Ensure context is cancelled to prevent resource leaks / Asegurar que el contexto se cancele para prevenir fugas de recursos

        var productRecordRequest requests.ProductRecordRequest

        // REQUEST PARSING: Parse JSON request body into structured data
        // ANÁLISIS DE PETICIÓN: Analizar el cuerpo de la petición JSON en datos estructurados
        err := request.JSON(r, &amp;productRecordRequest)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        // INPUT VALIDATION: Validate request structure and business rules
        // VALIDACIÓN DE ENTRADA: Validar estructura de petición y reglas de negocio
        <span class="cov0" title="0">v := validations.GetProductRecordValidation()
        err = v.ValidateProductRecordRequestStruct(productRecordRequest)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusUnprocessableEntity, err.Error())
                return
        }</span>

        // DATA TRANSFORMATION: Convert request DTO to domain model
        // TRANSFORMACIÓN DE DATOS: Convertir DTO de petición a modelo de dominio
        <span class="cov0" title="0">productRecord := mappers.GetProductRecordFromRequest(productRecordRequest)

        // BUSINESS LOGIC DELEGATION: Call service layer for business processing
        // DELEGACIÓN DE LÓGICA DE NEGOCIO: Llamar a la capa de servicio para procesamiento de negocio
        result, err := prh.Service.CreateProductRecord(ctx, productRecord)

        if err != nil </span><span class="cov0" title="0">{
                // ERROR MAPPING: Map business errors to appropriate HTTP status codes
                // MAPEO DE ERRORES: Mapear errores de negocio a códigos de estado HTTP apropiados
                if errors.Is(err, error_message.ErrDependencyNotFound) </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusConflict, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">response.Error(w, http.StatusInternalServerError, err.Error())
                return</span>
        }

        // RESPONSE FORMATTING: Transform domain model to response DTO and return success
        // FORMATEO DE RESPUESTA: Transformar modelo de dominio a DTO de respuesta y retornar éxito
        <span class="cov0" title="0">productRecordResponse := mappers.GetProductRecordResponseFromModel(result)
        response.JSON(w, http.StatusCreated, responses.DataResponse{
                Data: productRecordResponse,
        })</span>
}

// GetReport - HTTP handler for retrieving product record reports with URL parameter processing
// GetReport - Manejador HTTP para obtener reportes de registros de productos con procesamiento de parámetros URL
func (prh *productRecordHandler) GetReport(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // CONTEXT MANAGEMENT: Create context with longer timeout for report generation
        // GESTIÓN DE CONTEXTO: Crear contexto con timeout más largo para generación de reportes
        ctx, cancel := context.WithTimeout(r.Context(), 3*time.Second)
        defer cancel() // Ensure context is cancelled to prevent resource leaks / Asegurar que el contexto se cancele para prevenir fugas de recursos

        // URL PARAMETER EXTRACTION: Extract and validate ID parameter from query string
        // EXTRACCIÓN DE PARÁMETROS URL: Extraer y validar parámetro ID del query string
        idString := strings.TrimSpace(r.URL.Query().Get("id"))

        if idString == "" </span><span class="cov0" title="0">{
                report, err := prh.Service.GetReport(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusInternalServerError, err.Error())
                        return
                }</span>

                <span class="cov0" title="0">response.JSON(w, http.StatusOK, responses.DataResponse{Data: report})</span>

        } else<span class="cov0" title="0"> {

                // INPUT SANITIZATION: Convert string ID to integer with validation
                // SANITIZACIÓN DE ENTRADA: Convertir ID string a entero con validación
                idInt, err := strconv.Atoi(idString)
                if err != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusBadRequest, "error: id not is a number")
                        return
                }</span>

                // BUSINESS LOGIC DELEGATION: Call service layer for report generation
                // DELEGACIÓN DE LÓGICA DE NEGOCIO: Llamar a la capa de servicio para generación de reportes
                <span class="cov0" title="0">productRecordReport, err := prh.Service.GetReportByIdProduct(ctx, int64(idInt))

                if err != nil </span><span class="cov0" title="0">{
                        // ERROR MAPPING: Map service layer errors to HTTP status codes
                        // MAPEO DE ERRORES: Mapear errores de capa de servicio a códigos de estado HTTP
                        if errors.Is(err, error_message.ErrDependencyNotFound) </span><span class="cov0" title="0">{
                                response.Error(w, http.StatusConflict, err.Error())
                                return
                        }</span>
                        <span class="cov0" title="0">response.Error(w, http.StatusInternalServerError, err.Error())
                        return</span>
                }

                // RESPONSE FORMATTING: Format successful response with report data as array
                // FORMATEO DE RESPUESTA: Formatear respuesta exitosa con datos del reporte como array
                <span class="cov0" title="0">response.JSON(w, http.StatusOK, responses.DataResponse{
                        Data: []*models.ProductRecordReport{productRecordReport},
                })</span>

        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package handlers

import (
        "context"
        "errors"
        "net/http"
        "strconv"
        "time"

        "github.com/bootcamp-go/web/request"
        "github.com/bootcamp-go/web/response"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/error_message"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/responses"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/mappers"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/services"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/validations"
)

// GetPurchaseOrderHandler creates and returns a new instance of PurchaseOrderHandler with the required service
// GetPurchaseOrderHandler crea y retorna una nueva instancia de PurchaseOrderHandler con el servicio requerido
func GetPurchaseOrderHandler(service services.PurchaseOrderServiceI) PurchaseOrderHandlerI <span class="cov0" title="0">{
        return &amp;PurchaseOrderHandler{
                service: service,
        }
}</span>

// PurchaseOrderHandlerI defines the contract for purchase order HTTP handlers
// PurchaseOrderHandlerI define el contrato para los manejadores HTTP de órdenes de compra
type PurchaseOrderHandlerI interface {
        GetAll() http.HandlerFunc
        GetPurchaseOrdersReport() http.HandlerFunc
        PostPurchaseOrder() http.HandlerFunc
}

// PurchaseOrderHandler implements PurchaseOrderHandlerI and handles HTTP requests for purchase order operations
// PurchaseOrderHandler implementa PurchaseOrderHandlerI y maneja las solicitudes HTTP para operaciones de órdenes de compra
type PurchaseOrderHandler struct {
        service services.PurchaseOrderServiceI // Service layer for purchase order business logic / Capa de servicio para lógica de negocio de órdenes de compra
}

// PostPurchaseOrder handles HTTP POST requests to create a new purchase order
// Validates the request body and returns appropriate HTTP status codes
// PostPurchaseOrder maneja las solicitudes HTTP POST para crear una nueva orden de compra
// Valida el cuerpo de la solicitud y retorna códigos de estado HTTP apropiados
func (h *PurchaseOrderHandler) PostPurchaseOrder() http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Set timeout context for the request / Establecer contexto con timeout para la solicitud
                ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
                defer cancel()

                var (
                        requestResponse *responses.DataResponse       = &amp;responses.DataResponse{}
                        requestOrder    requests.PurchaseOrderRequest = requests.PurchaseOrderRequest{}
                )

                // Parse and validate JSON request body / Parsear y validar cuerpo de solicitud JSON
                err := request.JSON(r, &amp;requestOrder)
                if err != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusBadRequest, err.Error())
                        return
                }</span>

                // Validate request structure and business rules / Validar estructura de solicitud y reglas de negocio
                <span class="cov0" title="0">err = validations.ValidatePurchaseOrderRequestStruct(requestOrder)
                if err != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusUnprocessableEntity, err.Error())
                        return
                }</span>

                // Map request to model and create through service / Mapear solicitud a modelo y crear a través del servicio
                <span class="cov0" title="0">modelOrder := mappers.GetModelPurchaseOrderFromRequest(requestOrder)
                orderDb, err := h.service.Create(ctx, *modelOrder)
                if err != nil </span><span class="cov0" title="0">{
                        // Handle specific error types / Manejar tipos de error específicos
                        if errors.Is(err, error_message.ErrAlreadyExists) </span><span class="cov0" title="0">{
                                response.Error(w, http.StatusConflict, err.Error())
                                return
                        }</span>

                        <span class="cov0" title="0">if errors.Is(err, error_message.ErrNotFound) </span><span class="cov0" title="0">{
                                response.Error(w, http.StatusConflict, err.Error())
                                return
                        }</span>

                        <span class="cov0" title="0">response.Error(w, http.StatusInternalServerError, err.Error())
                        return</span>
                }

                // Map model to response format / Mapear modelo a formato de respuesta
                <span class="cov0" title="0">orderResponse := mappers.GetResponsePurchaseOrderFromModel(&amp;orderDb)
                requestResponse.Data = orderResponse

                response.JSON(w, http.StatusCreated, requestResponse)</span>
        }
}

// GetAll handles HTTP GET requests to retrieve all purchase orders
// Returns a JSON response with all purchase orders or appropriate error codes
// GetAll maneja las solicitudes HTTP GET para recuperar todas las órdenes de compra
// Retorna una respuesta JSON con todas las órdenes de compra o códigos de error apropiados
func (h *PurchaseOrderHandler) GetAll() http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Set timeout context for the request / Establecer contexto con timeout para la solicitud
                ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
                defer cancel()
                var (
                        requestResponse       *responses.DataResponse = &amp;responses.DataResponse{}
                        purchaseOrderResponse []*responses.PurchaseOrderResponse
                        purchaseOrders        []*models.PurchaseOrder
                )

                // Get all purchase orders from service layer / Obtener todas las órdenes de compra de la capa de servicio
                purchaseOrdersMap, err := h.service.GetAll(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusInternalServerError, err.Error())
                }</span>

                // Convert map to slice and map to response format / Convertir mapa a slice y mapear a formato de respuesta
                <span class="cov0" title="0">purchaseOrders = purchaseOrderMapToPurchaseOrderList(purchaseOrdersMap)
                purchaseOrderResponse = mappers.GetListPurchaseOrderResponseFromListModel(purchaseOrders)

                requestResponse.Data = purchaseOrderResponse
                response.JSON(w, http.StatusOK, requestResponse)</span>
        }
}

// GetPurchaseOrdersReport handles HTTP GET requests to retrieve purchase order reports
// Accepts an optional 'id' query parameter to filter by buyer ID
// GetPurchaseOrdersReport maneja las solicitudes HTTP GET para recuperar reportes de órdenes de compra
// Acepta un parámetro de consulta 'id' opcional para filtrar por ID de comprador
func (h *PurchaseOrderHandler) GetPurchaseOrdersReport() http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Set timeout context for the request / Establecer contexto con timeout para la solicitud
                ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
                defer cancel()
                var requestResponse *responses.DataResponse = &amp;responses.DataResponse{}
                var idRequest *int = nil

                // Get and validate optional buyer ID query parameter / Obtener y validar parámetro opcional de consulta ID de comprador
                idParam := r.URL.Query().Get("id")
                if idParam != "" </span><span class="cov0" title="0">{
                        // Parse and validate buyer ID / Parsear y validar ID de comprador
                        id, err := strconv.Atoi(r.URL.Query().Get("id"))
                        if err != nil </span><span class="cov0" title="0">{
                                response.Error(w, http.StatusBadRequest, err.Error())
                                return
                        }</span>
                        <span class="cov0" title="0">idRequest = &amp;id</span>
                }

                // Get purchase order reports from service layer / Obtener reportes de órdenes de compra de la capa de servicio
                <span class="cov0" title="0">report, err := h.service.GetPurchaseOrdersReport(ctx, idRequest)
                if err != nil </span><span class="cov0" title="0">{
                        // Handle specific error types / Manejar tipos de error específicos
                        if errors.Is(err, error_message.ErrNotFound) </span><span class="cov0" title="0">{
                                response.Error(w, http.StatusNotFound, err.Error())
                                return
                        }</span>
                        <span class="cov0" title="0">response.Error(w, http.StatusInternalServerError, err.Error())
                        return</span>
                }

                <span class="cov0" title="0">requestResponse.Data = report
                response.JSON(w, http.StatusOK, requestResponse)</span>
        }
}

// purchaseOrderMapToPurchaseOrderList converts a map of purchase orders to a slice of purchase order pointers
// Helper function for data transformation in the handler layer
// purchaseOrderMapToPurchaseOrderList convierte un mapa de órdenes de compra a un slice de punteros de órdenes de compra
// Función auxiliar para transformación de datos en la capa de manejadores
func purchaseOrderMapToPurchaseOrderList(orders map[int]models.PurchaseOrder) []*models.PurchaseOrder <span class="cov0" title="0">{
        ordersList := []*models.PurchaseOrder{}

        for _, order := range orders </span><span class="cov0" title="0">{
                ordersList = append(ordersList, &amp;order)
        }</span>

        <span class="cov0" title="0">return ordersList</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package handlers

import (
        "context"
        "encoding/json"
        "net/http"
        "strconv"
        "time"

        "github.com/bootcamp-go/web/response"
        "github.com/go-chi/chi/v5"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/responses"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/mappers"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/services"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/validations"
)

// GetSectionHandler creates and returns a new instance of SectionHandler with required services and validation
// GetSectionHandler crea y retorna una nueva instancia de SectionHandler con los servicios y validación requeridos
func GetSectionHandler(service services.SectionServiceI, warehouseService services.WarehouseService, validation *validations.SectionValidation) SectionHandlerI <span class="cov0" title="0">{
        return &amp;SectionHandler{
                service:          service,
                warehouseService: warehouseService,
                validation:       validation,
        }
}</span>

// SectionHandlerI defines the contract for section HTTP handlers with RESTful operations
// SectionHandlerI define el contrato para los manejadores HTTP de secciones con operaciones RESTful
type SectionHandlerI interface {
        GetAll(w http.ResponseWriter, r *http.Request)
        GetByID(w http.ResponseWriter, r *http.Request)
        Create(w http.ResponseWriter, r *http.Request)
        Update(w http.ResponseWriter, r *http.Request)
        DeleteByID(w http.ResponseWriter, r *http.Request)
}

// SectionHandler implements SectionHandlerI and handles HTTP requests for section operations
// SectionHandler implementa SectionHandlerI y maneja las solicitudes HTTP para operaciones de secciones
type SectionHandler struct {
        service          services.SectionServiceI       // Service layer for section business logic / Capa de servicio para lógica de negocio de secciones
        warehouseService services.WarehouseService      // Service layer for warehouse validation / Capa de servicio para validación de almacenes
        validation       *validations.SectionValidation // Validation layer for section requests / Capa de validación para solicitudes de secciones
}

// GetAll handles HTTP GET requests to retrieve all sections
// Returns a JSON response with all sections or appropriate error codes
// GetAll maneja las solicitudes HTTP GET para recuperar todas las secciones
// Retorna una respuesta JSON con todas las secciones o códigos de error apropiados
func (h *SectionHandler) GetAll(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var responseJson *responses.DataResponse = &amp;responses.DataResponse{}

        // Set timeout context for the request / Establecer contexto con timeout para la solicitud
        ctx, cancel := context.WithTimeout(r.Context(), 3*time.Second)
        defer cancel()

        // Get all sections from service layer / Obtener todas las secciones de la capa de servicio
        sections, srvErr := h.service.GetAll(ctx)
        if srvErr != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusNotFound, srvErr.Error())
                return
        }</span>

        // Map models to response format / Mapear modelos a formato de respuesta
        <span class="cov0" title="0">responseJson.Data = mappers.GetListSectionResponseFromListModel(sections)
        response.JSON(w, http.StatusOK, responseJson)</span>
}

// GetByID handles HTTP GET requests to retrieve a section by ID
// Extracts the ID from the URL parameter and returns the section data or appropriate error codes
// GetByID maneja las solicitudes HTTP GET para recuperar una sección por ID
// Extrae el ID del parámetro de URL y retorna los datos de la sección o códigos de error apropiados
func (h *SectionHandler) GetByID(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var responseJson *responses.DataResponse = &amp;responses.DataResponse{}

        // Set timeout context for the request / Establecer contexto con timeout para la solicitud
        ctx, cancel := context.WithTimeout(r.Context(), 3*time.Second)
        defer cancel()

        // Extract and validate ID parameter from URL / Extraer y validar parámetro ID de la URL
        idParam, convErr := strconv.Atoi(chi.URLParam(r, "id"))
        if convErr != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusExpectationFailed, convErr.Error())
                return
        }</span>

        // Get section by ID from service layer / Obtener sección por ID de la capa de servicio
        <span class="cov0" title="0">section, srvErr := h.service.GetByID(ctx, idParam)
        if srvErr != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusNotFound, srvErr.Error())
                return
        }</span>

        // Map model to response format / Mapear modelo a formato de respuesta
        <span class="cov0" title="0">responseJson.Data = mappers.GetSectionResponseFromModel(section)
        response.JSON(w, http.StatusOK, responseJson)</span>
}

// Create handles HTTP POST requests to create a new section
// Validates dependencies (warehouse) and creates the section with business rules validation
// Create maneja las solicitudes HTTP POST para crear una nueva sección
// Valida dependencias (almacén) y crea la sección con validación de reglas de negocio
func (h *SectionHandler) Create(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var (
                request      *requests.SectionRequest = &amp;requests.SectionRequest{}
                responseJson *responses.DataResponse  = &amp;responses.DataResponse{}
                section      *models.Section
        )

        // Set timeout context for the request / Establecer contexto con timeout para la solicitud
        ctx, cancel := context.WithTimeout(r.Context(), 3*time.Second)
        defer cancel()

        // Parse and validate JSON request body / Parsear y validar cuerpo de solicitud JSON
        if reqErr := json.NewDecoder(r.Body).Decode(request); reqErr != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusExpectationFailed, reqErr.Error())
                return
        }</span>

        // Validate request structure and business rules / Validar estructura de solicitud y reglas de negocio
        <span class="cov0" title="0">if valErr := h.validation.ValidateSectionRequestStruct(*request); valErr != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusUnprocessableEntity, valErr.Error())
                return
        }</span>

        // Validate that warehouse exists / Validar que el almacén exista
        <span class="cov0" title="0">_, srvErr := h.warehouseService.GetById(ctx, request.WarehouseID)
        if srvErr != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusNotFound, srvErr.Error())
                return
        }</span>

        // Map request to section model / Mapear solicitud a modelo de sección
        <span class="cov0" title="0">section = mappers.GetSectionModelFromRequest(request)

        // Validate section number uniqueness / Validar unicidad del número de sección
        if h.service.ExistsWithSectionNumber(ctx, section.Id, section.SectionNumber) </span><span class="cov0" title="0">{
                response.Error(w, http.StatusConflict, "already exist a section with the same number")
                return
        }</span>

        // Create section through service layer / Crear sección a través de la capa de servicio
        <span class="cov0" title="0">if srvErr := h.service.Create(ctx, section); srvErr != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusExpectationFailed, srvErr.Error())
                return
        }</span>

        // Map model to response format / Mapear modelo a formato de respuesta
        <span class="cov0" title="0">responseJson.Data = mappers.GetSectionResponseFromModel(section)
        response.JSON(w, http.StatusCreated, responseJson)</span>
}

// Update handles HTTP PUT requests to update an existing section
// Extracts the ID from the URL parameter and updates the section with validation
// Update maneja las solicitudes HTTP PUT para actualizar una sección existente
// Extrae el ID del parámetro de URL y actualiza la sección con validación
func (h *SectionHandler) Update(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var (
                request      *requests.SectionRequest = &amp;requests.SectionRequest{}
                responseJson *responses.DataResponse  = &amp;responses.DataResponse{}
        )

        // Set timeout context for the request / Establecer contexto con timeout para la solicitud
        ctx, cancel := context.WithTimeout(r.Context(), 3*time.Second)
        defer cancel()

        // Extract and validate ID parameter from URL / Extraer y validar parámetro ID de la URL
        idParam, convErr := strconv.Atoi(chi.URLParam(r, "id"))
        if convErr != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusExpectationFailed, convErr.Error())
                return
        }</span>

        // Get existing section by ID / Obtener sección existente por ID
        <span class="cov0" title="0">section, srvErr := h.service.GetByID(ctx, idParam)
        if srvErr != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusNotFound, srvErr.Error())
                return
        }</span>

        // Parse and validate JSON request body / Parsear y validar cuerpo de solicitud JSON
        <span class="cov0" title="0">if reqErr := json.NewDecoder(r.Body).Decode(request); reqErr != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusExpectationFailed, reqErr.Error())
                return
        }</span>

        // Validate request structure and business rules / Validar estructura de solicitud y reglas de negocio
        <span class="cov0" title="0">if valErr := h.validation.ValidateSectionRequestStruct(*request); valErr != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusUnprocessableEntity, valErr.Error())
                return
        }</span>

        // Validate section number uniqueness for update / Validar unicidad del número de sección para actualización
        <span class="cov0" title="0">if h.service.ExistsWithSectionNumber(ctx, section.Id, request.SectionNumber) </span><span class="cov0" title="0">{
                response.Error(w, http.StatusConflict, "already exist a section with the same number")
                return
        }</span>

        // Update section model with request data / Actualizar modelo de sección con datos de la solicitud
        <span class="cov0" title="0">mappers.UpdateSectionModelFromRequest(section, request)
        if srvErr := h.service.Update(ctx, section); srvErr != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusExpectationFailed, srvErr.Error())
                return
        }</span>

        // Map model to response format / Mapear modelo a formato de respuesta
        <span class="cov0" title="0">responseJson.Data = mappers.GetSectionResponseFromModel(section)
        response.JSON(w, http.StatusOK, responseJson)</span>
}

// DeleteByID handles HTTP DELETE requests to remove a section by ID
// Extracts the ID from the URL parameter and deletes the section
// DeleteByID maneja las solicitudes HTTP DELETE para eliminar una sección por ID
// Extrae el ID del parámetro de URL y elimina la sección
func (h *SectionHandler) DeleteByID(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Set timeout context for the request / Establecer contexto con timeout para la solicitud
        ctx, cancel := context.WithTimeout(r.Context(), 3*time.Second)
        defer cancel()

        // Extract and validate ID parameter from URL / Extraer y validar parámetro ID de la URL
        idParam, convErr := strconv.Atoi(chi.URLParam(r, "id"))
        if convErr != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusExpectationFailed, convErr.Error())
                return
        }</span>

        // Delete section through service layer / Eliminar sección a través de la capa de servicio
        <span class="cov0" title="0">srvErr := h.service.DeleteByID(ctx, idParam)
        if srvErr != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusNotFound, srvErr.Error())
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "strconv"

        "github.com/bootcamp-go/web/response"
        "github.com/go-chi/chi/v5"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/responses"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/mappers"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/validations"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/services"
)

// SellerHandler handles HTTP requests for seller operations
// SellerHandler maneja las solicitudes HTTP para operaciones de vendedores
type SellerHandler struct {
        service services.SellerService // Service layer for seller business logic / Capa de servicio para lógica de negocio de vendedores
}

// NewSellerHandler creates and returns a new instance of SellerHandler with the required service
// NewSellerHandler crea y retorna una nueva instancia de SellerHandler con el servicio requerido
func NewSellerHandler(service services.SellerService) *SellerHandler <span class="cov0" title="0">{
        return &amp;SellerHandler{service: service}
}</span>

// GetAll handles HTTP GET requests to retrieve all sellers
// Returns a JSON response with all sellers or appropriate error codes
// GetAll maneja las solicitudes HTTP GET para recuperar todos los vendedores
// Retorna una respuesta JSON con todos los vendedores o códigos de error apropiados
func (h *SellerHandler) GetAll(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Get all sellers from service layer / Obtener todos los vendedores de la capa de servicio
        sellers, err := h.service.GetAll()
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusNotFound, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.JSON(w, http.StatusOK, responses.DataResponse{Data: sellers})</span>
}

// GetById handles HTTP GET requests to retrieve a seller by ID
// Extracts the ID from the URL parameter and returns the seller data or appropriate error codes
// GetById maneja las solicitudes HTTP GET para recuperar un vendedor por ID
// Extrae el ID del parámetro de URL y retorna los datos del vendedor o códigos de error apropiados
func (h *SellerHandler) GetById(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Extract ID parameter from URL / Extraer parámetro ID de la URL
        id := chi.URLParam(r, "id")

        // Parse and validate ID parameter / Parsear y validar parámetro ID
        idFormated, err := strconv.Atoi(id)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        // Get seller by ID from service layer / Obtener vendedor por ID de la capa de servicio
        <span class="cov0" title="0">seller, err1 := h.service.GetById(idFormated)
        if err1 != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusNotFound, err1.Error())
                return
        }</span>

        <span class="cov0" title="0">response.JSON(w, http.StatusOK, responses.DataResponse{Data: seller})</span>
}

// Save handles HTTP POST requests to create a new seller
// Validates the request body and returns appropriate HTTP status codes
// Save maneja las solicitudes HTTP POST para crear un nuevo vendedor
// Valida el cuerpo de la solicitud y retorna códigos de estado HTTP apropiados
func (h *SellerHandler) Save(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var sellerToCreate requests.SellerRequest
        data := r.Body

        // Parse and validate JSON request body / Parsear y validar cuerpo de solicitud JSON
        errorBody := json.NewDecoder(data).Decode(&amp;sellerToCreate)
        if errorBody != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, errorBody.Error())
                return
        }</span>

        // Validate request structure and business rules / Validar estructura de solicitud y reglas de negocio
        <span class="cov0" title="0">if err := validations.ValidateSellerRequestStruct(sellerToCreate); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusUnprocessableEntity, err.Error())
                return
        }</span>

        // Map request to seller model / Mapear solicitud a modelo de vendedor
        <span class="cov0" title="0">sellerParced := mappers.ToRequestToSellerStruct(sellerToCreate)

        // Create seller through service layer / Crear vendedor a través de la capa de servicio
        sellerCreated, err := h.service.Save(sellerParced)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusConflict, err.Error())
                return
        }</span>

        // Map model to response format / Mapear modelo a formato de respuesta
        <span class="cov0" title="0">sellerResponse := mappers.ToSellerStructToResponse(sellerCreated[0])

        response.JSON(w, http.StatusOK, responses.DataResponse{Data: sellerResponse})</span>
}

// Update handles HTTP PUT requests to update an existing seller
// Extracts the ID from the URL parameter and updates the seller data
// Update maneja las solicitudes HTTP PUT para actualizar un vendedor existente
// Extrae el ID del parámetro de URL y actualiza los datos del vendedor
func (h *SellerHandler) Update(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Extract and validate ID parameter from URL / Extraer y validar parámetro ID de la URL
        id := chi.URLParam(r, "id")
        if id == "" </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "id is required")
                return
        }</span>

        // Parse and validate ID parameter / Parsear y validar parámetro ID
        <span class="cov0" title="0">idFormated, err := strconv.Atoi(id)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        // Parse and validate JSON request body / Parsear y validar cuerpo de solicitud JSON
        <span class="cov0" title="0">data := r.Body
        var bodyFormated requests.SellerRequest
        errBody := json.NewDecoder(data).Decode(&amp;bodyFormated)
        if errBody != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, errBody.Error())
                return
        }</span>

        // Map request to seller model and update through service / Mapear solicitud a modelo de vendedor y actualizar a través del servicio
        <span class="cov0" title="0">sellerToUpdate := mappers.ToRequestToSellerStruct(bodyFormated)
        sellerUpdated, errUpdate := h.service.Update(idFormated, sellerToUpdate)
        if errUpdate != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusNotFound, errUpdate.Error())
                return
        }</span>

        <span class="cov0" title="0">response.JSON(w, http.StatusOK, responses.DataResponse{Data: sellerUpdated})</span>
}

// Delete handles HTTP DELETE requests to remove a seller by ID
// Extracts the ID from the URL parameter and deletes the seller
// Delete maneja las solicitudes HTTP DELETE para eliminar un vendedor por ID
// Extrae el ID del parámetro de URL y elimina el vendedor
func (h *SellerHandler) Delete(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Extract and validate ID parameter from URL / Extraer y validar parámetro ID de la URL
        id := chi.URLParam(r, "id")
        if id == "" </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "id is required")
                return
        }</span>

        // Parse and validate ID parameter / Parsear y validar parámetro ID
        <span class="cov0" title="0">idFormated, err := strconv.Atoi(id)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        // Delete seller through service layer / Eliminar vendedor a través de la capa de servicio
        <span class="cov0" title="0">errDelete := h.service.Delete(idFormated)
        if errDelete != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusNotFound, errDelete.Error())
                return
        }</span>

        <span class="cov0" title="0">response.JSON(w, http.StatusNoContent, nil)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package handlers

import (
        "context"
        "encoding/json"
        "errors"
        "net/http"
        "strconv"
        "time"

        "github.com/bootcamp-go/web/response"
        "github.com/go-chi/chi/v5"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/error_message"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/responses"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/mappers"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/services"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/validations"
)

// WarehouseHandler handles HTTP requests for warehouse operations
// WarehouseHandler maneja las solicitudes HTTP para operaciones de almacenes
type WarehouseHandler struct {
        warehouseService services.WarehouseService // Service layer for warehouse business logic / Capa de servicio para lógica de negocio de almacenes
}

// NewWarehouseHandler creates and returns a new instance of WarehouseHandler with the required service
// NewWarehouseHandler crea y retorna una nueva instancia de WarehouseHandler con el servicio requerido
func NewWarehouseHandler(warehouseService services.WarehouseService) *WarehouseHandler <span class="cov0" title="0">{
        return &amp;WarehouseHandler{warehouseService: warehouseService}
}</span>

// GetAll handles HTTP GET requests to retrieve all warehouses
// Returns a JSON response with all warehouses or appropriate error codes
// GetAll maneja las solicitudes HTTP GET para recuperar todos los almacenes
// Retorna una respuesta JSON con todos los almacenes o códigos de error apropiados
func (h *WarehouseHandler) GetAll(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Set timeout context for the request / Establecer contexto con timeout para la solicitud
        ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
        defer cancel()

        // Get all warehouses from service layer / Obtener todos los almacenes de la capa de servicio
        warehouses, err := h.warehouseService.GetAll(ctx)
        if err != nil </span><span class="cov0" title="0">{
                // Handle timeout errors / Manejar errores de timeout
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusRequestTimeout, "Request timeout cancelled")
                        return
                }</span>
                // Handle specific error types / Manejar tipos de error específicos
                <span class="cov0" title="0">if errors.Is(err, error_message.ErrInternalServerError) </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusInternalServerError, "Error al leer la base de datos de warehouses")
                        return
                }</span>
                <span class="cov0" title="0">response.Error(w, http.StatusInternalServerError, "Error al obtener los warehouses")
                return</span>
        }

        // Check if any warehouses were found / Verificar si se encontraron almacenes
        <span class="cov0" title="0">if len(warehouses) == 0 </span><span class="cov0" title="0">{
                response.Error(w, http.StatusNotFound, "No se encontraron almacenes")
                return
        }</span>

        // Map models to response format / Mapear modelos a formato de respuesta
        <span class="cov0" title="0">warehouseResponses := make([]responses.WarehouseResponse, 0)
        for _, warehouse := range warehouses </span><span class="cov0" title="0">{
                warehouseResponses = append(warehouseResponses, mappers.ToResponse(warehouse))
        }</span>

        <span class="cov0" title="0">response.JSON(w, http.StatusOK, responses.DataResponse{
                Data: warehouseResponses,
        })</span>
}

// Create handles HTTP POST requests to create a new warehouse
// Validates the request body, code uniqueness, and returns appropriate HTTP status codes
// Create maneja las solicitudes HTTP POST para crear un nuevo almacén
// Valida el cuerpo de la solicitud, unicidad del código y retorna códigos de estado HTTP apropiados
func (h *WarehouseHandler) Create(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Set timeout context for the request / Establecer contexto con timeout para la solicitud
        ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
        defer cancel()

        var warehouseRequest requests.WarehouseRequest

        // Parse and validate JSON request body / Parsear y validar cuerpo de solicitud JSON
        if err := json.NewDecoder(r.Body).Decode(&amp;warehouseRequest); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Formato JSON inválido")
                return
        }</span>

        // Validate request structure and business rules / Validar estructura de solicitud y reglas de negocio
        <span class="cov0" title="0">if err := validations.ValidateWarehouseRequestStruct(warehouseRequest); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        // Validate warehouse code uniqueness / Validar unicidad del código de almacén
        <span class="cov0" title="0">if err := h.warehouseService.ValidateCodeUniqueness(ctx, warehouseRequest.WareHouseCode); err != nil </span><span class="cov0" title="0">{
                // Handle timeout errors / Manejar errores de timeout
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusRequestTimeout, "Request timeout cancelled")
                        return
                }</span>
                // Handle specific error types / Manejar tipos de error específicos
                <span class="cov0" title="0">if errors.Is(err, error_message.ErrAlreadyExists) </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusConflict, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">if errors.Is(err, error_message.ErrInternalServerError) </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusInternalServerError, "Error al validar la unicidad del código en la base de datos")
                        return
                }</span>
                <span class="cov0" title="0">response.Error(w, http.StatusInternalServerError, "Error al validar el código del warehouse")
                return</span>
        }

        // Map request to warehouse model and create through service / Mapear solicitud a modelo de almacén y crear a través del servicio
        <span class="cov0" title="0">warehouse := mappers.ToRequest(warehouseRequest)
        createdWarehouse, err := h.warehouseService.Create(ctx, warehouse)
        if err != nil </span><span class="cov0" title="0">{
                // Handle timeout errors / Manejar errores de timeout
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusRequestTimeout, "Request timeout cancelled")
                        return
                }</span>
                // Handle specific error types / Manejar tipos de error específicos
                <span class="cov0" title="0">if errors.Is(err, error_message.ErrInternalServerError) </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusInternalServerError, "Error al guardar el warehouse en la base de datos")
                        return
                }</span>
                <span class="cov0" title="0">response.Error(w, http.StatusInternalServerError, "Error al crear el warehouse")
                return</span>
        }

        // Map model to response format / Mapear modelo a formato de respuesta
        <span class="cov0" title="0">warehouseResponse := mappers.ToResponse(createdWarehouse)
        response.JSON(w, http.StatusCreated, responses.DataResponse{
                Data: warehouseResponse,
        })</span>
}

// GetById handles HTTP GET requests to retrieve a warehouse by ID
// Extracts the ID from the URL parameter and returns the warehouse data or appropriate error codes
// GetById maneja las solicitudes HTTP GET para recuperar un almacén por ID
// Extrae el ID del parámetro de URL y retorna los datos del almacén o códigos de error apropiados
func (h *WarehouseHandler) GetById(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Set timeout context for the request / Establecer contexto con timeout para la solicitud
        ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
        defer cancel()

        // Extract and validate ID parameter from URL / Extraer y validar parámetro ID de la URL
        idStr := chi.URLParam(r, "id")
        if idStr == "" </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "El ID del almacén es requerido")
                return
        }</span>

        // Parse and validate ID parameter / Parsear y validar parámetro ID
        <span class="cov0" title="0">id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "El ID del almacén debe ser un número")
                return
        }</span>

        // Get warehouse by ID from service layer / Obtener almacén por ID de la capa de servicio
        <span class="cov0" title="0">warehouse, err := h.warehouseService.GetById(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                // Handle timeout errors / Manejar errores de timeout
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusRequestTimeout, "Request timeout cancelled")
                        return
                }</span>
                // Handle specific error types / Manejar tipos de error específicos
                <span class="cov0" title="0">if errors.Is(err, error_message.ErrNotFound) </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusNotFound, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">if errors.Is(err, error_message.ErrInternalServerError) </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusInternalServerError, "Error al buscar el warehouse en la base de datos")
                        return
                }</span>
                <span class="cov0" title="0">response.Error(w, http.StatusInternalServerError, "Error al obtener el warehouse")
                return</span>
        }

        // Map model to response format / Mapear modelo a formato de respuesta
        <span class="cov0" title="0">warehouseResponse := mappers.ToResponse(warehouse)
        response.JSON(w, http.StatusOK, responses.DataResponse{
                Data: warehouseResponse,
        })</span>
}

// Delete handles HTTP DELETE requests to remove a warehouse by ID
// Extracts the ID from the URL parameter and deletes the warehouse
// Delete maneja las solicitudes HTTP DELETE para eliminar un almacén por ID
// Extrae el ID del parámetro de URL y elimina el almacén
func (h *WarehouseHandler) Delete(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Set timeout context for the request / Establecer contexto con timeout para la solicitud
        ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
        defer cancel()

        // Extract and validate ID parameter from URL / Extraer y validar parámetro ID de la URL
        idStr := chi.URLParam(r, "id")
        if idStr == "" </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "El ID del almacén es requerido")
                return
        }</span>

        // Parse and validate ID parameter / Parsear y validar parámetro ID
        <span class="cov0" title="0">id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "El ID del almacén debe ser un número")
                return
        }</span>

        // Delete warehouse through service layer / Eliminar almacén a través de la capa de servicio
        <span class="cov0" title="0">if err := h.warehouseService.Delete(ctx, id); err != nil </span><span class="cov0" title="0">{
                // Handle timeout errors / Manejar errores de timeout
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusRequestTimeout, "Request timeout cancelled")
                        return
                }</span>
                // Handle specific error types / Manejar tipos de error específicos
                <span class="cov0" title="0">if errors.Is(err, error_message.ErrNotFound) </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusNotFound, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">if errors.Is(err, error_message.ErrInternalServerError) </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusInternalServerError, "Error al eliminar el warehouse de la base de datos")
                        return
                }</span>
                <span class="cov0" title="0">response.Error(w, http.StatusInternalServerError, "Error al eliminar el warehouse")
                return</span>
        }

        <span class="cov0" title="0">response.JSON(w, http.StatusNoContent, responses.DataResponse{
                Data: nil,
        })</span>
}

// Update handles HTTP PUT requests to update an existing warehouse
// Extracts the ID from the URL parameter, validates code uniqueness, and updates the warehouse
// Update maneja las solicitudes HTTP PUT para actualizar un almacén existente
// Extrae el ID del parámetro de URL, valida unicidad del código y actualiza el almacén
func (h *WarehouseHandler) Update(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Set timeout context for the request / Establecer contexto con timeout para la solicitud
        ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
        defer cancel()

        // Extract and validate ID parameter from URL / Extraer y validar parámetro ID de la URL
        idStr := chi.URLParam(r, "id")
        if idStr == "" </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "El ID del almacén es requerido")
                return
        }</span>

        // Parse and validate ID parameter / Parsear y validar parámetro ID
        <span class="cov0" title="0">id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "El ID del almacén debe ser un número")
                return
        }</span>

        // Get existing warehouse by ID for comparison / Obtener almacén existente por ID para comparación
        <span class="cov0" title="0">existingWarehouse, err := h.warehouseService.GetById(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                // Handle timeout errors / Manejar errores de timeout
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusRequestTimeout, "Request timeout cancelled")
                        return
                }</span>
                // Handle specific error types / Manejar tipos de error específicos
                <span class="cov0" title="0">if errors.Is(err, error_message.ErrNotFound) </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusNotFound, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">if errors.Is(err, error_message.ErrInternalServerError) </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusInternalServerError, "Error al buscar el warehouse en la base de datos")
                        return
                }</span>
                <span class="cov0" title="0">response.Error(w, http.StatusInternalServerError, "Error al obtener el warehouse")
                return</span>
        }

        <span class="cov0" title="0">var warehousePatchRequest requests.WarehousePatchRequest

        // Parse and validate JSON request body / Parsear y validar cuerpo de solicitud JSON
        if err := json.NewDecoder(r.Body).Decode(&amp;warehousePatchRequest); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Formato JSON inválido")
                return
        }</span>

        // Validate request structure for patch operation / Validar estructura de solicitud para operación patch
        <span class="cov0" title="0">if err := validations.ValidateWarehousePatchRequest(warehousePatchRequest); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        // Apply patch to existing warehouse / Aplicar patch al almacén existente
        <span class="cov0" title="0">updatedWarehouse := mappers.ApplyPatch(existingWarehouse, warehousePatchRequest)

        // Validate code uniqueness only if code has changed / Validar unicidad del código solo si el código ha cambiado
        if warehousePatchRequest.WareHouseCode != nil &amp;&amp; *warehousePatchRequest.WareHouseCode != existingWarehouse.WareHouseCode </span><span class="cov0" title="0">{
                if err := h.warehouseService.ValidateCodeUniqueness(ctx, *warehousePatchRequest.WareHouseCode); err != nil </span><span class="cov0" title="0">{
                        // Handle timeout errors / Manejar errores de timeout
                        if ctx.Err() != nil </span><span class="cov0" title="0">{
                                response.Error(w, http.StatusRequestTimeout, "Request timeout cancelled")
                                return
                        }</span>
                        // Handle specific error types / Manejar tipos de error específicos
                        <span class="cov0" title="0">if errors.Is(err, error_message.ErrAlreadyExists) </span><span class="cov0" title="0">{
                                response.Error(w, http.StatusConflict, err.Error())
                                return
                        }</span>
                        <span class="cov0" title="0">if errors.Is(err, error_message.ErrInternalServerError) </span><span class="cov0" title="0">{
                                response.Error(w, http.StatusInternalServerError, "Error al validar la unicidad del código en la base de datos")
                                return
                        }</span>
                        <span class="cov0" title="0">response.Error(w, http.StatusInternalServerError, "Error al validar el código del warehouse")
                        return</span>
                }
        }

        // Update warehouse through service layer / Actualizar almacén a través de la capa de servicio
        <span class="cov0" title="0">updatedWarehouse, err = h.warehouseService.Update(ctx, id, updatedWarehouse)
        if err != nil </span><span class="cov0" title="0">{
                // Handle timeout errors / Manejar errores de timeout
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusRequestTimeout, "Request timeout cancelled")
                        return
                }</span>
                // Handle specific error types / Manejar tipos de error específicos
                <span class="cov0" title="0">if errors.Is(err, error_message.ErrNotFound) </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusNotFound, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">if errors.Is(err, error_message.ErrInternalServerError) </span><span class="cov0" title="0">{
                        response.Error(w, http.StatusInternalServerError, "Error al actualizar el warehouse en la base de datos")
                        return
                }</span>
                <span class="cov0" title="0">response.Error(w, http.StatusInternalServerError, "Error al actualizar el warehouse")
                return</span>
        }

        // Map model to response format / Mapear modelo a formato de respuesta
        <span class="cov0" title="0">warehouseResponse := mappers.ToResponse(updatedWarehouse)
        response.JSON(w, http.StatusOK, responses.DataResponse{
                Data: warehouseResponse,
        })</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package mappers

import (
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/responses"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
)

// GetModelBuyerFromRequest converts a BuyerRequest to a Buyer model
// Sets the ID to 0 as it will be generated by the database
func GetModelBuyerFromRequest(br requests.BuyerRequest) *models.Buyer <span class="cov0" title="0">{
        return &amp;models.Buyer{
                Id:           0,
                CardNumberId: br.CardNumberId,
                FirstName:    br.FirstName,
                LastName:     br.LastName,
        }
}</span>

// GetResponseBuyerFromModel converts a Buyer model to a BuyerResponse
func GetResponseBuyerFromModel(b *models.Buyer) *responses.BuyerResponse <span class="cov0" title="0">{
        return &amp;responses.BuyerResponse{
                Id:           b.Id,
                CardNumberId: b.CardNumberId,
                FirstName:    b.FirstName,
                LastName:     b.LastName,
        }
}</span>

// GetListBuyerResponseFromListModel converts a slice of Buyer models to a slice of BuyerResponse
func GetListBuyerResponseFromListModel(models []*models.Buyer) []*responses.BuyerResponse <span class="cov0" title="0">{
        var listBuyerResponse []*responses.BuyerResponse

        for _, buyer := range models </span><span class="cov0" title="0">{
                listBuyerResponse = append(listBuyerResponse, GetResponseBuyerFromModel(buyer))
        }</span>

        <span class="cov0" title="0">return listBuyerResponse</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package mappers

import (
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/responses"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
)

func MapCarryToCreateCarryResponse(carry models.Carry) responses.CreateCarryResponse <span class="cov0" title="0">{
        return responses.CreateCarryResponse{
                Id:          carry.Id,
                Cid:         carry.Cid,
                CompanyName: carry.CompanyName,
                Address:     carry.Address,
                Telephone:   carry.Telephone,
                LocalityId:  carry.LocalityId,
        }
}</span>

func MapCarryRequestToCarry(request requests.CarryRequest) models.Carry <span class="cov0" title="0">{
        return models.Carry{
                Cid:         request.Cid,
                CompanyName: request.CompanyName,
                Address:     request.Address,
                Telephone:   request.Telephone,
                LocalityId:  request.LocalityId,
        }
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package mappers

import (
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/responses"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
)

func GetEmployeeModelFromRequest(request requests.EmployeeRequest) *models.Employee <span class="cov0" title="0">{
        return &amp;models.Employee{
                Id:           0,
                CardNumberID: request.CardNumberID,
                FirstName:    request.FirstName,
                LastName:     request.LastName,
                WarehouseID:  request.WarehouseID,
        }
}</span>

func GetEmployeeResponseFromModel(model *models.Employee) *responses.EmployeeResponse <span class="cov0" title="0">{
        return &amp;responses.EmployeeResponse{
                ID:           model.Id,
                CardNumberID: model.CardNumberID,
                FirstName:    model.FirstName,
                LastName:     model.LastName,
                WarehouseID:  model.WarehouseID,
        }
}</span>

func UpdateEmployeeModelFromRequest(model *models.Employee, request *requests.EmployeeRequest) <span class="cov0" title="0">{
        model.CardNumberID = request.CardNumberID
        model.FirstName = request.FirstName
        model.LastName = request.LastName
        model.WarehouseID = request.WarehouseID
}</span>
func GetListEmployeeResponseFromListModel(models []*models.Employee) []*responses.EmployeeResponse <span class="cov0" title="0">{
        var listEmployeeResponse []*responses.EmployeeResponse
        if len(models) &gt; 0 </span><span class="cov0" title="0">{
                for _, s := range models </span><span class="cov0" title="0">{
                        listEmployeeResponse = append(listEmployeeResponse, GetEmployeeResponseFromModel(s))
                }</span>
        }
        <span class="cov0" title="0">return listEmployeeResponse</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package mappers

import (
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/responses"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
)

func GetModelInboundOrderFromRequest(req requests.InboundOrderRequest) *models.InboundOrder <span class="cov0" title="0">{
        return &amp;models.InboundOrder{
                OrderDate:      req.Data.OrderDate,
                OrderNumber:    req.Data.OrderNumber,
                EmployeeId:     req.Data.EmployeeId,
                ProductBatchId: req.Data.ProductBatchId,
                WarehouseId:    req.Data.WarehouseId,
        }
}</span>
func GetResponseInboundOrderFromModel(po *models.InboundOrder) *responses.InboundOrderResponse <span class="cov0" title="0">{
        return &amp;responses.InboundOrderResponse{
                Id:             po.Id,
                OrderNumber:    po.OrderNumber,
                OrderDate:      po.OrderDate,
                EmployeeId:     po.EmployeeId,
                ProductBatchId: po.ProductBatchId,
                WarehouseId:    po.WarehouseId,
        }
}</span>

func GetListInboundOrderResponseFromListModel(models []*models.InboundOrder) []*responses.InboundOrderResponse <span class="cov0" title="0">{
        var listInboundOrderResponse []*responses.InboundOrderResponse

        for _, inboundOrder := range models </span><span class="cov0" title="0">{
                listInboundOrderResponse = append(listInboundOrderResponse, GetResponseInboundOrderFromModel(inboundOrder))
        }</span>

        <span class="cov0" title="0">return listInboundOrderResponse</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package mappers

import (
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
)

/*type LocalitySellerReportResponse struct {
        Data []responses.LocalitySellerResponse `json:"data"`
}*/

func ToRequestToLocalityStruct(locality requests.LocalityRequest) models.Locality <span class="cov0" title="0">{
        localityFormated := models.Locality{
                LocalityName: locality.Data.LocalityName,
                ProvinceName: locality.Data.ProvinceName,
                CountryName:  locality.Data.CountryName,
        }
        return localityFormated
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package mappers

import (
        "errors"
        "time"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/responses"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
        tools "github.com/sajimenezher_meli/meli-frescos-8/pkg"
)

func GetProductBatchModelFromRequest(request *requests.ProductBatchRequest) (*models.ProductBatch, error) <span class="cov0" title="0">{
        dueDate, convErr := tools.ConvertStringToDate(request.DueDate)
        if convErr != nil </span><span class="cov0" title="0">{
                return nil, errors.New("cannot convert the field dueDate")
        }</span>

        <span class="cov0" title="0">manufacturingDate, convErr := tools.ConvertStringToDate(request.ManufacturingDate)
        if convErr != nil </span><span class="cov0" title="0">{
                return nil, errors.New("cannot convert the field manufacturingDate")
        }</span>

        <span class="cov0" title="0">manufacturingHour := time.Date(
                manufacturingDate.Year(),
                manufacturingDate.Month(),
                manufacturingDate.Day(),
                request.ManufacturingHour,
                manufacturingDate.Minute(),
                manufacturingDate.Second(),
                manufacturingDate.Nanosecond(),
                manufacturingDate.Location(),
        )

        return &amp;models.ProductBatch{
                BatchNumber:        request.BatchNumber,
                CurrentQuantity:    request.CurrentQuantity,
                CurrentTemperature: request.CurrentTemperature,
                DueDate:            dueDate,
                InitialQuantity:    request.InitialQuantity,
                ManufacturingDate:  manufacturingDate,
                ManufacturingHour:  manufacturingHour,
                MinimumTemperature: request.MinimumTemperature,
                ProductID:          request.ProductID,
                SectionID:          request.SectionID,
        }, nil</span>
}

func GetProductBatchResponseFromModel(model *models.ProductBatch) *responses.ProductBatchResponse <span class="cov0" title="0">{
        return &amp;responses.ProductBatchResponse{
                Id:                 model.Id,
                BatchNumber:        model.BatchNumber,
                CurrentQuantity:    model.CurrentQuantity,
                CurrentTemperature: model.CurrentTemperature,
                DueDate:            model.DueDate.String(),
                InitialQuantity:    model.InitialQuantity,
                ManufacturingDate:  model.ManufacturingDate.String(),
                ManufacturingHour:  float64(model.ManufacturingHour.Hour()),
                MinimumTemperature: model.MinimumTemperature,
                ProductID:          model.ProductID,
                SectionID:          model.SectionID,
        }
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package mappers

import (
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/responses"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
)

func GetProductResponseFromModel(model *models.Product) *responses.ProductResponse <span class="cov0" title="0">{
        return &amp;responses.ProductResponse{
                ProductCode:                    model.ProductCode,
                Description:                    model.Description,
                Width:                          model.Width,
                Height:                         model.Height,
                Length:                         model.Length,
                NetWeight:                      model.NetWeight,
                ExpirationRate:                 model.ExpirationRate,
                RecommendedFreezingTemperature: model.RecommendedFreezingTemperature,
                FreezingRate:                   model.FreezingRate,
                ProductTypeID:                  model.ProductTypeID,
                SellerID:                       model.SellerID,
        }
}</span>

func GetProductFromRequest(request requests.ProductRequest) models.Product <span class="cov0" title="0">{
        return models.Product{
                ProductCode:                    request.ProductCode,
                Description:                    request.Description,
                Width:                          request.Width,
                Height:                         request.Height,
                Length:                         request.Length,
                NetWeight:                      request.NetWeight,
                ExpirationRate:                 request.ExpirationRate,
                RecommendedFreezingTemperature: request.RecommendedFreezingTemperature,
                FreezingRate:                   request.FreezingRate,
                ProductTypeID:                  request.ProductTypeID,
                SellerID:                       request.SellerID,
        }
}</span>

func GetListProductResponseFromListModel(models []*models.Product) []*responses.ProductResponse <span class="cov0" title="0">{
        var listProductResponse []*responses.ProductResponse
        if len(models) &gt; 0 </span><span class="cov0" title="0">{
                for _, s := range models </span><span class="cov0" title="0">{
                        listProductResponse = append(listProductResponse, GetProductResponseFromModel(s))
                }</span>
        }
        <span class="cov0" title="0">return listProductResponse</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package mappers

import (
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/responses"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
)

func GetProductRecordResponseFromModel(model *models.ProductRecord) *responses.ProductRecordResponse <span class="cov0" title="0">{
        return &amp;responses.ProductRecordResponse{
                LastUpdateDate: model.LastUpdateDate,
                PurchasePrice:  model.PurchasePrice,
                SalePrice:      model.SalePrice,
                ProductID:      model.ProductID,
        }
}</span>

func GetProductRecordFromRequest(request requests.ProductRecordRequest) models.ProductRecord <span class="cov0" title="0">{
        return models.ProductRecord{
                LastUpdateDate: request.LastUpdateDate,
                PurchasePrice:  request.PurchasePrice,
                SalePrice:      request.SalePrice,
                ProductID:      request.ProductID,
        }
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package mappers

import (
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/responses"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
)

// GetModelPurchaseOrderFromRequest converts a PurchaseOrderRequest to a PurchaseOrder model
// Sets the ID to 0 as it will be generated by the database
func GetModelPurchaseOrderFromRequest(por requests.PurchaseOrderRequest) *models.PurchaseOrder <span class="cov0" title="0">{
        return &amp;models.PurchaseOrder{
                Id:              0,
                OrderNumber:     por.Data.OrderNumber,
                OrderDate:       por.Data.OrderDate,
                TrackingCode:    por.Data.TrackingCode,
                BuyerId:         por.Data.BuyerId,
                ProductRecordId: por.Data.ProductRecordId,
        }
}</span>

// GetResponsePurchaseOrderFromModel converts a PurchaseOrder model to a PurchaseOrderResponse
func GetResponsePurchaseOrderFromModel(po *models.PurchaseOrder) *responses.PurchaseOrderResponse <span class="cov0" title="0">{
        return &amp;responses.PurchaseOrderResponse{
                Id:              po.Id,
                OrderNumber:     po.OrderNumber,
                OrderDate:       po.OrderDate,
                TrackingCode:    po.TrackingCode,
                BuyerId:         po.BuyerId,
                ProductRecordId: po.ProductRecordId,
        }
}</span>

// GetListPurchaseOrderResponseFromListModel converts a slice of PurchaseOrder models to a slice of PurchaseOrderResponse
func GetListPurchaseOrderResponseFromListModel(models []*models.PurchaseOrder) []*responses.PurchaseOrderResponse <span class="cov0" title="0">{
        var listPurchaseOrderResponse []*responses.PurchaseOrderResponse

        for _, purchaseOrder := range models </span><span class="cov0" title="0">{
                listPurchaseOrderResponse = append(listPurchaseOrderResponse, GetResponsePurchaseOrderFromModel(purchaseOrder))
        }</span>

        <span class="cov0" title="0">return listPurchaseOrderResponse</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package mappers

import (
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/responses"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
)

func GetSectionModelFromRequest(request *requests.SectionRequest) *models.Section <span class="cov0" title="0">{
        return &amp;models.Section{
                SectionNumber:      request.SectionNumber,
                CurrentCapacity:    request.CurrentCapacity,
                CurrentTemperature: request.CurrentTemperature,
                MaximumCapacity:    request.MaximumCapacity,
                MinimumCapacity:    request.MinimumCapacity,
                MinimumTemperature: request.MinimumTemperature,
                ProductTypeID:      request.ProductTypeID,
                WarehouseID:        request.WarehouseID,
        }
}</span>

func GetSectionResponseFromModel(model *models.Section) *responses.SectionResponse <span class="cov0" title="0">{
        return &amp;responses.SectionResponse{
                ID:                 model.Id,
                SectionNumber:      model.SectionNumber,
                CurrentCapacity:    model.CurrentCapacity,
                CurrentTemperature: model.CurrentTemperature,
                MaximumCapacity:    model.MaximumCapacity,
                MinimumCapacity:    model.MinimumCapacity,
                MinimumTemperature: model.MinimumTemperature,
                ProductTypeID:      model.ProductTypeID,
                WarehouseID:        model.WarehouseID,
        }
}</span>

func UpdateSectionModelFromRequest(model *models.Section, request *requests.SectionRequest) <span class="cov0" title="0">{
        model.SectionNumber = request.SectionNumber
        model.CurrentCapacity = request.CurrentCapacity
        model.CurrentTemperature = request.CurrentTemperature
        model.MaximumCapacity = request.MaximumCapacity
        model.MinimumCapacity = request.MinimumCapacity
        model.MinimumTemperature = request.MinimumTemperature
        model.ProductTypeID = request.ProductTypeID
        model.WarehouseID = request.WarehouseID
}</span>

func GetListSectionResponseFromListModel(models []*models.Section) []*responses.SectionResponse <span class="cov0" title="0">{
        var listSectionResponse []*responses.SectionResponse
        if len(models) &gt; 0 </span><span class="cov0" title="0">{
                for _, s := range models </span><span class="cov0" title="0">{
                        listSectionResponse = append(listSectionResponse, GetSectionResponseFromModel(s))
                }</span>
        }
        <span class="cov0" title="0">return listSectionResponse</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package mappers

import (
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/responses"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
)

func ToRequestToSellerStruct(seller requests.SellerRequest) models.Seller <span class="cov0" title="0">{
        sellerFormated := models.Seller{
                CID:         seller.CID,
                CompanyName: seller.CompanyName,
                Address:     seller.Address,
                Telephone:   seller.Telephone,
                LocalityID:  seller.LocalityID,
        }
        return sellerFormated
}</span>

func ToSellerStructToResponse(seller models.Seller) responses.SellerResponse <span class="cov0" title="0">{
        sellerFormated := responses.SellerResponse{
                Id:          seller.Id,
                CID:         seller.CID,
                CompanyName: seller.CompanyName,
                Address:     seller.Address,
                Telephone:   seller.Telephone,
                LocalityID:  seller.LocalityID,
        }
        return sellerFormated
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package mappers

import (
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/responses"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
)

func ToResponse(warehouse models.Warehouse) responses.WarehouseResponse <span class="cov0" title="0">{
        return responses.WarehouseResponse{
                ID:                 warehouse.Id,
                Address:            warehouse.Address,
                Telephone:          warehouse.Telephone,
                WareHouseCode:      warehouse.WareHouseCode,
                MinimumCapacity:    warehouse.MinimumCapacity,
                MinimumTemperature: warehouse.MinimumTemperature,
        }
}</span>

func ToRequest(warehouseRequest requests.WarehouseRequest) models.Warehouse <span class="cov0" title="0">{
        return models.Warehouse{
                Address:            warehouseRequest.Address,
                Telephone:          warehouseRequest.Telephone,
                WareHouseCode:      warehouseRequest.WareHouseCode,
                MinimumCapacity:    warehouseRequest.MinimumCapacity,
                MinimumTemperature: warehouseRequest.MinimumTemperature,
                LocalityId:         warehouseRequest.LocalityId,
        }
}</span>

func ApplyPatch(existing models.Warehouse, patch requests.WarehousePatchRequest) models.Warehouse <span class="cov0" title="0">{
        if patch.Address != nil </span><span class="cov0" title="0">{
                existing.Address = *patch.Address
        }</span>
        <span class="cov0" title="0">if patch.Telephone != nil </span><span class="cov0" title="0">{
                existing.Telephone = *patch.Telephone
        }</span>
        <span class="cov0" title="0">if patch.WareHouseCode != nil </span><span class="cov0" title="0">{
                existing.WareHouseCode = *patch.WareHouseCode
        }</span>
        <span class="cov0" title="0">if patch.MinimumCapacity != nil </span><span class="cov0" title="0">{
                existing.MinimumCapacity = *patch.MinimumCapacity
        }</span>
        <span class="cov0" title="0">if patch.MinimumTemperature != nil </span><span class="cov0" title="0">{
                existing.MinimumTemperature = *patch.MinimumTemperature
        }</span>
        <span class="cov0" title="0">return existing</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/error_message"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
)

var inboundOrderRepositoryInstance InboundOrderRepositoryI

// GetNewInboundOrderMySQLRepository - Creates and returns a new instance of MySqlInboundOrderRepository using singleton pattern
// GetNewInboundOrderMySQLRepository - Crea y retorna una nueva instancia de MySqlInboundOrderRepository usando patrón singleton
func GetNewInboundOrderMySQLRepository(db *sql.DB) InboundOrderRepositoryI <span class="cov0" title="0">{
        if inboundOrderRepositoryInstance != nil </span><span class="cov0" title="0">{
                return inboundOrderRepositoryInstance
        }</span>
        <span class="cov0" title="0">inboundOrderRepositoryInstance = &amp;MySqlInboundOrderRepository{
                db: db,
        }
        return inboundOrderRepositoryInstance</span>
}

// InboundOrderRepositoryI - Interface defining the contract for inbound order repository operations
// InboundOrderRepositoryI - Interfaz que define el contrato para las operaciones del repositorio de órdenes de entrada
type InboundOrderRepositoryI interface {
        // GetAllInboundOrdersReports - Retrieves inbound order reports for all employees with their order counts
        // GetAllInboundOrdersReports - Obtiene reportes de órdenes de entrada para todos los empleados con sus conteos de órdenes
        GetAllInboundOrdersReports(ctx context.Context) ([]models.InboundOrderReport, error)

        // GetInboundOrdersReportByEmployeeId - Retrieves an inbound order report for a specific employee ID
        // GetInboundOrdersReportByEmployeeId - Obtiene un reporte de órdenes de entrada para un ID de empleado específico
        GetInboundOrdersReportByEmployeeId(ctx context.Context, employeeId int) (models.InboundOrderReport, error)

        // Create - Inserts a new inbound order into the database and returns the created order with its generated ID
        // Create - Inserta una nueva orden de entrada en la base de datos y retorna la orden creada con su ID generado
        Create(ctx context.Context, inbound models.InboundOrder) (models.InboundOrder, error)

        // ExistsByOrderNumber - Checks if an inbound order with the given order number already exists in the database
        // ExistsByOrderNumber - Verifica si una orden de entrada con el número de orden dado ya existe en la base de datos
        ExistsByOrderNumber(ctx context.Context, orderNumber string) (bool, error)
}

// MySqlInboundOrderRepository - MySQL implementation of the InboundOrderRepositoryI interface
// MySqlInboundOrderRepository - Implementación MySQL de la interfaz InboundOrderRepositoryI
type MySqlInboundOrderRepository struct {
        db *sql.DB // Database connection / Conexión a la base de datos
}

// GetAllInboundOrdersReports - Retrieves inbound order reports for all employees showing employee info and their order counts
// GetAllInboundOrdersReports - Obtiene reportes de órdenes de entrada para todos los empleados mostrando información del empleado y sus conteos de órdenes
func (r *MySqlInboundOrderRepository) GetAllInboundOrdersReports(ctx context.Context) ([]models.InboundOrderReport, error) <span class="cov0" title="0">{
        reports := []models.InboundOrderReport{}

        // Complex SQL query using INNER JOIN to get employee info and count their inbound orders
        // Consulta SQL compleja usando INNER JOIN para obtener información del empleado y contar sus órdenes de entrada
        query := `
        SELECT e.id, e.id_card_number, e.first_name, e.last_name, COUNT(io.id) AS inbound_orders_count
        FROM employees e
        INNER JOIN inbound_orders io ON io.employee_id = e.id
        GROUP BY e.id
        ORDER BY e.id;
        `

        rows, err := r.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return []models.InboundOrderReport{}, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        // Iterate through all rows and scan each report into the results slice
        // Itera a través de todas las filas y escanea cada reporte en el slice de resultados
        for rows.Next() </span><span class="cov0" title="0">{
                var report models.InboundOrderReport
                err := rows.Scan(&amp;report.Id, &amp;report.IdCardNumber, &amp;report.FirstName, &amp;report.LastName, &amp;report.InboundOrderCount)
                if err != nil </span><span class="cov0" title="0">{
                        return []models.InboundOrderReport{}, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">reports = append(reports, report)</span>
        }

        <span class="cov0" title="0">return reports, nil</span>
}

// GetInboundOrdersReportByEmployeeId - Retrieves an inbound order report for a specific employee showing their info and order count
// GetInboundOrdersReportByEmployeeId - Obtiene un reporte de órdenes de entrada para un empleado específico mostrando su información y conteo de órdenes
func (r *MySqlInboundOrderRepository) GetInboundOrdersReportByEmployeeId(ctx context.Context, employeeId int) (models.InboundOrderReport, error) <span class="cov0" title="0">{
        report := models.InboundOrderReport{}

        // Complex SQL query using INNER JOIN to get specific employee info and count their inbound orders
        // Consulta SQL compleja usando INNER JOIN para obtener información específica del empleado y contar sus órdenes de entrada
        query := `
        SELECT e.id, e.id_card_number, e.first_name, e.last_name, COUNT(io.id) AS inbound_orders_count
        FROM employees e
        INNER JOIN inbound_orders io ON io.employee_id = e.id
        WHERE e.id = ?
        GROUP BY e.id;
        `

        row := r.db.QueryRowContext(ctx, query, employeeId)
        err := row.Scan(&amp;report.Id, &amp;report.IdCardNumber, &amp;report.FirstName, &amp;report.LastName, &amp;report.InboundOrderCount)

        if err != nil </span><span class="cov0" title="0">{
                // Handle case when no employee is found / Maneja el caso cuando no se encuentra ningún empleado
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return models.InboundOrderReport{}, fmt.Errorf("%w. %s %d %s", error_message.ErrNotFound, "employee with Id", employeeId, "doesn't exist.")
                }</span>
                <span class="cov0" title="0">return models.InboundOrderReport{}, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())</span>
        }

        <span class="cov0" title="0">return report, nil</span>
}

// Create - Inserts a new inbound order into the MySQL database and returns the created order with its generated ID
// Create - Inserta una nueva orden de entrada en la base de datos MySQL y retorna la orden creada con su ID generado
func (r *MySqlInboundOrderRepository) Create(ctx context.Context, inbound models.InboundOrder) (models.InboundOrder, error) <span class="cov0" title="0">{
        // SQL query to insert new inbound order with all required fields / Consulta SQL para insertar nueva orden de entrada con todos los campos requeridos
        query := `
                INSERT INTO inbound_orders (order_date, order_number, employee_id, product_batch_id, warehouse_id)
                VALUES (?, ?, ?, ?, ?)
        `

        result, err := r.db.ExecContext(ctx, query,
                inbound.OrderDate,
                inbound.OrderNumber,
                inbound.EmployeeId,
                inbound.ProductBatchId,
                inbound.WarehouseId,
        )
        if err != nil </span><span class="cov0" title="0">{
                return models.InboundOrder{}, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
        }</span>

        // Get the auto-generated ID from the database / Obtiene el ID autogenerado de la base de datos
        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return models.InboundOrder{}, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
        }</span>

        <span class="cov0" title="0">inbound.Id = int(id)
        return inbound, nil</span>
}

// ExistsByOrderNumber - Checks if an inbound order with the given order number already exists in the MySQL database
// ExistsByOrderNumber - Verifica si una orden de entrada con el número de orden dado ya existe en la base de datos MySQL
func (r *MySqlInboundOrderRepository) ExistsByOrderNumber(ctx context.Context, orderNumber string) (bool, error) <span class="cov0" title="0">{
        var exists bool
        // Simple query using EXISTS for efficient existence check / Consulta simple usando EXISTS para verificación eficiente de existencia
        query := "SELECT EXISTS(SELECT 1 FROM inbound_orders WHERE order_number = ?)"
        err := r.db.QueryRowContext(ctx, query, orderNumber).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">return exists, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "strings"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/error_message"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
)

var buyerRepositoryInstance BuyerRepositoryI

// GetNewBuyerMySQLRepository - Creates and returns a new instance of MySqlBuyerRepository using singleton pattern
// GetNewBuyerMySQLRepository - Crea y retorna una nueva instancia de MySqlBuyerRepository usando patrón singleton
func GetNewBuyerMySQLRepository(db *sql.DB) BuyerRepositoryI <span class="cov0" title="0">{
        if buyerRepositoryInstance != nil </span><span class="cov0" title="0">{
                return buyerRepositoryInstance
        }</span>

        <span class="cov0" title="0">buyerRepositoryInstance = &amp;MySqlBuyerRepository{
                db: db,
        }
        return buyerRepositoryInstance</span>
}

// BuyerRepositoryI - Interface defining the contract for buyer repository operations
// BuyerRepositoryI - Interfaz que define el contrato para las operaciones del repositorio de compradores
type BuyerRepositoryI interface {
        // GetAll - Retrieves all buyers from the database and returns them as a map with buyer ID as key
        // GetAll - Obtiene todos los compradores de la base de datos y los retorna como un mapa con el ID del comprador como clave
        GetAll(ctx context.Context) (map[int]models.Buyer, error)

        // GetById - Retrieves a specific buyer by their ID from the database
        // GetById - Obtiene un comprador específico por su ID de la base de datos
        GetById(ctx context.Context, id int) (models.Buyer, error)

        // DeleteById - Removes a buyer from the database by their ID
        // DeleteById - Elimina un comprador de la base de datos por su ID
        DeleteById(ctx context.Context, id int) error

        // Create - Inserts a new buyer into the database and returns the created buyer with its generated ID
        // Create - Inserta un nuevo comprador en la base de datos y retorna el comprador creado con su ID generado
        Create(ctx context.Context, buyer models.Buyer) (models.Buyer, error)

        // Update - Modifies an existing buyer in the database with support for partial updates
        // Update - Modifica un comprador existente en la base de datos con soporte para actualizaciones parciales
        Update(ctx context.Context, buyerId int, buyer models.Buyer) (models.Buyer, error)

        // GetCardNumberIds - Retrieves all card number IDs from the database for validation purposes
        // GetCardNumberIds - Obtiene todos los IDs de números de tarjeta de la base de datos para propósitos de validación
        GetCardNumberIds() ([]string, error)

        // ExistBuyerById - Checks if a buyer with the given ID exists in the database
        // ExistBuyerById - Verifica si un comprador con el ID dado existe en la base de datos
        ExistBuyerById(ctx context.Context, buyerId int) (bool, error)
}

// MySqlBuyerRepository - MySQL implementation of the BuyerRepositoryI interface
// MySqlBuyerRepository - Implementación MySQL de la interfaz BuyerRepositoryI
type MySqlBuyerRepository struct {
        db *sql.DB // Database connection / Conexión a la base de datos
}

// GetAll - Retrieves all buyers from the MySQL database and returns them as a map with buyer ID as key
// GetAll - Obtiene todos los compradores de la base de datos MySQL y los retorna como un mapa con el ID del comprador como clave
func (r *MySqlBuyerRepository) GetAll(ctx context.Context) (map[int]models.Buyer, error) <span class="cov0" title="0">{
        buyers := make(map[int]models.Buyer)

        // SQL query to select all buyer fields / Consulta SQL para seleccionar todos los campos del comprador
        query := "select id, id_card_number, first_name, last_name from buyers"
        rows, err := r.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return buyers, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        // Create temporary map to store buyers before returning / Crear mapa temporal para almacenar compradores antes de retornar
        tempBuyersMap := make(map[int]models.Buyer)
        // Iterate through all rows and map each buyer to the result map / Itera a través de todas las filas y mapea cada comprador al mapa de resultados
        for rows.Next() </span><span class="cov0" title="0">{
                buyer := models.Buyer{}
                err = rows.Scan(&amp;buyer.Id, &amp;buyer.CardNumberId, &amp;buyer.FirstName, &amp;buyer.LastName)
                if err != nil </span><span class="cov0" title="0">{
                        return buyers, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">tempBuyersMap[buyer.Id] = buyer</span>
        }

        <span class="cov0" title="0">buyers = tempBuyersMap
        return buyers, nil</span>
}

// GetById - Retrieves a specific buyer by their ID from the MySQL database
// GetById - Obtiene un comprador específico por su ID de la base de datos MySQL
func (r *MySqlBuyerRepository) GetById(ctx context.Context, id int) (models.Buyer, error) <span class="cov0" title="0">{
        buyer := models.Buyer{}

        // SQL query to select buyer by specific ID / Consulta SQL para seleccionar comprador por ID específico
        query := "select id, id_card_number, first_name, last_name from buyers where id = ?"
        row := r.db.QueryRowContext(ctx, query, id)
        err := row.Err()
        if err != nil </span><span class="cov0" title="0">{
                return buyer, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
        }</span>

        <span class="cov0" title="0">err = row.Scan(&amp;buyer.Id, &amp;buyer.CardNumberId, &amp;buyer.FirstName, &amp;buyer.LastName)
        if err != nil </span><span class="cov0" title="0">{
                // Handle case when no buyer is found / Maneja el caso cuando no se encuentra ningún comprador
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return models.Buyer{}, fmt.Errorf("%w. %s %d %s", error_message.ErrNotFound, "Buyer with Id", id, "doesn't exists.")
                }</span>
                <span class="cov0" title="0">return models.Buyer{}, err</span>
        }

        <span class="cov0" title="0">return buyer, nil</span>
}

// DeleteById - Removes a buyer from the MySQL database by their ID
// DeleteById - Elimina un comprador de la base de datos MySQL por su ID
func (r *MySqlBuyerRepository) DeleteById(ctx context.Context, id int) error <span class="cov0" title="0">{
        // SQL query to delete buyer by ID / Consulta SQL para eliminar comprador por ID
        query := "delete from buyers where id = ?"

        result, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w. %s", error_message.ErrInternalServerError, err)
        }</span>

        // Check if any rows were affected to confirm deletion / Verifica si alguna fila fue afectada para confirmar la eliminación
        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w. %s", error_message.ErrInternalServerError, err)
        }</span>

        // If no rows affected, buyer doesn't exist / Si ninguna fila fue afectada, el comprador no existe
        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("%w. %s %d %s", error_message.ErrNotFound, "Buyer with Id", id, "doesn't exists.")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Create - Inserts a new buyer into the MySQL database and returns the created buyer with its generated ID
// Create - Inserta un nuevo comprador en la base de datos MySQL y retorna el comprador creado con su ID generado
func (r *MySqlBuyerRepository) Create(ctx context.Context, buyer models.Buyer) (models.Buyer, error) <span class="cov0" title="0">{
        // SQL query to insert new buyer / Consulta SQL para insertar nuevo comprador
        query := `insert into buyers (id_card_number, first_name, last_name) values (?, ?, ?)`

        result, err := r.db.ExecContext(ctx, query, buyer.CardNumberId, buyer.FirstName, buyer.LastName)

        if err != nil </span><span class="cov0" title="0">{
                return models.Buyer{}, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
        }</span>

        // Get the auto-generated ID from the database / Obtiene el ID autogenerado de la base de datos
        <span class="cov0" title="0">lastId, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return models.Buyer{}, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
        }</span>

        <span class="cov0" title="0">buyer.Id = int(lastId)
        return buyer, nil</span>
}

// Update - Modifies an existing buyer in the MySQL database with support for partial updates
// Update - Modifica un comprador existente en la base de datos MySQL con soporte para actualizaciones parciales
func (r *MySqlBuyerRepository) Update(ctx context.Context, buyerId int, buyer models.Buyer) (models.Buyer, error) <span class="cov0" title="0">{
        updates := []string{}
        values := []interface{}{}

        // Build dynamic UPDATE query based on provided fields / Construye consulta UPDATE dinámica basada en campos proporcionados
        if buyer.FirstName != "" </span><span class="cov0" title="0">{
                updates = append(updates, "first_name = ?")
                values = append(values, buyer.FirstName)
        }</span>
        <span class="cov0" title="0">if buyer.LastName != "" </span><span class="cov0" title="0">{
                updates = append(updates, "last_name = ?")
                values = append(values, buyer.LastName)
        }</span>
        <span class="cov0" title="0">if buyer.CardNumberId != "" </span><span class="cov0" title="0">{
                updates = append(updates, "id_card_number = ?")
                values = append(values, buyer.CardNumberId)
        }</span>

        // Execute dynamic UPDATE query / Ejecuta consulta UPDATE dinámica
        <span class="cov0" title="0">query := "UPDATE buyers SET " + strings.Join(updates, ", ") + " WHERE id = ?"
        values = append(values, buyerId)

        result, err := r.db.ExecContext(ctx, query, values...)
        if err != nil </span><span class="cov0" title="0">{
                return models.Buyer{}, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
        }</span>

        // Check if any rows were affected to confirm update / Verifica si alguna fila fue afectada para confirmar la actualización
        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return models.Buyer{}, fmt.Errorf("%w. %s", error_message.ErrInternalServerError, err)
        }</span>

        // If no rows affected, buyer doesn't exist / Si ninguna fila fue afectada, el comprador no existe
        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return models.Buyer{}, fmt.Errorf("%w. %s %d %s", error_message.ErrNotFound, "Buyer with Id", buyerId, "doesn't exists.")
        }</span>

        // Retrieve and return the updated buyer / Obtiene y retorna el comprador actualizado
        <span class="cov0" title="0">updatedUser, err := r.GetById(ctx, buyerId)
        if err != nil </span><span class="cov0" title="0">{
                return models.Buyer{}, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">return updatedUser, nil</span>
}

// GetCardNumberIds - Retrieves all card number IDs from the MySQL database for validation purposes
// GetCardNumberIds - Obtiene todos los IDs de números de tarjeta de la base de datos MySQL para propósitos de validación
func (r *MySqlBuyerRepository) GetCardNumberIds() ([]string, error) <span class="cov0" title="0">{
        cardNumberIds := []string{}

        // SQL query to select all card number IDs / Consulta SQL para seleccionar todos los IDs de números de tarjeta
        query := "select id_card_number from buyers"
        rows, err := r.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return []string{}, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        // Iterate through all rows and collect card number IDs / Itera a través de todas las filas y recolecta los IDs de números de tarjeta
        for rows.Next() </span><span class="cov0" title="0">{
                cardNumberId := ""
                err = rows.Scan(&amp;cardNumberId)
                if err != nil </span><span class="cov0" title="0">{
                        return []string{}, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
                }</span>

                <span class="cov0" title="0">cardNumberIds = append(cardNumberIds, cardNumberId)</span>
        }

        <span class="cov0" title="0">return cardNumberIds, nil</span>
}

// ExistBuyerById - Checks if a buyer with the given ID exists in the MySQL database
// ExistBuyerById - Verifica si un comprador con el ID dado existe en la base de datos MySQL
func (r *MySqlBuyerRepository) ExistBuyerById(ctx context.Context, buyerId int) (bool, error) <span class="cov0" title="0">{
        // Simple query to check buyer existence using LIMIT 1 for efficiency / Consulta simple para verificar existencia del comprador usando LIMIT 1 por eficiencia
        query := "SELECT 1 FROM buyers WHERE id = ? LIMIT 1"

        var exists int64
        err := r.db.QueryRowContext(ctx, query, buyerId).Scan(&amp;exists)

        if err != nil </span><span class="cov0" title="0">{
                // If no rows found, buyer doesn't exist (not an error) / Si no se encuentran filas, el comprador no existe (no es un error)
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("error al verificar la existencia del producto: %w", err)</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/error_message"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/responses"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
)

// Carry table and field constants / Constantes de tabla y campos de transportista
const (
        carryTable = "carriers"

        // Field groups for better maintainability / Grupos de campos para mejor mantenibilidad
        carryFields       = "`id`, `cid`, `company_name`, `address`, `telephone`, `locality_id`"
        carryInsertFields = "`cid`, `company_name`, `address`, `telephone`, `locality_id`"
)

// Carry query strings - organized by operation type / Cadenas de consulta de transportista - organizadas por tipo de operación
var (
        // INSERT queries / Consultas INSERT
        queryCreateCarry = fmt.Sprintf("INSERT INTO `%s`(%s) VALUES (?,?,?,?,?)", carryTable, carryInsertFields)

        // SELECT queries / Consultas SELECT
        queryExistsByCid = fmt.Sprintf("SELECT COUNT(*) FROM `%s` WHERE `cid` = ?", carryTable)

        // Report queries / Consultas de reportes
        queryGetCarryReportsByLocality = "SELECT l.id, l.locality_name, COUNT(c.id) AS carriers_count FROM localities l LEFT JOIN carriers c ON l.id = c.locality_id WHERE l.id = ? GROUP BY l.id"
        queryGetAllCarryReports        = "SELECT l.id, l.locality_name, COUNT(c.id) AS carriers_count FROM localities l LEFT JOIN carriers c ON l.id = c.locality_id GROUP BY l.id"
)

var carryRepositoryInstance CarryRepository

// NewCarryRepository - Creates and returns a new instance of CarryRepositoryImpl using singleton pattern
// NewCarryRepository - Crea y retorna una nueva instancia de CarryRepositoryImpl usando patrón singleton
func NewCarryRepository(db *sql.DB) CarryRepository <span class="cov0" title="0">{
        if carryRepositoryInstance != nil </span><span class="cov0" title="0">{
                return carryRepositoryInstance
        }</span>

        <span class="cov0" title="0">carryRepositoryInstance = &amp;CarryRepositoryImpl{db: db}
        return carryRepositoryInstance</span>
}

// CarryRepository - Interface defining the contract for carry repository operations
// CarryRepository - Interfaz que define el contrato para las operaciones del repositorio de transportistas
type CarryRepository interface {
        // Create - Inserts a new carry (carrier) into the database and returns the created carry with its generated ID
        // Create - Inserta un nuevo transportista en la base de datos y retorna el transportista creado con su ID generado
        Create(ctx context.Context, carry models.Carry) (models.Carry, error)

        // ExistsByCid - Checks if a carry with the given CID already exists in the database
        // ExistsByCid - Verifica si un transportista con el CID dado ya existe en la base de datos
        ExistsByCid(ctx context.Context, cid string) (bool, error)

        // GetCarryReportsByLocality - Retrieves carry reports for all localities or a specific locality by ID, showing carrier counts
        // GetCarryReportsByLocality - Obtiene reportes de transportistas para todas las localidades o una localidad específica por ID, mostrando conteos de transportistas
        GetCarryReportsByLocality(ctx context.Context, localityID int) ([]responses.LocalityCarryReport, error)
}

// CarryRepositoryImpl - Implementation of the CarryRepository interface
// CarryRepositoryImpl - Implementación de la interfaz CarryRepository
type CarryRepositoryImpl struct {
        db *sql.DB // Database connection / Conexión a la base de datos
}

// Create - Inserts a new carry (carrier) into the database and returns the created carry with its generated ID
// Create - Inserta un nuevo transportista en la base de datos y retorna el transportista creado con su ID generado
func (r *CarryRepositoryImpl) Create(ctx context.Context, carry models.Carry) (models.Carry, error) <span class="cov0" title="0">{
        // Execute insert statement with carry data / Ejecutar declaración de inserción con datos del transportista
        result, err := r.db.ExecContext(ctx, queryCreateCarry,
                carry.Cid, carry.CompanyName, carry.Address, carry.Telephone, carry.LocalityId,
        )
        if err != nil </span><span class="cov0" title="0">{
                return models.Carry{}, fmt.Errorf("%w: %v", error_message.ErrInternalServerError, err)
        }</span>

        // Get the auto-generated ID and assign it to the carry / Obtener el ID autogenerado y asignarlo al transportista
        <span class="cov0" title="0">lastInsertId, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return models.Carry{}, fmt.Errorf("%w: %v", error_message.ErrInternalServerError, err)
        }</span>
        <span class="cov0" title="0">carry.Id = int(lastInsertId)

        return carry, nil</span>
}

// ExistsByCid - Checks if a carry with the given CID already exists in the database
// ExistsByCid - Verifica si un transportista con el CID dado ya existe en la base de datos
func (r *CarryRepositoryImpl) ExistsByCid(ctx context.Context, cid string) (bool, error) <span class="cov0" title="0">{
        // Execute query to count carries with the given CID / Ejecutar consulta para contar transportistas con el CID dado
        row := r.db.QueryRowContext(ctx, queryExistsByCid, cid)

        var count int
        err := row.Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                // If no rows found, CID doesn't exist (not an error) / Si no se encuentran filas, el CID no existe (no es un error)
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("%w: %v", error_message.ErrInternalServerError, err)</span>
        }

        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

// GetCarryReportsByLocality - Retrieves carry reports showing locality information and carrier counts
// GetCarryReportsByLocality - Obtiene reportes de transportistas mostrando información de localidad y conteos de transportistas
func (r *CarryRepositoryImpl) GetCarryReportsByLocality(ctx context.Context, localityID int) ([]responses.LocalityCarryReport, error) <span class="cov0" title="0">{
        var rows *sql.Rows
        var err error

        // Execute different query based on whether specific locality ID is requested
        // Ejecutar consulta diferente basada en si se solicita un ID de localidad específico
        if localityID != 0 </span><span class="cov0" title="0">{
                // Query for specific locality using LEFT JOIN to include localities with zero carriers
                // Consulta para localidad específica usando LEFT JOIN para incluir localidades sin transportistas
                rows, err = r.db.QueryContext(ctx, queryGetCarryReportsByLocality, localityID)
        }</span> else<span class="cov0" title="0"> {
                // Query for all localities using LEFT JOIN to include localities with zero carriers
                // Consulta para todas las localidades usando LEFT JOIN para incluir localidades sin transportistas
                rows, err = r.db.QueryContext(ctx, queryGetAllCarryReports)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: %v", error_message.ErrInternalServerError, err)
        }</span>

        <span class="cov0" title="0">defer rows.Close()

        // Iterate through all rows and scan each report into the results slice
        // Itera a través de todas las filas y escanea cada reporte en el slice de resultados
        var reports []responses.LocalityCarryReport
        for rows.Next() </span><span class="cov0" title="0">{
                var report responses.LocalityCarryReport
                err := rows.Scan(&amp;report.LocalityId, &amp;report.LocalityName, &amp;report.CarriersCount)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w: %v", error_message.ErrInternalServerError, err)
                }</span>
                <span class="cov0" title="0">reports = append(reports, report)</span>
        }

        // Check for any errors that occurred during iteration / Verificar si ocurrieron errores durante la iteración
        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: %v", error_message.ErrInternalServerError, err)
        }</span>

        <span class="cov0" title="0">return reports, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "strings"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/error_message"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
)

var employeeRepositoryInstance EmployeeRepositoryI

// GetNewEmployeeMySQLRepository - Creates and returns a new instance of MySqlEmployeeRepository using singleton pattern
// GetNewEmployeeMySQLRepository - Crea y retorna una nueva instancia de MySqlEmployeeRepository usando patrón singleton
func GetNewEmployeeMySQLRepository(db *sql.DB) EmployeeRepositoryI <span class="cov0" title="0">{
        if employeeRepositoryInstance != nil </span><span class="cov0" title="0">{
                return employeeRepositoryInstance
        }</span>

        <span class="cov0" title="0">employeeRepositoryInstance = &amp;MySqlEmployeeRepository{
                db: db,
        }
        return employeeRepositoryInstance</span>
}

// EmployeeRepositoryI - Interface defining the contract for employee repository operations
// EmployeeRepositoryI - Interfaz que define el contrato para las operaciones del repositorio de empleados
type EmployeeRepositoryI interface {
        // GetAll - Retrieves all employees from the database and returns them as a map with employee ID as key
        // GetAll - Obtiene todos los empleados de la base de datos y los retorna como un mapa con el ID del empleado como clave
        GetAll(ctx context.Context) (map[int]models.Employee, error)

        // GetById - Retrieves a specific employee by their ID from the database
        // GetById - Obtiene un empleado específico por su ID de la base de datos
        GetById(ctx context.Context, id int) (models.Employee, error)

        // DeleteById - Removes an employee from the database by their ID
        // DeleteById - Elimina un empleado de la base de datos por su ID
        DeleteById(ctx context.Context, id int) error

        // Create - Inserts a new employee into the database and returns the created employee with its generated ID
        // Create - Inserta un nuevo empleado en la base de datos y retorna el empleado creado con su ID generado
        Create(ctx context.Context, employee models.Employee) (models.Employee, error)

        // Update - Modifies an existing employee in the database with partial updates support
        // Update - Modifica un empleado existente en la base de datos con soporte para actualizaciones parciales
        Update(ctx context.Context, employeeId int, employee models.Employee) (models.Employee, error)

        // GetCardNumberIds - Retrieves all card number IDs from the database for validation purposes
        // GetCardNumberIds - Obtiene todos los IDs de números de tarjeta de la base de datos para propósitos de validación
        GetCardNumberIds() ([]string, error)

        // ExistEmployeeById - Checks if an employee with the given ID exists in the database
        // ExistEmployeeById - Verifica si un empleado con el ID dado existe en la base de datos
        ExistEmployeeById(ctx context.Context, employeeId int) (bool, error)
}

// MySqlEmployeeRepository - MySQL implementation of the EmployeeRepositoryI interface
// MySqlEmployeeRepository - Implementación MySQL de la interfaz EmployeeRepositoryI
type MySqlEmployeeRepository struct {
        db *sql.DB // Database connection / Conexión a la base de datos
}

// GetAll - Retrieves all employees from the MySQL database and returns them as a map with employee ID as key
// GetAll - Obtiene todos los empleados de la base de datos MySQL y los retorna como un mapa con el ID del empleado como clave
func (r *MySqlEmployeeRepository) GetAll(ctx context.Context) (map[int]models.Employee, error) <span class="cov0" title="0">{
        employees := make(map[int]models.Employee)

        // SQL query to select all employee fields / Consulta SQL para seleccionar todos los campos del empleado
        query := "SELECT id, id_card_number, first_name, last_name, warehouse_id FROM employees"
        rows, err := r.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return employees, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        // Iterate through all rows and map each employee to the result map
        // Itera a través de todas las filas y mapea cada empleado al mapa de resultados
        for rows.Next() </span><span class="cov0" title="0">{
                employee := models.Employee{}
                err = rows.Scan(&amp;employee.Id, &amp;employee.CardNumberID, &amp;employee.FirstName, &amp;employee.LastName, &amp;employee.WarehouseID)
                if err != nil </span><span class="cov0" title="0">{
                        return employees, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">employees[employee.Id] = employee</span>
        }

        <span class="cov0" title="0">return employees, nil</span>
}

// GetById - Retrieves a specific employee by their ID from the MySQL database
// GetById - Obtiene un empleado específico por su ID de la base de datos MySQL
func (r *MySqlEmployeeRepository) GetById(ctx context.Context, id int) (models.Employee, error) <span class="cov0" title="0">{
        employee := models.Employee{}

        // SQL query to select employee by specific ID / Consulta SQL para seleccionar empleado por ID específico
        query := "SELECT id, id_card_number, first_name, last_name, warehouse_id FROM employees WHERE id = ?"
        row := r.db.QueryRowContext(ctx, query, id)

        err := row.Scan(&amp;employee.Id, &amp;employee.CardNumberID, &amp;employee.FirstName, &amp;employee.LastName, &amp;employee.WarehouseID)
        if err != nil </span><span class="cov0" title="0">{
                // Handle case when no employee is found / Maneja el caso cuando no se encuentra ningún empleado
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return models.Employee{}, fmt.Errorf("%w. %s %d %s", error_message.ErrNotFound, "employee with Id", id, "not exists.")
                }</span>
                <span class="cov0" title="0">return models.Employee{}, err</span>
        }

        <span class="cov0" title="0">return employee, nil</span>
}

// DeleteById - Removes an employee from the MySQL database by their ID
// DeleteById - Elimina un empleado de la base de datos MySQL por su ID
func (r *MySqlEmployeeRepository) DeleteById(ctx context.Context, id int) error <span class="cov0" title="0">{
        // SQL query to delete employee by ID / Consulta SQL para eliminar empleado por ID
        query := "DELETE FROM employees WHERE id = ?"

        result, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w. %s", error_message.ErrInternalServerError, err)
        }</span>

        // Check if any rows were affected to confirm deletion / Verifica si alguna fila fue afectada para confirmar la eliminación
        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w. %s", error_message.ErrInternalServerError, err)
        }</span>

        // If no rows affected, employee doesn't exist / Si ninguna fila fue afectada, el empleado no existe
        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("%w. %s %d %s", error_message.ErrNotFound, "Employee with Id", id, "doesn't exist.")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Create - Inserts a new employee into the MySQL database and returns the created employee with its generated ID
// Create - Inserta un nuevo empleado en la base de datos MySQL y retorna el empleado creado con su ID generado
func (r *MySqlEmployeeRepository) Create(ctx context.Context, employee models.Employee) (models.Employee, error) <span class="cov0" title="0">{
        // SQL query to insert new employee / Consulta SQL para insertar nuevo empleado
        query := `INSERT INTO employees (id_card_number, first_name, last_name, warehouse_id) VALUES (?, ?, ?, ?)`

        result, err := r.db.ExecContext(ctx, query, employee.CardNumberID, employee.FirstName, employee.LastName, employee.WarehouseID)
        if err != nil </span><span class="cov0" title="0">{
                return models.Employee{}, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
        }</span>

        // Get the auto-generated ID from the database / Obtiene el ID autogenerado de la base de datos
        <span class="cov0" title="0">lastId, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return models.Employee{}, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
        }</span>

        <span class="cov0" title="0">employee.Id = int(lastId)
        return employee, nil</span>
}

// Update - Modifies an existing employee in the MySQL database with support for partial updates
// Update - Modifica un empleado existente en la base de datos MySQL con soporte para actualizaciones parciales
func (r *MySqlEmployeeRepository) Update(ctx context.Context, employeeId int, employee models.Employee) (models.Employee, error) <span class="cov0" title="0">{
        updates := []string{}
        values := []interface{}{}

        // Build dynamic UPDATE query based on provided fields / Construye consulta UPDATE dinámica basada en campos proporcionados
        if employee.FirstName != "" </span><span class="cov0" title="0">{
                updates = append(updates, "first_name = ?")
                values = append(values, employee.FirstName)
        }</span>
        <span class="cov0" title="0">if employee.LastName != "" </span><span class="cov0" title="0">{
                updates = append(updates, "last_name = ?")
                values = append(values, employee.LastName)
        }</span>
        <span class="cov0" title="0">if employee.CardNumberID != "" </span><span class="cov0" title="0">{
                updates = append(updates, "id_card_number = ?")
                values = append(values, employee.CardNumberID)
        }</span>
        <span class="cov0" title="0">if employee.WarehouseID != 0 </span><span class="cov0" title="0">{
                updates = append(updates, "warehouse_id = ?")
                values = append(values, employee.WarehouseID)
        }</span>

        // Execute dynamic UPDATE query / Ejecuta consulta UPDATE dinámica
        <span class="cov0" title="0">query := "UPDATE employees SET " + strings.Join(updates, ", ") + " WHERE id = ?"
        values = append(values, employeeId)

        result, err := r.db.ExecContext(ctx, query, values...)
        if err != nil </span><span class="cov0" title="0">{
                return models.Employee{}, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
        }</span>

        // Check if any rows were affected to confirm update / Verifica si alguna fila fue afectada para confirmar la actualización
        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return models.Employee{}, fmt.Errorf("%w. %s", error_message.ErrInternalServerError, err)
        }</span>

        // If no rows affected, employee doesn't exist / Si ninguna fila fue afectada, el empleado no existe
        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return models.Employee{}, fmt.Errorf("%w. %s %d %s", error_message.ErrNotFound, "employee with Id", employeeId, "not exists.")
        }</span>

        // Retrieve and return the updated employee / Obtiene y retorna el empleado actualizado
        <span class="cov0" title="0">updatedEmployee, err := r.GetById(ctx, employeeId)
        if err != nil </span><span class="cov0" title="0">{
                return models.Employee{}, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">return updatedEmployee, nil</span>
}

// GetCardNumberIds - Retrieves all card number IDs from the MySQL database for validation purposes
// GetCardNumberIds - Obtiene todos los IDs de números de tarjeta de la base de datos MySQL para propósitos de validación
func (r *MySqlEmployeeRepository) GetCardNumberIds() ([]string, error) <span class="cov0" title="0">{
        cardNumberIds := []string{}

        // SQL query to select all card number IDs / Consulta SQL para seleccionar todos los IDs de números de tarjeta
        query := "SELECT id_card_number FROM employees"
        rows, err := r.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return []string{}, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        // Iterate through all rows and collect card number IDs / Itera a través de todas las filas y recolecta los IDs de números de tarjeta
        for rows.Next() </span><span class="cov0" title="0">{
                cardNumberId := ""
                err = rows.Scan(&amp;cardNumberId)
                if err != nil </span><span class="cov0" title="0">{
                        return []string{}, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
                }</span>

                <span class="cov0" title="0">cardNumberIds = append(cardNumberIds, cardNumberId)</span>
        }

        <span class="cov0" title="0">return cardNumberIds, nil</span>
}

// ExistEmployeeById - Checks if an employee with the given ID exists in the MySQL database
// ExistEmployeeById - Verifica si un empleado con el ID dado existe en la base de datos MySQL
func (r *MySqlEmployeeRepository) ExistEmployeeById(ctx context.Context, employeeId int) (bool, error) <span class="cov0" title="0">{
        // Simple query to check employee existence using LIMIT 1 for efficiency / Consulta simple para verificar existencia del empleado usando LIMIT 1 por eficiencia
        query := "SELECT 1 FROM employees WHERE id = ? LIMIT 1"

        var exists int64
        err := r.db.QueryRowContext(ctx, query, employeeId).Scan(&amp;exists)

        if err != nil </span><span class="cov0" title="0">{
                // If no rows found, employee doesn't exist (not an error) / Si no se encuentran filas, el empleado no existe (no es un error)
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("error verifying employee existence: %w", err)</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package repositories

import (
        "context"
        "database/sql"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/error_message"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/responses"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
)

var localityRepositoryInstance LocalityRepository

// NewSQLLocalityRepository - Creates and returns a new instance of SQLLocalityRepository using singleton pattern
// NewSQLLocalityRepository - Crea y retorna una nueva instancia de SQLLocalityRepository usando patrón singleton
func NewSQLLocalityRepository(db *sql.DB) LocalityRepository <span class="cov0" title="0">{
        if localityRepositoryInstance != nil </span><span class="cov0" title="0">{
                return localityRepositoryInstance
        }</span>

        <span class="cov0" title="0">localityRepositoryInstance = &amp;SQLLocalityRepository{db: db}
        return localityRepositoryInstance</span>
}

// LocalityRepository - Interface defining the contract for locality repository operations
// LocalityRepository - Interfaz que define el contrato para las operaciones del repositorio de localidades
type LocalityRepository interface {
        // Save - Creates a new locality in the database, handling country and province relationships
        // Save - Crea una nueva localidad en la base de datos, manejando las relaciones de país y provincia
        Save(ctx context.Context, locality models.Locality) (models.Locality, error)

        // GetSellerReports - Retrieves seller reports for all localities or a specific locality by ID
        // GetSellerReports - Obtiene reportes de vendedores para todas las localidades o una localidad específica por ID
        GetSellerReports(ctx context.Context, localityID int) ([]responses.LocalitySellerReport, error)

        // ExistById - Checks if a locality with the given ID exists in the database
        // ExistById - Verifica si una localidad con el ID dado existe en la base de datos
        ExistById(ctx context.Context, localityID int) (bool, error)
}

// SQLLocalityRepository - SQL implementation of the LocalityRepository interface
// SQLLocalityRepository - Implementación SQL de la interfaz LocalityRepository
type SQLLocalityRepository struct {
        db *sql.DB // Database connection / Conexión a la base de datos
}

// Save - Creates a new locality in the database with automatic country and province management
// Save - Crea una nueva localidad en la base de datos con manejo automático de país y provincia
func (r *SQLLocalityRepository) Save(ctx context.Context, locality models.Locality) (models.Locality, error) <span class="cov0" title="0">{
        // 1. Find or insert the country / 1. Buscar o insertar el país
        var countryID int
        err := r.db.QueryRowContext(ctx, "SELECT id FROM countries WHERE country_name = ?", locality.CountryName).Scan(&amp;countryID)
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                // Create new country if it doesn't exist / Crear nuevo país si no existe
                res, err := r.db.ExecContext(ctx, "INSERT INTO countries (country_name) VALUES (?)", locality.CountryName)
                if err != nil </span><span class="cov0" title="0">{
                        return models.Locality{}, error_message.ErrQuery
                }</span>
                <span class="cov0" title="0">lastID, _ := res.LastInsertId()
                countryID = int(lastID)</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return models.Locality{}, error_message.ErrQuery
        }</span>

        // 2. Find or insert the province / 2. Buscar o insertar la provincia
        <span class="cov0" title="0">var provinceID int
        err = r.db.QueryRowContext(ctx, "SELECT id FROM provinces WHERE province_name = ? AND id_country_fk = ?", locality.ProvinceName, countryID).Scan(&amp;provinceID)
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                // Create new province if it doesn't exist / Crear nueva provincia si no existe
                res, err := r.db.ExecContext(ctx, "INSERT INTO provinces (province_name, id_country_fk) VALUES (?, ?)", locality.ProvinceName, countryID)
                if err != nil </span><span class="cov0" title="0">{
                        return models.Locality{}, error_message.ErrQuery
                }</span>
                <span class="cov0" title="0">lastID, _ := res.LastInsertId()
                provinceID = int(lastID)</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return models.Locality{}, error_message.ErrQuery
        }</span>

        // 3. Check if locality already exists with same name and province / 3. Verificar si ya existe una localidad con ese nombre y esa provincia
        <span class="cov0" title="0">var exists bool
        err = r.db.QueryRowContext(ctx, `
                SELECT EXISTS(
                        SELECT 1 FROM localities WHERE locality_name = ? AND province_id = ?
                )
        `, locality.LocalityName, provinceID).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return models.Locality{}, error_message.ErrQuery
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return models.Locality{}, error_message.ErrAlreadyExists
        }</span>

        // 4. Insert new locality with auto-generated ID / 4. Insertar nueva localidad (el ID será auto-generado)
        <span class="cov0" title="0">res, err := r.db.ExecContext(ctx,
                "INSERT INTO localities (locality_name, province_id) VALUES (?, ?)",
                locality.LocalityName, provinceID,
        )

        if err != nil </span><span class="cov0" title="0">{
                return models.Locality{}, error_message.ErrQuery
        }</span>

        // Get the auto-generated ID and assign it to the locality / Obtener el ID autogenerado y asignarlo a la localidad
        <span class="cov0" title="0">lastID, err := res.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return models.Locality{}, error_message.ErrQuery
        }</span>
        <span class="cov0" title="0">locality.Id = int(lastID)

        return locality, nil</span>
}

// GetSellerReports - Retrieves seller reports showing locality information and seller counts
// GetSellerReports - Obtiene reportes de vendedores mostrando información de localidad y conteos de vendedores
func (r *SQLLocalityRepository) GetSellerReports(ctx context.Context, localityID int) ([]responses.LocalitySellerReport, error) <span class="cov0" title="0">{
        // If specific ID provided, verify locality exists / Si se especifica un ID, verificar que exista
        if localityID != 0 </span><span class="cov0" title="0">{
                var exists bool
                err := r.db.QueryRowContext(ctx, "SELECT EXISTS(SELECT 1 FROM localities WHERE id = ?)", localityID).Scan(&amp;exists)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, error_message.ErrFailedCheckingExistence
                }</span>
                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                        return nil, error_message.ErrNotFound
                }</span>
        }

        <span class="cov0" title="0">var (
                rows *sql.Rows
                err  error
        )

        // Execute different query based on whether specific locality ID is requested
        // Ejecutar consulta diferente basada en si se solicita un ID de localidad específico
        if localityID != 0 </span><span class="cov0" title="0">{
                // Query for specific locality using LEFT JOIN to include localities with zero sellers
                // Consulta para localidad específica usando LEFT JOIN para incluir localidades sin vendedores
                rows, err = r.db.QueryContext(ctx, `
                        SELECT l.id, l.locality_name, COUNT(s.id)
                        FROM localities l
                        LEFT JOIN sellers s ON s.locality_id = l.id
                        WHERE l.id = ?
                        GROUP BY l.id, l.locality_name
                `, localityID)
        }</span> else<span class="cov0" title="0"> {
                // Query for all localities using LEFT JOIN to include localities with zero sellers
                // Consulta para todas las localidades usando LEFT JOIN para incluir localidades sin vendedores
                rows, err = r.db.QueryContext(ctx, `
                        SELECT l.id, l.locality_name, COUNT(s.id)
                        FROM localities l
                        LEFT JOIN sellers s ON s.locality_id = l.id
                        GROUP BY l.id, l.locality_name
                `)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, error_message.ErrQueryingReport
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        // Iterate through all rows and scan each report into the results slice
        // Itera a través de todas las filas y escanea cada reporte en el slice de resultados
        var reports []responses.LocalitySellerReport
        for rows.Next() </span><span class="cov0" title="0">{
                var r responses.LocalitySellerReport
                if err := rows.Scan(&amp;r.LocalityID, &amp;r.LocalityName, &amp;r.SellerCount); err != nil </span><span class="cov0" title="0">{
                        return nil, error_message.ErrFailedToScan
                }</span>
                <span class="cov0" title="0">reports = append(reports, r)</span>
        }

        <span class="cov0" title="0">return reports, nil</span>
}

// ExistById - Checks if a locality with the given ID exists in the database
// ExistById - Verifica si una localidad con el ID dado existe en la base de datos
func (r *SQLLocalityRepository) ExistById(ctx context.Context, localityID int) (bool, error) <span class="cov0" title="0">{
        // Simple query using EXISTS for efficient existence check / Consulta simple usando EXISTS para verificación eficiente de existencia
        row := r.db.QueryRowContext(ctx, "SELECT EXISTS(SELECT 1 FROM localities WHERE id = ?)", localityID)
        var exists bool
        err := row.Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return false, error_message.ErrQuery
        }</span>
        <span class="cov0" title="0">return exists, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package repositories

import (
        "context"
        "database/sql"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
        "github.com/sajimenezher_meli/meli-frescos-8/pkg/database"
)

var productBatchRepositoryInstance ProductBatchRepositoryI

// GetProductBatchRepository - Creates and returns a new instance of productBatchRepository using singleton pattern
// GetProductBatchRepository - Crea y retorna una nueva instancia de productBatchRepository usando patrón singleton
func GetProductBatchRepository(db *sql.DB) ProductBatchRepositoryI <span class="cov0" title="0">{
        if productBatchRepositoryInstance != nil </span><span class="cov0" title="0">{
                return productBatchRepositoryInstance
        }</span>

        <span class="cov0" title="0">productBatchRepositoryInstance = &amp;productBatchRepository{
                database:  db,
                tablename: "product_batches",
        }
        return productBatchRepositoryInstance</span>
}

// ProductBatchRepositoryI - Interface defining the contract for product batch repository operations
// ProductBatchRepositoryI - Interfaz que define el contrato para las operaciones del repositorio de lotes de productos
type ProductBatchRepositoryI interface {
        // Create - Inserts a new product batch into the database and assigns the generated ID to the model
        // Create - Inserta un nuevo lote de producto en la base de datos y asigna el ID generado al modelo
        Create(ctx context.Context, model *models.ProductBatch) error

        // GetProductQuantityBySectionId - Retrieves the total quantity of products in a specific section
        // GetProductQuantityBySectionId - Obtiene la cantidad total de productos en una sección específica
        GetProductQuantityBySectionId(ctx context.Context, id int) int

        // ExistsWithBatchNumber - Checks if a product batch exists with the given batch number, excluding a specific ID
        // ExistsWithBatchNumber - Verifica si existe un lote de producto con el número de lote dado, excluyendo un ID específico
        ExistsWithBatchNumber(ctx context.Context, id int, batchNumber string) bool
}

// productBatchRepository - Implementation of ProductBatchRepositoryI using a generic database helper
// productBatchRepository - Implementación de ProductBatchRepositoryI usando un helper genérico de base de datos
type productBatchRepository struct {
        database  *sql.DB // Database connection / Conexión a la base de datos
        tablename string  // Table name for product batches / Nombre de tabla para lotes de productos
}

// Create - Inserts a new product batch into the database with all required fields and sets the generated ID
// Create - Inserta un nuevo lote de producto en la base de datos con todos los campos requeridos y establece el ID generado
func (r *productBatchRepository) Create(ctx context.Context, model *models.ProductBatch) error <span class="cov0" title="0">{
        // Prepare data map with all product batch fields / Preparar mapa de datos con todos los campos del lote de producto
        data := make(map[any]any)
        data["batch_number"] = model.BatchNumber
        data["current_quantity"] = model.CurrentQuantity
        data["current_temperature"] = model.CurrentTemperature
        data["due_date"] = model.DueDate
        data["initial_quantity"] = model.InitialQuantity
        data["manufacturing_date"] = model.ManufacturingDate
        data["manufacturing_hour"] = model.ManufacturingHour
        data["minimum_temperature"] = model.MinimumTemperature
        data["product_id"] = model.ProductID
        data["section_id"] = model.SectionID

        // Execute insert operation using generic database helper / Ejecutar operación de inserción usando helper genérico de base de datos
        result, err := database.Insert(ctx, r.database, r.tablename, data)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get the auto-generated ID and assign it to the model / Obtener el ID autogenerado y asignarlo al modelo
        <span class="cov0" title="0">newID, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">model.Id = int(newID)
        return nil</span>
}

// ExistsWithBatchNumber - Checks if a product batch exists with the given batch number, excluding a specific ID for update scenarios
// ExistsWithBatchNumber - Verifica si existe un lote de producto con el número de lote dado, excluyendo un ID específico para escenarios de actualización
func (r *productBatchRepository) ExistsWithBatchNumber(ctx context.Context, id int, batchNumber string) bool <span class="cov0" title="0">{
        // Query to count batches with same batch number but different ID / Consulta para contar lotes con el mismo número pero diferente ID
        row := database.SelectOne(ctx, r.database, r.tablename, []string{"COUNT(Id)"}, "batch_number = ? AND Id &lt;&gt; ?", batchNumber, id)
        var count string
        if err := row.Scan(&amp;count); err != nil </span><span class="cov0" title="0">{
                // Return true on error to be safe for validation / Retornar true en caso de error para ser seguro en la validación
                return true
        }</span>

        <span class="cov0" title="0">return count != "0"</span>
}

// GetProductQuantityBySectionId - Calculates and returns the total current quantity of all product batches in a specific section
// GetProductQuantityBySectionId - Calcula y retorna la cantidad total actual de todos los lotes de productos en una sección específica
func (r *productBatchRepository) GetProductQuantityBySectionId(ctx context.Context, id int) int <span class="cov0" title="0">{
        // Query to sum current quantities for all batches in the section / Consulta para sumar cantidades actuales de todos los lotes en la sección
        row := database.SelectOne(ctx, r.database, r.tablename, []string{"SUM(current_quantity)"}, "section_id = ?", id)
        var quantity int
        if err := row.Scan(&amp;quantity); err != nil </span><span class="cov0" title="0">{
                // Return existing quantity on scan error / Retornar cantidad existente en caso de error de escaneo
                return quantity
        }</span>

        <span class="cov0" title="0">return quantity</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/error_message"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
)

var productRecordInstance IProductRecordRepository

// NewProductRecordRepository - Constructor function that creates a new repository instance
// NewProductRecordRepository - Función constructora que crea una nueva instancia del repositorio
func NewProductRecordRepository(db *sql.DB) IProductRecordRepository <span class="cov0" title="0">{
        if productRecordInstance != nil </span><span class="cov0" title="0">{
                return productRecordInstance
        }</span>

        <span class="cov0" title="0">productRecordInstance = &amp;productRecordRepository{DB: db}
        return productRecordInstance</span>
}

// productRecordRepository - Repository implementation for product records operations
// productRecordRepository - Implementación del repositorio para operaciones de registros de productos
type productRecordRepository struct {
        DB *sql.DB // Database connection / Conexión a la base de datos
}

// IProductRecordRepository - Interface defining the contract for product records repository
// IProductRecordRepository - Interfaz que define el contrato para el repositorio de registros de productos
type IProductRecordRepository interface {
        // Create - Creates a new product record in the database
        // Create - Crea un nuevo registro de producto en la base de datos
        Create(ctx context.Context, pr *models.ProductRecord) (*models.ProductRecord, error)

        // GetReportByIdProduct - Generates a report for a specific product with records count
        // GetReportByIdProduct - Genera un reporte para un producto específico con el conteo de registros
        GetReportByIdProduct(ctx context.Context, id int64) (*models.ProductRecordReport, error)

        // GetReport - Generates a report showing all products information and the count of their records
        // GetReport - Genera un reporte que muestra la información de todos los productos y el conteo de sus registros
        GetReport(ctx context.Context) ([]*models.ProductRecordReport, error)

        // ExistProductRecordByID - Checks if a product record exists in the database
        // ExistProductRecordByID - Verifica si un registro de producto existe en la base de datos
        ExistProductRecordByID(ctx context.Context, id int64) bool
}

// Create - Inserts a new product record into the database and returns the created record with its ID
// Create - Inserta un nuevo registro de producto en la base de datos y retorna el registro creado con su ID
func (prr *productRecordRepository) Create(ctx context.Context, pr *models.ProductRecord) (*models.ProductRecord, error) <span class="cov0" title="0">{
        // SQL query to insert a new product record / Consulta SQL para insertar un nuevo registro de producto
        query := "INSERT INTO product_records (last_update_date, purchase_price, sale_price, product_id) VALUES (?, ?, ?, ?)"

        // Execute the insert query with the provided context and product record data
        // Ejecuta la consulta de inserción con el contexto proporcionado y los datos del registro de producto
        result, err := prr.DB.ExecContext(ctx, query, pr.LastUpdateDate, pr.PurchasePrice, pr.SalePrice, pr.ProductID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error to create product record: %w", err)
        }</span>

        // Get the auto-generated ID from the database / Obtiene el ID autogenerado de la base de datos
        <span class="cov0" title="0">productRecordId, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error to get last insert id: %w", err)
        }</span>

        // Set the generated ID to the product record / Asigna el ID generado al registro de producto
        <span class="cov0" title="0">pr.ID = int(productRecordId)

        return pr, err</span>
}

// GetReportByIdProduct - Generates a report showing product information and the count of its records
// GetReportByIdProduct - Genera un reporte que muestra la información del producto y el conteo de sus registros
func (prr *productRecordRepository) GetReportByIdProduct(ctx context.Context, id int64) (*models.ProductRecordReport, error) <span class="cov0" title="0">{
        // Complex SQL query using LEFT JOIN to get product info and count records
        // Uses count(*) since we're filtering by WHERE clause, ensuring at least one product exists
        // Consulta SQL compleja usando LEFT JOIN para obtener información del producto y contar registros
        // Usa count(*) ya que estamos filtrando por WHERE clause, asegurando que al menos un producto existe
        query := `
        SELECT p.id as product_id, p.description, count(*) as records_count
        FROM 
                products as p
        LEFT JOIN
                product_records as pr
        ON pr.product_id = p.id
        WHERE p.id = ?
        GROUP BY p.id, p.description`

        var productRecordReport models.ProductRecordReport

        // Execute query and scan results into the report struct
        // Ejecuta la consulta y escanea los resultados en la estructura del reporte
        err := prr.DB.QueryRowContext(ctx, query, id).Scan(
                &amp;productRecordReport.ProductId,
                &amp;productRecordReport.Description,
                &amp;productRecordReport.RecordsCount,
        )

        if err != nil </span><span class="cov0" title="0">{
                // Handle case when no product is found / Maneja el caso cuando no se encuentra ningún producto
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, error_message.ErrDependencyNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("error to scan product record report %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;productRecordReport, nil</span>
}

// GetReport - Generates a report showing products information and the count of its records
// GetReport - Genera un reporte que muestra la información de los productos y el conteo de sus registros
func (prr *productRecordRepository) GetReport(ctx context.Context) (reports []*models.ProductRecordReport, err error) <span class="cov0" title="0">{

        // Complex SQL query using LEFT JOIN to get product info and count records
        // Uses const for immutability and count(pr.product_id) to count only non-null values (actual records)
        // Consulta SQL compleja usando LEFT JOIN para obtener información del producto y contar registros
        // Usa const para inmutabilidad y count(pr.product_id) para contar solo valores no nulos (registros reales)
        const query = `
        SELECT
            p.id as product_id,
            p.description,
            count(pr.product_id) as records_count
        FROM
            products p
        LEFT JOIN
            product_records pr ON pr.product_id = p.id
        GROUP BY
            p.id, p.description`

        // Prepare statement for better performance and security against SQL injection
        // Prepara la consulta para mejor rendimiento y seguridad contra inyección SQL
        stmt, err := prr.DB.PrepareContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to prepare product report query: %w", err)
        }</span>
        // Ensure statement is closed to prevent resource leaks
        // Asegura que la consulta se cierre para prevenir fugas de recursos
        <span class="cov0" title="0">defer stmt.Close()

        // Execute query and scan results into the report struct
        // Ejecuta la consulta y escanea los resultados en la estructura del reporte
        rows, err := stmt.QueryContext(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute product report query: %w", err)
        }</span>
        // Ensure rows are closed to prevent resource leaks
        // Asegura que las filas se cierren para prevenir fugas de recursos
        <span class="cov0" title="0">defer rows.Close()

        // Initialize empty slice to hold the reports
        // Inicializa un slice vacío para almacenar los reportes
        reports = []*models.ProductRecordReport{}

        // Iterate through all rows and scan each one into a ProductRecordReport struct
        // Itera a través de todas las filas y escanea cada una en una estructura ProductRecordReport
        for rows.Next() </span><span class="cov0" title="0">{
                var pr models.ProductRecordReport

                // Scan current row values into the struct fields
                // Escanea los valores de la fila actual en los campos de la estructura
                if err := rows.Scan(&amp;pr.ProductId, &amp;pr.Description, &amp;pr.RecordsCount); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan product record row: %w", err)
                }</span>
                // Append the scanned report to the results slice
                // Agrega el reporte escaneado al slice de resultados
                <span class="cov0" title="0">reports = append(reports, &amp;pr)</span>
        }

        // Check for any errors that occurred during iteration
        // Verifica si ocurrieron errores durante la iteración
        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating product record rows: %w", err)
        }</span>

        <span class="cov0" title="0">return reports, nil</span>
}

// ExistProductRecordByID - Validates if a product record exists in the database by its ID
// ExistProductRecordByID - Valida si un registro de producto existe en la base de datos por su ID
func (prr *productRecordRepository) ExistProductRecordByID(ctx context.Context, id int64) bool <span class="cov0" title="0">{
        // Simple query to check product record existence using LIMIT 1 for efficiency
        // Consulta simple para verificar la existencia del registro de producto usando LIMIT 1 por eficiencia
        query := "SELECT 1 FROM product_records WHERE id = ? LIMIT 1;"

        // Use int64 to match the database return type for consistency
        // Usa int64 para coincidir con el tipo de retorno de la base de datos por consistencia
        var exists int64
        err := prr.DB.QueryRowContext(ctx, query, id).Scan(&amp;exists)

        if err != nil </span><span class="cov0" title="0">{
                // If no rows found, product record doesn't exist (not an error)
                // Si no se encuentran filas, el registro del producto no existe (no es un error)
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return false
                }</span>
                // Any other error is a real database error / Cualquier otro error es un error real de base de datos
                <span class="cov0" title="0">return false</span>
        }

        // If we reach here, product record exists / Si llegamos aquí, el registro de producto existe
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/error_message"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
)

// Constantes SQL para operaciones de productos
// SQL constants for product operations
const (
        // productColumns define las columnas principales de la tabla products
        // productColumns defines the main columns of the products table
        productColumns = `
                id, description, expiration_rate, freezing_rate, height, 
                length, net_weight, product_code, recommended_freezing_temperature, 
                width, product_type_id, seller_id
        `
        queryGetAllProducts = "SELECT " + productColumns + " FROM products"
        queryGetProductByID = "SELECT " + productColumns + " FROM products WHERE id = ?"
        queryCreateProduct  = `
                INSERT INTO products (description, expiration_rate, freezing_rate, height, 
                                                          length, net_weight, product_code, recommended_freezing_temperature, 
                                                          width, product_type_id, seller_id) 
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`
        queryUpdateProduct = `
                UPDATE products SET description = ?, expiration_rate = ?, freezing_rate = ?, height = ?, 
                length = ?, net_weight = ?, product_code = ?, recommended_freezing_temperature = ?, 
                width = ?, product_type_id = ?, seller_id = ?
                WHERE id = ?`
        queryDeleteProduct    = "DELETE FROM products WHERE id = ?"
        queryExistProductID   = "SELECT 1 FROM products WHERE id = ? LIMIT 1"
        queryExistProductCode = "SELECT 1 FROM products WHERE product_code = ? LIMIT 1"
)

var productRepositoryInstance ProductRepository

// NewProductRepository crea una nueva instancia del repositorio de productos
// NewProductRepository creates a new instance of the product repository
func NewProductRepository(db *sql.DB) ProductRepository <span class="cov0" title="0">{
        if productRepositoryInstance != nil </span><span class="cov0" title="0">{
                return productRepositoryInstance
        }</span>

        <span class="cov0" title="0">productRepositoryInstance = &amp;service{
                db: db,
        }
        return productRepositoryInstance</span>
}

// ProductRepository define la interfaz para operaciones de productos en la base de datos
// ProductRepository defines the interface for product database operations
type ProductRepository interface {
        // GetAll obtiene todos los productos de la base de datos
        // GetAll retrieves all products from the database
        GetAll(ctx context.Context) ([]models.Product, error)

        // GetByID obtiene un producto por su ID
        // GetByID retrieves a product by its ID
        GetByID(ctx context.Context, id int64) (models.Product, error)

        // Create crea un nuevo producto en la base de datos
        // Create creates a new product in the database
        Create(ctx context.Context, newProduct models.Product) (models.Product, error)

        // CreateByBatch crea múltiples productos en una sola transacción
        // CreateByBatch creates multiple products in a single transaction
        CreateByBatch(ctx context.Context, products []models.Product) ([]models.Product, error)

        // Update actualiza un producto existente
        // Update updates an existing product
        Update(ctx context.Context, id int64, product models.Product) (models.Product, error)

        // Delete elimina un producto por su ID
        // Delete removes a product by its ID
        Delete(ctx context.Context, id int64) error

        // Exists verifica si un producto existe por su ID
        // Exists checks if a product exists by its ID
        Exists(ctx context.Context, id int64) (bool, error)

        // ExistsByProductCode verifica si existe un producto con el código dado
        // ExistsByProductCode checks if a product exists with the given product code
        ExistsByProductCode(ctx context.Context, productCode string) (bool, error)
}

// service implementa la interfaz ProductRepository
// service implements the ProductRepository interface
type service struct {
        db *sql.DB
}

// GetAll obtiene todos los productos de la base de datos
// GetAll retrieves all products from the database
func (pr *service) GetAll(ctx context.Context) ([]models.Product, error) <span class="cov0" title="0">{
        rows, err := pr.db.QueryContext(ctx, queryGetAllProducts)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query products: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var products []models.Product
        for rows.Next() </span><span class="cov0" title="0">{
                var p models.Product

                if err := rows.Scan(&amp;p.Id, &amp;p.Description, &amp;p.ExpirationRate, &amp;p.FreezingRate, &amp;p.Height,
                        &amp;p.Length, &amp;p.NetWeight, &amp;p.ProductCode, &amp;p.RecommendedFreezingTemperature,
                        &amp;p.Width, &amp;p.ProductTypeID, &amp;p.SellerID); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan product row: %w", err)
                }</span>
                <span class="cov0" title="0">products = append(products, p)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating product rows: %w", err)
        }</span>

        <span class="cov0" title="0">return products, nil</span>
}

// GetByID obtiene un producto específico por su ID
// GetByID retrieves a specific product by its ID
func (pr *service) GetByID(ctx context.Context, id int64) (models.Product, error) <span class="cov0" title="0">{
        var p models.Product
        err := pr.db.QueryRowContext(ctx, queryGetProductByID, id).Scan(
                &amp;p.Id, &amp;p.Description, &amp;p.ExpirationRate, &amp;p.FreezingRate, &amp;p.Height,
                &amp;p.Length, &amp;p.NetWeight, &amp;p.ProductCode, &amp;p.RecommendedFreezingTemperature,
                &amp;p.Width, &amp;p.ProductTypeID, &amp;p.SellerID,
        )

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return models.Product{}, error_message.ErrNotFound
                }</span>
                <span class="cov0" title="0">return models.Product{}, fmt.Errorf("failed to scan product with id %d: %w", id, err)</span>
        }

        <span class="cov0" title="0">return p, nil</span>
}

// Create crea un nuevo producto en la base de datos y retorna el producto con su ID asignado
// Create creates a new product in the database and returns the product with its assigned ID
func (pr *service) Create(ctx context.Context, newProduct models.Product) (models.Product, error) <span class="cov0" title="0">{
        result, err := pr.db.ExecContext(ctx, queryCreateProduct, newProduct.Description, newProduct.ExpirationRate,
                newProduct.FreezingRate, newProduct.Height, newProduct.Length, newProduct.NetWeight,
                newProduct.ProductCode, newProduct.RecommendedFreezingTemperature, newProduct.Width,
                newProduct.ProductTypeID, newProduct.SellerID)

        if err != nil </span><span class="cov0" title="0">{
                return models.Product{}, fmt.Errorf("failed to create product: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return models.Product{}, fmt.Errorf("failed to get last insert id for product: %w", err)
        }</span>

        <span class="cov0" title="0">newProduct.Id = id
        return newProduct, nil</span>
}

// CreateByBatch crea múltiples productos en una sola transacción para mejorar el rendimiento
// CreateByBatch creates multiple products in a single transaction to improve performance
func (pr *service) CreateByBatch(ctx context.Context, products []models.Product) ([]models.Product, error) <span class="cov0" title="0">{
        // Inicia una transacción para asegurar atomicidad
        // Start a transaction to ensure atomicity
        tx, err := pr.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to begin transaction: %w", err)
        }</span>

        <span class="cov0" title="0">defer tx.Rollback()

        // Prepara la declaración SQL para reutilizar
        // Prepare the SQL statement for reuse
        stmt, err := tx.PrepareContext(ctx, queryCreateProduct)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to prepare statement: %w", err)
        }</span>
        <span class="cov0" title="0">defer stmt.Close()

        // Ejecuta la inserción para cada producto
        // Execute the insertion for each product
        for i := range products </span><span class="cov0" title="0">{
                product := &amp;products[i]
                result, err := stmt.ExecContext(ctx, product.Description, product.ExpirationRate,
                        product.FreezingRate, product.Height, product.Length, product.NetWeight,
                        product.ProductCode, product.RecommendedFreezingTemperature, product.Width,
                        product.ProductTypeID, product.SellerID)

                if err != nil </span><span class="cov0" title="0">{

                        return nil, fmt.Errorf("failed to execute statement for product %s: %w", product.ProductCode, err)
                }</span>

                <span class="cov0" title="0">id, err := result.LastInsertId()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get last insert id for product %s: %w", product.ProductCode, err)
                }</span>
                <span class="cov0" title="0">product.Id = id</span>
        }

        // Confirma la transacción
        // Commit the transaction
        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return products, nil</span>
}

// Update actualiza un producto existente en la base de datos
// Update updates an existing product in the database
func (pr *service) Update(ctx context.Context, id int64, product models.Product) (models.Product, error) <span class="cov0" title="0">{
        result, err := pr.db.ExecContext(ctx, queryUpdateProduct,
                product.Description, product.ExpirationRate, product.FreezingRate, product.Height,
                product.Length, product.NetWeight, product.ProductCode, product.RecommendedFreezingTemperature,
                product.Width, product.ProductTypeID, product.SellerID, id)

        if err != nil </span><span class="cov0" title="0">{
                return models.Product{}, fmt.Errorf("failed to update product %d: %w", id, err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return models.Product{}, fmt.Errorf("failed to get rows affected for product %d: %w", id, err)
        }</span>

        // Verifica si el producto existe
        // Check if the product exists
        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return models.Product{}, error_message.ErrNotFound
        }</span>

        <span class="cov0" title="0">product.Id = id
        return product, nil</span>
}

// Delete elimina un producto de la base de datos por su ID
// Delete removes a product from the database by its ID
func (pr *service) Delete(ctx context.Context, id int64) error <span class="cov0" title="0">{
        result, err := pr.db.ExecContext(ctx, queryDeleteProduct, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete product %d: %w", id, err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected on delete for product %d: %w", id, err)
        }</span>

        // Verifica si el producto existía
        // Check if the product existed
        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return error_message.ErrNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Exists verifica si un producto existe en la base de datos por su ID
// Exists checks if a product exists in the database by its ID
func (pr *service) Exists(ctx context.Context, id int64) (bool, error) <span class="cov0" title="0">{
        var exists int
        err := pr.db.QueryRowContext(ctx, queryExistProductID, id).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("error checking existence of product %d: %w", id, err)</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

// ExistsByProductCode verifica si existe un producto con el código de producto dado
// ExistsByProductCode checks if a product exists with the given product code
func (pr *service) ExistsByProductCode(ctx context.Context, productCode string) (bool, error) <span class="cov0" title="0">{
        var exists int
        err := pr.db.QueryRowContext(ctx, queryExistProductCode, productCode).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("error checking existence of product code %s: %w", productCode, err)</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/error_message"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
)

var purchaseOrderRepositoryInstance PurchaseOrderRepositoryI

// GetNewPurchaseOrderMySQLRepository - Creates and returns a new instance of MySqlPurchaseOrderRepository using singleton pattern
// GetNewPurchaseOrderMySQLRepository - Crea y retorna una nueva instancia de MySqlPurchaseOrderRepository usando patrón singleton
func GetNewPurchaseOrderMySQLRepository(db *sql.DB) PurchaseOrderRepositoryI <span class="cov0" title="0">{
        if purchaseOrderRepositoryInstance != nil </span><span class="cov0" title="0">{
                return purchaseOrderRepositoryInstance
        }</span>

        <span class="cov0" title="0">purchaseOrderRepositoryInstance = &amp;MySqlPurchaseOrderRepository{
                db: db,
        }
        return purchaseOrderRepositoryInstance</span>
}

// PurchaseOrderRepositoryI - Interface defining the contract for purchase order repository operations
// PurchaseOrderRepositoryI - Interfaz que define el contrato para las operaciones del repositorio de órdenes de compra
type PurchaseOrderRepositoryI interface {
        // GetAll - Retrieves all purchase orders from the database and returns them as a map with order ID as key
        // GetAll - Obtiene todas las órdenes de compra de la base de datos y las retorna como un mapa con el ID de la orden como clave
        GetAll(ctx context.Context) (map[int]models.PurchaseOrder, error)

        // Create - Inserts a new purchase order into the database and returns the created order with its generated ID
        // Create - Inserta una nueva orden de compra en la base de datos y retorna la orden creada con su ID generado
        Create(ctx context.Context, order models.PurchaseOrder) (models.PurchaseOrder, error)

        // ExistPurchaseOrderByOrderNumber - Checks if a purchase order with the given order number already exists in the database
        // ExistPurchaseOrderByOrderNumber - Verifica si una orden de compra con el número de orden dado ya existe en la base de datos
        ExistPurchaseOrderByOrderNumber(ctx context.Context, orderNumber string) (bool, error)

        // GetPurchaseOrdersReportByBuyerId - Retrieves a purchase order report for a specific buyer ID showing buyer info and order count
        // GetPurchaseOrdersReportByBuyerId - Obtiene un reporte de órdenes de compra para un ID de comprador específico mostrando información del comprador y conteo de órdenes
        GetPurchaseOrdersReportByBuyerId(ctx context.Context, buyerId int) (models.PurchaseOrderReport, error)

        // GetAllPurchaseOrdersReports - Retrieves purchase order reports for all buyers showing buyer info and their order counts
        // GetAllPurchaseOrdersReports - Obtiene reportes de órdenes de compra para todos los compradores mostrando información del comprador y sus conteos de órdenes
        GetAllPurchaseOrdersReports(ctx context.Context) ([]models.PurchaseOrderReport, error)
}

// MySqlPurchaseOrderRepository - MySQL implementation of the PurchaseOrderRepositoryI interface
// MySqlPurchaseOrderRepository - Implementación MySQL de la interfaz PurchaseOrderRepositoryI
type MySqlPurchaseOrderRepository struct {
        db *sql.DB // Database connection / Conexión a la base de datos
}

// GetAll - Retrieves all purchase orders from the database and returns them as a map with order ID as key
// GetAll - Obtiene todas las órdenes de compra de la base de datos y las retorna como un mapa con el ID de la orden como clave
func (r *MySqlPurchaseOrderRepository) GetAll(ctx context.Context) (map[int]models.PurchaseOrder, error) <span class="cov0" title="0">{
        orders := make(map[int]models.PurchaseOrder)

        // SQL query to select all purchase order fields / Consulta SQL para seleccionar todos los campos de la orden de compra
        query := "select id, order_number, order_date, tracking_code, buyer_id, product_record_id from purchase_orders"

        rows, err := r.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return orders, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        // Create temporary map to store orders before returning / Crear mapa temporal para almacenar órdenes antes de retornar
        tempOrdersMap := make(map[int]models.PurchaseOrder)

        // Iterate through all rows and map each order to the result map / Itera a través de todas las filas y mapea cada orden al mapa de resultados
        for rows.Next() </span><span class="cov0" title="0">{
                order := models.PurchaseOrder{}
                err := rows.Scan(&amp;order.Id, &amp;order.OrderNumber, &amp;order.OrderDate, &amp;order.TrackingCode, &amp;order.BuyerId, &amp;order.ProductRecordId)
                if err != nil </span><span class="cov0" title="0">{
                        return orders, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
                }</span>

                <span class="cov0" title="0">tempOrdersMap[order.Id] = order</span>
        }

        <span class="cov0" title="0">orders = tempOrdersMap
        return orders, nil</span>
}

// Create - Inserts a new purchase order into the database and returns the created order with its generated ID
// Create - Inserta una nueva orden de compra en la base de datos y retorna la orden creada con su ID generado
func (r *MySqlPurchaseOrderRepository) Create(ctx context.Context, order models.PurchaseOrder) (models.PurchaseOrder, error) <span class="cov0" title="0">{
        // SQL query to insert new purchase order / Consulta SQL para insertar nueva orden de compra
        query := `insert into purchase_orders (order_number, order_date, tracking_code, buyer_id, product_record_id)
        values (?, ?, ?, ?, ?)`

        result, err := r.db.ExecContext(ctx, query, order.OrderNumber, order.OrderDate, order.TrackingCode, order.BuyerId, order.ProductRecordId)
        if err != nil </span><span class="cov0" title="0">{
                return models.PurchaseOrder{}, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
        }</span>

        // Get the auto-generated ID from the database / Obtiene el ID autogenerado de la base de datos
        <span class="cov0" title="0">lastId, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return models.PurchaseOrder{}, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
        }</span>

        <span class="cov0" title="0">order.Id = int(lastId)
        return order, nil</span>
}

// GetPurchaseOrdersReportByBuyerId - Retrieves a purchase order report for a specific buyer ID showing buyer info and order count
// GetPurchaseOrdersReportByBuyerId - Obtiene un reporte de órdenes de compra para un ID de comprador específico mostrando información del comprador y conteo de órdenes
func (r *MySqlPurchaseOrderRepository) GetPurchaseOrdersReportByBuyerId(ctx context.Context, buyerId int) (models.PurchaseOrderReport, error) <span class="cov0" title="0">{
        report := models.PurchaseOrderReport{}

        // Complex SQL query using INNER JOIN to get buyer info and count their purchase orders / Consulta SQL compleja usando INNER JOIN para obtener información del comprador y contar sus órdenes de compra
        query := `select b.id, b.id_card_number, b.first_name, b.last_name, count(po.id) as "purchase_orders_count"
from productos_frescos.buyers b
inner join productos_frescos.purchase_orders po on po.buyer_id = b.id
where b.id = ?
group by b.id`
        row := r.db.QueryRowContext(ctx, query, buyerId)

        err := row.Scan(&amp;report.Id, &amp;report.IdCardNumber, &amp;report.FirstName, &amp;report.LastName, &amp;report.PurchaseOrderCount)
        if err != nil </span><span class="cov0" title="0">{
                // Handle case when no buyer is found / Maneja el caso cuando no se encuentra ningún comprador
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return models.PurchaseOrderReport{}, fmt.Errorf("%w. %s %d %s", error_message.ErrNotFound, "Buyer with Id", buyerId, "doesn't exists.")
                }</span>
                <span class="cov0" title="0">return models.PurchaseOrderReport{}, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())</span>
        }

        <span class="cov0" title="0">return report, nil</span>
}

// GetAllPurchaseOrdersReports - Retrieves purchase order reports for all buyers showing buyer info and their order counts
// GetAllPurchaseOrdersReports - Obtiene reportes de órdenes de compra para todos los compradores mostrando información del comprador y sus conteos de órdenes
func (r *MySqlPurchaseOrderRepository) GetAllPurchaseOrdersReports(ctx context.Context) ([]models.PurchaseOrderReport, error) <span class="cov0" title="0">{
        reports := []models.PurchaseOrderReport{}

        // Complex SQL query using INNER JOIN to get all buyers info and count their purchase orders / Consulta SQL compleja usando INNER JOIN para obtener información de todos los compradores y contar sus órdenes de compra
        query := `select b.id, b.id_card_number, b.first_name, b.last_name, count(po.id) as "purchase_orders_count"
from productos_frescos.buyers b
inner join productos_frescos.purchase_orders po on po.buyer_id = b.id
group by b.id
order by b.id`

        rows, err := r.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return []models.PurchaseOrderReport{}, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        // Iterate through all rows and scan each report into the results slice / Itera a través de todas las filas y escanea cada reporte en el slice de resultados
        for rows.Next() </span><span class="cov0" title="0">{
                report := models.PurchaseOrderReport{}
                err := rows.Scan(&amp;report.Id, &amp;report.IdCardNumber, &amp;report.FirstName, &amp;report.LastName, &amp;report.PurchaseOrderCount)
                if err != nil </span><span class="cov0" title="0">{
                        return []models.PurchaseOrderReport{}, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
                }</span>

                <span class="cov0" title="0">reports = append(reports, report)</span>
        }
        <span class="cov0" title="0">return reports, nil</span>
}

// ExistPurchaseOrderByOrderNumber - Checks if a purchase order with the given order number already exists in the database
// ExistPurchaseOrderByOrderNumber - Verifica si una orden de compra con el número de orden dado ya existe en la base de datos
func (r *MySqlPurchaseOrderRepository) ExistPurchaseOrderByOrderNumber(ctx context.Context, orderNumber string) (bool, error) <span class="cov0" title="0">{
        // Simple query to check purchase order existence using LIMIT 1 for efficiency / Consulta simple para verificar existencia de la orden de compra usando LIMIT 1 por eficiencia
        query := "SELECT 1 FROM purchase_orders WHERE order_number = ? LIMIT 1 "

        var exists int64
        err := r.db.QueryRowContext(ctx, query, orderNumber).Scan(&amp;exists)

        if err != nil </span><span class="cov0" title="0">{
                // If no rows found, order number doesn't exist (not an error) / Si no se encuentran filas, el número de orden no existe (no es un error)
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("error al verificar la existencia del order number: %w", err)</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
        "github.com/sajimenezher_meli/meli-frescos-8/pkg/database"
)

var sectionRepositoryInstance SectionRepositoryI

// GetSectionRepository - Creates and returns a new instance of sectionRepository using singleton pattern
// GetSectionRepository - Crea y retorna una nueva instancia de sectionRepository usando patrón singleton
func GetSectionRepository(db *sql.DB) SectionRepositoryI <span class="cov0" title="0">{
        if sectionRepositoryInstance != nil </span><span class="cov0" title="0">{
                return sectionRepositoryInstance
        }</span>

        <span class="cov0" title="0">sectionRepositoryInstance = &amp;sectionRepository{
                database:  db,
                tablename: "sections",
        }

        return sectionRepositoryInstance</span>
}

// SectionRepositoryI - Interface defining the contract for section repository operations
// SectionRepositoryI - Interfaz que define el contrato para las operaciones del repositorio de secciones
type SectionRepositoryI interface {
        // GetAll - Retrieves all sections from the database
        // GetAll - Obtiene todas las secciones de la base de datos
        GetAll(ctx context.Context) ([]*models.Section, error)

        // GetByID - Retrieves a specific section by its ID from the database
        // GetByID - Obtiene una sección específica por su ID de la base de datos
        GetByID(ctx context.Context, id int) (*models.Section, error)

        // Create - Inserts a new section into the database and assigns the generated ID to the model
        // Create - Inserta una nueva sección en la base de datos y asigna el ID generado al modelo
        Create(ctx context.Context, model *models.Section) error

        // Update - Modifies an existing section in the database with the provided data
        // Update - Modifica una sección existente en la base de datos con los datos proporcionados
        Update(ctx context.Context, model *models.Section) error

        // ExistWithID - Checks if a section with the given ID exists in the database
        // ExistWithID - Verifica si una sección con el ID dado existe en la base de datos
        ExistWithID(ctx context.Context, id int) bool

        // ExistsWithSectionNumber - Checks if a section exists with the given section number, excluding a specific ID
        // ExistsWithSectionNumber - Verifica si existe una sección con el número de sección dado, excluyendo un ID específico
        ExistsWithSectionNumber(ctx context.Context, id int, sectionNumber string) bool

        // DeleteByID - Removes a section from the database by its ID
        // DeleteByID - Elimina una sección de la base de datos por su ID
        DeleteByID(ctx context.Context, id int) error
}

// sectionRepository - Implementation of SectionRepositoryI using a generic database helper
// sectionRepository - Implementación de SectionRepositoryI usando un helper genérico de base de datos
type sectionRepository struct {
        database  *sql.DB // Database connection / Conexión a la base de datos
        tablename string  // Table name for sections / Nombre de tabla para secciones
}

// GetAll - Retrieves all sections from the database and returns them as a slice of pointers
// GetAll - Obtiene todas las secciones de la base de datos y las retorna como un slice de punteros
func (r *sectionRepository) GetAll(ctx context.Context) ([]*models.Section, error) <span class="cov0" title="0">{
        // Define columns to select from the sections table / Definir columnas a seleccionar de la tabla de secciones
        columns := []string{"Id", "section_number", "current_capacity", "current_temperature", "maximum_capacity", "minimum_capacity", "minimum_temperature", "product_type_id", "warehouse_id"}

        // Execute select query using generic database helper / Ejecutar consulta select usando helper genérico de base de datos
        rows, err := database.Select(ctx, r.database, r.tablename, columns, "")

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">defer rows.Close()

        var sections []*models.Section

        // Iterate through all rows and scan each section into the results slice
        // Itera a través de todas las filas y escanea cada sección en el slice de resultados
        for rows.Next() </span><span class="cov0" title="0">{
                var section models.Section
                if err := rows.Scan(
                        &amp;section.Id,
                        &amp;section.SectionNumber,
                        &amp;section.CurrentCapacity,
                        &amp;section.CurrentTemperature,
                        &amp;section.MaximumCapacity,
                        &amp;section.MinimumCapacity,
                        &amp;section.MinimumTemperature,
                        &amp;section.ProductTypeID,
                        &amp;section.WarehouseID,
                ); err != nil </span><span class="cov0" title="0">{
                        return sections, err
                }</span>

                <span class="cov0" title="0">sections = append(sections, &amp;section)</span>
        }

        <span class="cov0" title="0">return sections, nil</span>

}

// GetByID - Retrieves a specific section by its ID from the database
// GetByID - Obtiene una sección específica por su ID de la base de datos
func (r *sectionRepository) GetByID(ctx context.Context, id int) (*models.Section, error) <span class="cov0" title="0">{
        // Define columns to select from the sections table / Definir columnas a seleccionar de la tabla de secciones
        columns := []string{"Id", "section_number", "current_capacity", "current_temperature", "maximum_capacity", "minimum_capacity", "minimum_temperature", "product_type_id", "warehouse_id"}
        // Execute select query for specific ID using generic database helper / Ejecutar consulta select para ID específico usando helper genérico de base de datos
        row := database.SelectOne(ctx, r.database, r.tablename, columns, "Id = ?", id)

        var section models.Section

        // Scan the row into the section model / Escanear la fila en el modelo de sección
        if err := row.Scan(
                &amp;section.Id,
                &amp;section.SectionNumber,
                &amp;section.CurrentCapacity,
                &amp;section.CurrentTemperature,
                &amp;section.MaximumCapacity,
                &amp;section.MinimumCapacity,
                &amp;section.MinimumTemperature,
                &amp;section.ProductTypeID,
                &amp;section.WarehouseID,
        ); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;section, nil</span>
}

// Create - Inserts a new section into the database with all required fields and sets the generated ID
// Create - Inserta una nueva sección en la base de datos con todos los campos requeridos y establece el ID generado
func (r *sectionRepository) Create(ctx context.Context, model *models.Section) error <span class="cov0" title="0">{
        // Prepare data map with all section fields / Preparar mapa de datos con todos los campos de la sección
        data := make(map[any]any)
        data["section_number"] = model.SectionNumber
        data["current_capacity"] = model.CurrentCapacity
        data["current_temperature"] = model.CurrentTemperature
        data["maximum_capacity"] = model.MaximumCapacity
        data["minimum_capacity"] = model.MinimumCapacity
        data["minimum_temperature"] = model.MinimumTemperature
        data["product_type_id"] = model.ProductTypeID
        data["warehouse_id"] = model.WarehouseID

        // Execute insert operation using generic database helper / Ejecutar operación de inserción usando helper genérico de base de datos
        result, err := database.Insert(ctx, r.database, r.tablename, data)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get the auto-generated ID and assign it to the model / Obtener el ID autogenerado y asignarlo al modelo
        <span class="cov0" title="0">newID, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">model.Id = int(newID)
        return nil</span>
}

// Update - Modifies an existing section in the database with the provided data using a direct SQL statement
// Update - Modifica una sección existente en la base de datos con los datos proporcionados usando una declaración SQL directa
func (r *sectionRepository) Update(ctx context.Context, model *models.Section) error <span class="cov0" title="0">{
        // Build SQL update statement with all section fields / Construir declaración SQL de actualización con todos los campos de sección
        sqlStatement := fmt.Sprintf("UPDATE %s SET `section_number`=?, `current_capacity`=?, `current_temperature`=?, `maximum_capacity`=?, `minimum_capacity`=?, `minimum_temperature`=?, `product_type_id`=?, `warehouse_id`=? WHERE `Id`=?", r.tablename)
        // Execute update statement with section data / Ejecutar declaración de actualización con datos de sección
        _, err := r.database.Exec(sqlStatement,
                model.SectionNumber,
                model.CurrentCapacity,
                model.CurrentTemperature,
                model.MaximumCapacity,
                model.MinimumCapacity,
                model.MinimumTemperature,
                model.ProductTypeID,
                model.WarehouseID,
                model.Id,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ExistWithID - Checks if a section with the given ID exists in the database
// ExistWithID - Verifica si una sección con el ID dado existe en la base de datos
func (r *sectionRepository) ExistWithID(ctx context.Context, id int) bool <span class="cov0" title="0">{
        // Query to count sections with the given ID / Consulta para contar secciones con el ID dado
        row := database.SelectOne(ctx, r.database, r.tablename, []string{"COUNT(Id)"}, "Id = ?", id)
        var count int
        if err := row.Scan(&amp;count); err != nil </span><span class="cov0" title="0">{
                // Return true on error to be safe for validation / Retornar true en caso de error para ser seguro en la validación
                return true
        }</span>

        <span class="cov0" title="0">return count != 0</span>
}

// ExistsWithSectionNumber - Checks if a section exists with the given section number, excluding a specific ID for update scenarios
// ExistsWithSectionNumber - Verifica si existe una sección con el número de sección dado, excluyendo un ID específico para escenarios de actualización
func (r *sectionRepository) ExistsWithSectionNumber(ctx context.Context, id int, sectionNumber string) bool <span class="cov0" title="0">{
        // Query to count sections with same section number but different ID / Consulta para contar secciones con el mismo número pero diferente ID
        row := database.SelectOne(ctx, r.database, r.tablename, []string{"COUNT(Id)"}, "section_number = ? AND Id &lt;&gt; ?", sectionNumber, id)
        var count string
        if err := row.Scan(&amp;count); err != nil </span><span class="cov0" title="0">{
                // Return true on error to be safe for validation / Retornar true en caso de error para ser seguro en la validación
                return true
        }</span>

        <span class="cov0" title="0">return count != "0"</span>
}

// DeleteByID - Removes a section from the database by its ID using the generic database helper
// DeleteByID - Elimina una sección de la base de datos por su ID usando el helper genérico de base de datos
func (r *sectionRepository) DeleteByID(ctx context.Context, id int) error <span class="cov0" title="0">{
        // Execute delete operation using generic database helper / Ejecutar operación de eliminación usando helper genérico de base de datos
        _, err := database.Delete(ctx, r.database, r.tablename, "Id = ?", id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package repositories

import (
        "database/sql"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/error_message"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
)

var sellerRepositoryInstance SellerRepository

// NewSQLSellerRepository - Creates and returns a new instance of SQLSellerRepository using singleton pattern
// NewSQLSellerRepository - Crea y retorna una nueva instancia de SQLSellerRepository usando patrón singleton
func NewSQLSellerRepository(db *sql.DB) SellerRepository <span class="cov0" title="0">{
        if sellerRepositoryInstance != nil </span><span class="cov0" title="0">{
                return sellerRepositoryInstance
        }</span>

        <span class="cov0" title="0">sellerRepositoryInstance = &amp;SQLSellerRepository{db: db}
        return sellerRepositoryInstance</span>
}

// SellerRepository - Interface defining the contract for seller repository operations
// SellerRepository - Interfaz que define el contrato para las operaciones del repositorio de vendedores
type SellerRepository interface {
        // GetAll - Retrieves all sellers from the database
        // GetAll - Obtiene todos los vendedores de la base de datos
        GetAll() ([]models.Seller, error)

        // Save - Creates a new seller in the database with validation checks for CID uniqueness and locality existence
        // Save - Crea un nuevo vendedor en la base de datos con validaciones de unicidad de CID y existencia de localidad
        Save(seller models.Seller) ([]models.Seller, error)

        // Update - Modifies an existing seller in the database with partial update support
        // Update - Modifica un vendedor existente en la base de datos con soporte para actualizaciones parciales
        Update(id int, seller models.Seller) ([]models.Seller, error)

        // Delete - Removes a seller from the database by their ID
        // Delete - Elimina un vendedor de la base de datos por su ID
        Delete(id int) error
}

// SQLSellerRepository - SQL implementation of the SellerRepository interface
// SQLSellerRepository - Implementación SQL de la interfaz SellerRepository
type SQLSellerRepository struct {
        db *sql.DB // Database connection / Conexión a la base de datos
}

// GetAll - Retrieves all sellers from the database and returns them as a slice
// GetAll - Obtiene todos los vendedores de la base de datos y los retorna como un slice
func (r *SQLSellerRepository) GetAll() ([]models.Seller, error) <span class="cov0" title="0">{
        // Execute query to select all seller fields / Ejecutar consulta para seleccionar todos los campos del vendedor
        rows, err := r.db.Query("SELECT id, cid, company_name, address, telephone, locality_id FROM sellers")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        // Iterate through all rows and scan each seller into the results slice
        // Itera a través de todas las filas y escanea cada vendedor en el slice de resultados
        var sellers []models.Seller
        for rows.Next() </span><span class="cov0" title="0">{
                var s models.Seller
                if err := rows.Scan(&amp;s.Id, &amp;s.CID, &amp;s.CompanyName, &amp;s.Address, &amp;s.Telephone, &amp;s.LocalityID); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">sellers = append(sellers, s)</span>
        }
        <span class="cov0" title="0">return sellers, nil</span>
}

// Save - Creates a new seller in the database with validation for CID uniqueness and locality existence
// Save - Crea un nuevo vendedor en la base de datos con validación de unicidad de CID y existencia de localidad
func (r *SQLSellerRepository) Save(seller models.Seller) ([]models.Seller, error) <span class="cov0" title="0">{
        // Validate that no other seller exists with the same CID / Validar que no exista otro vendedor con el mismo CID
        var exists bool
        err := r.db.QueryRow("SELECT EXISTS(SELECT 1 FROM sellers WHERE cid = ?)", seller.CID).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return nil, error_message.ErrAlreadyExists
        }</span>

        // Validate that the locality exists before creating the seller / Validar que la localidad existe antes de crear el vendedor
        <span class="cov0" title="0">var existsLocality bool
        err = r.db.QueryRow("SELECT EXISTS(SELECT 1 FROM localities WHERE id = ?)", seller.LocalityID).Scan(&amp;existsLocality)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !existsLocality </span><span class="cov0" title="0">{
                return nil, error_message.ErrDependencyNotFound
        }</span>

        // Execute insert statement with seller data / Ejecutar declaración de inserción con datos del vendedor
        <span class="cov0" title="0">res, err := r.db.Exec("INSERT INTO sellers (cid, company_name, address, telephone, locality_id) VALUES (?, ?, ?, ?, ?)",
                seller.CID, seller.CompanyName, seller.Address, seller.Telephone, seller.LocalityID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get the auto-generated ID and assign it to the seller / Obtener el ID autogenerado y asignarlo al vendedor
        <span class="cov0" title="0">lastID, err := res.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">seller.Id = int(lastID)
        return []models.Seller{seller}, nil</span>
}

// Update - Modifies an existing seller in the database with support for partial updates
// Update - Modifica un vendedor existente en la base de datos con soporte para actualizaciones parciales
func (r *SQLSellerRepository) Update(id int, seller models.Seller) ([]models.Seller, error) <span class="cov0" title="0">{
        // Retrieve existing seller data to perform partial update / Obtener datos del vendedor existente para realizar actualización parcial
        var existing models.Seller
        err := r.db.QueryRow("SELECT id, cid, company_name, address, telephone, locality_id FROM sellers WHERE id = ?", id).
                Scan(&amp;existing.Id, &amp;existing.CID, &amp;existing.CompanyName, &amp;existing.Address, &amp;existing.Telephone, &amp;existing.LocalityID)

        // Handle case when seller is not found / Manejar el caso cuando el vendedor no se encuentra
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, error_message.ErrNotFound
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update only the provided fields (partial update logic) / Actualizar solo los campos proporcionados (lógica de actualización parcial)
        <span class="cov0" title="0">if seller.CID != "" </span><span class="cov0" title="0">{
                existing.CID = seller.CID
        }</span>
        <span class="cov0" title="0">if seller.CompanyName != "" </span><span class="cov0" title="0">{
                existing.CompanyName = seller.CompanyName
        }</span>
        <span class="cov0" title="0">if seller.Address != "" </span><span class="cov0" title="0">{
                existing.Address = seller.Address
        }</span>
        <span class="cov0" title="0">if seller.Telephone != "" </span><span class="cov0" title="0">{
                existing.Telephone = seller.Telephone
        }</span>

        <span class="cov0" title="0">if seller.LocalityID != 0 </span><span class="cov0" title="0">{
                existing.LocalityID = seller.LocalityID
        }</span>

        // Execute update statement with merged data / Ejecutar declaración de actualización con datos combinados
        <span class="cov0" title="0">_, err = r.db.Exec("UPDATE sellers SET cid = ?, company_name = ?, address = ?, telephone = ?, locality_id = ? WHERE id = ?",
                existing.CID, existing.CompanyName, existing.Address, existing.Telephone, existing.LocalityID, id)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return []models.Seller{existing}, nil</span>
}

// Delete - Removes a seller from the database by their ID
// Delete - Elimina un vendedor de la base de datos por su ID
func (r *SQLSellerRepository) Delete(id int) error <span class="cov0" title="0">{
        // Execute delete statement for the specified seller ID / Ejecutar declaración de eliminación para el ID del vendedor especificado
        res, err := r.db.Exec("DELETE FROM sellers WHERE id = ?", id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if any rows were affected to confirm deletion / Verificar si alguna fila fue afectada para confirmar la eliminación
        <span class="cov0" title="0">count, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // If no rows affected, seller doesn't exist / Si ninguna fila fue afectada, el vendedor no existe
        <span class="cov0" title="0">if count == 0 </span><span class="cov0" title="0">{
                return error_message.ErrNotFound
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/error_message"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
)

// Warehouse table and field constants / Constantes de tabla y campos de almacén
const (
        warehouseTable = "warehouse"

        // Field groups for better maintainability / Grupos de campos para mejor mantenibilidad
        warehouseFields       = "`id`, `address`, `telephone`, `warehouse_code`, `minimum_capacity`, `minimum_temperature`"
        warehouseInsertFields = "`address`, `telephone`, `warehouse_code`, `minimum_capacity`, `minimum_temperature`, `locality_id`"
        warehouseUpdateFields = "`address` = ?, `telephone` = ?, `warehouse_code` = ?, `minimum_capacity` = ?, `minimum_temperature` = ?"
)

// Warehouse query strings - organized by operation type / Cadenas de consulta de almacén - organizadas por tipo de operación
var (
        // SELECT queries / Consultas SELECT
        queryGetAllWarehouses = fmt.Sprintf("SELECT %s FROM `%s`", warehouseFields, warehouseTable)
        queryGetWarehouseById = fmt.Sprintf("SELECT %s FROM `%s` WHERE `id` = ?", warehouseFields, warehouseTable)
        queryExistsByCode     = fmt.Sprintf("SELECT COUNT(*) FROM `%s` WHERE `warehouse_code` = ?", warehouseTable)

        // INSERT queries / Consultas INSERT
        queryCreateWarehouse = fmt.Sprintf("INSERT INTO `%s`(%s) VALUES (?,?,?,?,?,?)", warehouseTable, warehouseInsertFields)

        // UPDATE queries / Consultas UPDATE
        queryUpdateWarehouse = fmt.Sprintf("UPDATE `%s` SET %s WHERE `id` = ?", warehouseTable, warehouseUpdateFields)

        // DELETE queries / Consultas DELETE
        queryDeleteWarehouse = fmt.Sprintf("DELETE FROM `%s` WHERE `id` = ?", warehouseTable)

        warehouseRepositoryInstance WarehouseRepository
)

// NewWarehouseRepository - Creates and returns a new instance of WarehouseRepositoryImpl using singleton pattern
// NewWarehouseRepository - Crea y retorna una nueva instancia de WarehouseRepositoryImpl usando patrón singleton
func NewWarehouseRepository(db *sql.DB) WarehouseRepository <span class="cov0" title="0">{
        if warehouseRepositoryInstance != nil </span><span class="cov0" title="0">{
                return warehouseRepositoryInstance
        }</span>
        <span class="cov0" title="0">warehouseRepositoryInstance = &amp;WarehouseRepositoryImpl{db: db}
        return warehouseRepositoryInstance</span>
}

// WarehouseRepository - Interface defining the contract for warehouse repository operations
// WarehouseRepository - Interfaz que define el contrato para las operaciones del repositorio de almacenes
type WarehouseRepository interface {
        // GetAll - Retrieves all warehouses from the database
        // GetAll - Obtiene todos los almacenes de la base de datos
        GetAll(ctx context.Context) ([]models.Warehouse, error)

        // Create - Inserts a new warehouse into the database and returns the created warehouse with its generated ID
        // Create - Inserta un nuevo almacén en la base de datos y retorna el almacén creado con su ID generado
        Create(ctx context.Context, warehouse models.Warehouse) (models.Warehouse, error)

        // ExistsByCode - Checks if a warehouse with the given warehouse code already exists in the database
        // ExistsByCode - Verifica si un almacén con el código de almacén dado ya existe en la base de datos
        ExistsByCode(ctx context.Context, code string) (bool, error)

        // GetById - Retrieves a specific warehouse by its ID from the database
        // GetById - Obtiene un almacén específico por su ID de la base de datos
        GetById(ctx context.Context, id int) (models.Warehouse, error)

        // Delete - Removes a warehouse from the database by its ID
        // Delete - Elimina un almacén de la base de datos por su ID
        Delete(ctx context.Context, id int) error

        // Update - Modifies an existing warehouse in the database and returns the updated warehouse
        // Update - Modifica un almacén existente en la base de datos y retorna el almacén actualizado
        Update(ctx context.Context, id int, warehouse models.Warehouse) (models.Warehouse, error)
}

// WarehouseRepositoryImpl - Implementation of the WarehouseRepository interface
// WarehouseRepositoryImpl - Implementación de la interfaz WarehouseRepository
type WarehouseRepositoryImpl struct {
        db *sql.DB // Database connection / Conexión a la base de datos
}

// GetAll - Retrieves all warehouses from the database and returns them as a slice
// GetAll - Obtiene todos los almacenes de la base de datos y los retorna como un slice
func (r *WarehouseRepositoryImpl) GetAll(ctx context.Context) ([]models.Warehouse, error) <span class="cov0" title="0">{
        // Execute query to select all warehouse fields / Ejecutar consulta para seleccionar todos los campos del almacén
        rows, err := r.db.QueryContext(ctx, queryGetAllWarehouses)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("warehouse: %v\n", err.Error())
                return nil, fmt.Errorf("%w: %v", error_message.ErrInternalServerError, err)
        }</span>

        // Iterate through all rows and scan each warehouse into the results slice
        // Itera a través de todas las filas y escanea cada almacén en el slice de resultados
        <span class="cov0" title="0">warehouses := []models.Warehouse{}
        for rows.Next() </span><span class="cov0" title="0">{
                var w models.Warehouse
                err := rows.Scan(&amp;w.Id, &amp;w.Address, &amp;w.Telephone, &amp;w.WareHouseCode, &amp;w.MinimumCapacity, &amp;w.MinimumTemperature)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w: %v", error_message.ErrInternalServerError, err)
                }</span>
                <span class="cov0" title="0">warehouses = append(warehouses, w)</span>

        }
        <span class="cov0" title="0">return warehouses, nil</span>

}

// Create - Inserts a new warehouse into the database and returns the created warehouse with its generated ID
// Create - Inserta un nuevo almacén en la base de datos y retorna el almacén creado con su ID generado
func (r *WarehouseRepositoryImpl) Create(ctx context.Context, warehouse models.Warehouse) (models.Warehouse, error) <span class="cov0" title="0">{
        // Execute insert statement with warehouse data / Ejecutar declaración de inserción con datos del almacén
        result, err := r.db.ExecContext(ctx, queryCreateWarehouse,
                warehouse.Address, warehouse.Telephone, warehouse.WareHouseCode, warehouse.MinimumCapacity, warehouse.MinimumTemperature, warehouse.LocalityId)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("warehouse: %v\n", err.Error())
                return models.Warehouse{}, fmt.Errorf("%w: %v", error_message.ErrInternalServerError, err)
        }</span>

        // Get the auto-generated ID and assign it to the warehouse / Obtener el ID autogenerado y asignarlo al almacén
        <span class="cov0" title="0">lastInsertId, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return models.Warehouse{}, fmt.Errorf("%w: %v", error_message.ErrInternalServerError, err)
        }</span>
        <span class="cov0" title="0">warehouse.Id = int(lastInsertId)

        return warehouse, nil</span>
}

// ExistsByCode - Checks if a warehouse with the given warehouse code already exists in the database
// ExistsByCode - Verifica si un almacén con el código de almacén dado ya existe en la base de datos
func (r *WarehouseRepositoryImpl) ExistsByCode(ctx context.Context, code string) (bool, error) <span class="cov0" title="0">{
        // Execute query to count warehouses with the given code / Ejecutar consulta para contar almacenes con el código dado
        row := r.db.QueryRowContext(ctx, queryExistsByCode, code)

        var count int
        err := row.Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("%w: %v", error_message.ErrInternalServerError, err)
        }</span>

        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

// GetById - Retrieves a specific warehouse by its ID from the database
// GetById - Obtiene un almacén específico por su ID de la base de datos
func (r *WarehouseRepositoryImpl) GetById(ctx context.Context, id int) (models.Warehouse, error) <span class="cov0" title="0">{
        // Execute query to select warehouse by specific ID / Ejecutar consulta para seleccionar almacén por ID específico
        row := r.db.QueryRowContext(ctx, queryGetWarehouseById, id)

        var warehouse models.Warehouse
        err := row.Scan(&amp;warehouse.Id, &amp;warehouse.Address, &amp;warehouse.Telephone, &amp;warehouse.WareHouseCode, &amp;warehouse.MinimumCapacity, &amp;warehouse.MinimumTemperature)
        if err != nil </span><span class="cov0" title="0">{
                // Handle case when no warehouse is found / Manejar el caso cuando no se encuentra ningún almacén
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return models.Warehouse{}, fmt.Errorf("%w: warehouse with id %d", error_message.ErrNotFound, id)
                }</span>
                <span class="cov0" title="0">return models.Warehouse{}, fmt.Errorf("%w: %v", error_message.ErrInternalServerError, err)</span>
        }

        <span class="cov0" title="0">return warehouse, nil</span>
}

// Delete - Removes a warehouse from the database by its ID
// Delete - Elimina un almacén de la base de datos por su ID
func (r *WarehouseRepositoryImpl) Delete(ctx context.Context, id int) error <span class="cov0" title="0">{
        // Execute delete statement for the specified warehouse ID / Ejecutar declaración de eliminación para el ID del almacén especificado
        _, err := r.db.ExecContext(ctx, queryDeleteWarehouse, id)
        if err != nil </span><span class="cov0" title="0">{
                // Handle case when no warehouse is found / Manejar el caso cuando no se encuentra ningún almacén
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return fmt.Errorf("%w: warehouse with id %d", error_message.ErrNotFound, id)
                }</span>
                <span class="cov0" title="0">fmt.Printf("warehouse: %v\n", err.Error())
                return fmt.Errorf("%w: %v", error_message.ErrInternalServerError, err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Update - Modifies an existing warehouse in the database and returns the updated warehouse
// Update - Modifica un almacén existente en la base de datos y retorna el almacén actualizado
func (r *WarehouseRepositoryImpl) Update(ctx context.Context, id int, warehouse models.Warehouse) (models.Warehouse, error) <span class="cov0" title="0">{
        // Execute update statement with warehouse data / Ejecutar declaración de actualización con datos del almacén
        result, err := r.db.ExecContext(ctx, queryUpdateWarehouse,
                warehouse.Address, warehouse.Telephone, warehouse.WareHouseCode, warehouse.MinimumCapacity, warehouse.MinimumTemperature, id)
        if err != nil </span><span class="cov0" title="0">{
                return models.Warehouse{}, fmt.Errorf("%w: %v", error_message.ErrInternalServerError, err)
        }</span>

        // Check if any rows were affected to confirm update / Verificar si alguna fila fue afectada para confirmar la actualización
        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return models.Warehouse{}, fmt.Errorf("%w: %v", error_message.ErrInternalServerError, err)
        }</span>

        // If no rows affected, warehouse doesn't exist / Si ninguna fila fue afectada, el almacén no existe
        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return models.Warehouse{}, fmt.Errorf("%w: warehouse with id %d", error_message.ErrNotFound, id)
        }</span>

        <span class="cov0" title="0">return warehouse, nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package routes

import (
        "net/http"

        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/container"
)

func SetupRoutes(c *container.Container) *chi.Mux <span class="cov0" title="0">{

        router := chi.NewRouter()

        router.Use(middleware.Logger)
        router.Use(middleware.Recoverer)

        router.Route("/api/v1", func(r chi.Router) </span><span class="cov0" title="0">{

                r.Get("/", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        w.Header().Set("Content-Type", "application/json")
                        w.WriteHeader(http.StatusOK)
                        w.Write([]byte(`{"message": "API v1 is running", "status": "active"}`))
                }</span>)

                <span class="cov0" title="0">r.Route("/employee", func(rt chi.Router) </span><span class="cov0" title="0">{

                        rt.Get("/", c.EmployeeHandler.GetAllEmployee())
                        rt.Get("/{id}", c.EmployeeHandler.GetByIdEmployee())
                        rt.Post("/", c.EmployeeHandler.PostEmployee())
                        rt.Patch("/{id}", c.EmployeeHandler.PatchEmployee())
                        rt.Delete("/{id}", c.EmployeeHandler.DeleteByIdEmployee())

                        rt.Get("/reportInboundOrders", c.InboundOrderHandler.GetInboundOrdersReport())

                }</span>)

                <span class="cov0" title="0">r.Route("/buyers", func(r chi.Router) </span><span class="cov0" title="0">{

                        r.Get("/", c.BuyerHandler.GetAll())
                        r.Get("/{id}", c.BuyerHandler.GetById())
                        r.Delete("/{id}", c.BuyerHandler.DeleteById())
                        r.Post("/", c.BuyerHandler.PostBuyer())
                        r.Patch("/{id}", c.BuyerHandler.PatchBuyer())
                        r.Get("/reportPurchaseOrders", c.PurchaseOrderHandler.GetPurchaseOrdersReport())
                }</span>)

                <span class="cov0" title="0">r.Route("/warehouse", func(r chi.Router) </span><span class="cov0" title="0">{

                        r.Get("/{id}", c.WarehouseHandler.GetById)
                        r.Get("/", c.WarehouseHandler.GetAll)
                        r.Post("/", c.WarehouseHandler.Create)
                        r.Patch("/{id}", c.WarehouseHandler.Update)
                        r.Delete("/{id}", c.WarehouseHandler.Delete)
                }</span>)

                <span class="cov0" title="0">r.Route("/sellers", func(r chi.Router) </span><span class="cov0" title="0">{

                        r.Get("/", c.SellerHandler.GetAll)
                        r.Get("/{id}", c.SellerHandler.GetById)
                        r.Post("/", c.SellerHandler.Save)
                        r.Patch("/{id}", c.SellerHandler.Update)
                        r.Delete("/{id}", c.SellerHandler.Delete)
                }</span>)

                <span class="cov0" title="0">r.Route("/sections", func(rt chi.Router) </span><span class="cov0" title="0">{
                        rt.Get("/", c.SectionHandler.GetAll)
                        rt.Get("/{id}", c.SectionHandler.GetByID)
                        rt.Get("/reportProducts", c.ProductBatchHandler.GetReportProduct)
                        rt.Post("/", c.SectionHandler.Create)
                        rt.Patch("/{id}", c.SectionHandler.Update)
                        rt.Delete("/{id}", c.SectionHandler.DeleteByID)
                }</span>)

                <span class="cov0" title="0">r.Route("/products", func(r chi.Router) </span><span class="cov0" title="0">{

                        r.Get("/", c.ProductHandler.GetAll)
                        r.Get("/{id}", c.ProductHandler.Get)
                        r.Post("/", c.ProductHandler.Create)
                        r.Patch("/{id}", c.ProductHandler.Update)
                        r.Delete("/{id}", c.ProductHandler.Delete)

                        //Product Records
                        r.Get("/reportRecords", c.ProductRecordHandler.GetReport)
                }</span>)

                <span class="cov0" title="0">r.Route("/productBatches", func(r chi.Router) </span><span class="cov0" title="0">{
                        r.Post("/", c.ProductBatchHandler.Create)
                }</span>)

                <span class="cov0" title="0">r.Route("/purchaseOrders", func(r chi.Router) </span><span class="cov0" title="0">{
                        r.Get("/", c.PurchaseOrderHandler.GetAll())
                        r.Post("/", c.PurchaseOrderHandler.PostPurchaseOrder())
                }</span>)
                <span class="cov0" title="0">r.Post("/productRecords", c.ProductRecordHandler.Create)

                r.Route("/localities", func(r chi.Router) </span><span class="cov0" title="0">{
                        r.Post("/", c.LocalityHandler.Save)
                        r.Get("/reportSellers", c.LocalityHandler.GetSellerReportByLocality)
                        r.Get("/reportCarriers", c.CarryHandler.GetCarryReportByLocality)
                }</span>)

                <span class="cov0" title="0">r.Route("/carriers", func(r chi.Router) </span><span class="cov0" title="0">{
                        r.Post("/", c.CarryHandler.Create)
                }</span>)

                <span class="cov0" title="0">r.Route("/inboundOrders", func(rt chi.Router) </span><span class="cov0" title="0">{
                        rt.Post("/", c.InboundOrderHandler.PostInboundOrder())
                }</span>)

        })

        <span class="cov0" title="0">return router</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package services

import (
        "context"
        "fmt"
        "slices"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/error_message"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/repositories"
)

var buyerServiceInstance BuyerServiceI

// GetBuyerService - Creates and returns a new instance of BuyerService with the required repository using singleton pattern
// GetBuyerService - Crea y retorna una nueva instancia de BuyerService con el repositorio requerido usando patrón singleton
func GetBuyerService(repo repositories.BuyerRepositoryI) BuyerServiceI <span class="cov0" title="0">{
        if buyerServiceInstance != nil </span><span class="cov0" title="0">{
                return buyerServiceInstance
        }</span>

        <span class="cov0" title="0">buyerServiceInstance = &amp;BuyerService{
                repository: repo,
        }
        return buyerServiceInstance</span>
}

// BuyerServiceI - Interface defining the contract for buyer service operations with business logic
// BuyerServiceI - Interfaz que define el contrato para las operaciones del servicio de compradores con lógica de negocio
type BuyerServiceI interface {
        // GetAll - Retrieves all buyers from the system
        // GetAll - Obtiene todos los compradores del sistema
        GetAll(ctx context.Context) (map[int]models.Buyer, error)

        // GetById - Retrieves a specific buyer by their ID
        // GetById - Obtiene un comprador específico por su ID
        GetById(ctx context.Context, id int) (models.Buyer, error)

        // DeleteById - Removes a buyer from the system by their ID
        // DeleteById - Elimina un comprador del sistema por su ID
        DeleteById(ictx context.Context, d int) error

        // Create - Creates a new buyer with business validation (card number uniqueness)
        // Create - Crea un nuevo comprador con validación de negocio (unicidad del número de tarjeta)
        Create(ctx context.Context, buyer models.Buyer) (models.Buyer, error)

        // Update - Updates an existing buyer with business validation (card number uniqueness)
        // Update - Actualiza un comprador existente con validación de negocio (unicidad del número de tarjeta)
        Update(ctx context.Context, buyerId int, buyer models.Buyer) (models.Buyer, error)
}

// BuyerService - Implementation of BuyerServiceI containing business logic for buyer operations
// BuyerService - Implementación de BuyerServiceI que contiene la lógica de negocio para operaciones de compradores
type BuyerService struct {
        repository repositories.BuyerRepositoryI // Repository dependency for data access / Dependencia del repositorio para acceso a datos
}

// GetAll - Delegates retrieving all buyers to the repository
// GetAll - Delega la obtención de todos los compradores al repositorio
func (s *BuyerService) GetAll(ctx context.Context) (map[int]models.Buyer, error) <span class="cov0" title="0">{
        return s.repository.GetAll(ctx)
}</span>

// GetById - Delegates retrieving a buyer by their ID to the repository
// GetById - Delega la obtención de un comprador por su ID al repositorio
func (s *BuyerService) GetById(ctx context.Context, id int) (models.Buyer, error) <span class="cov0" title="0">{
        return s.repository.GetById(ctx, id)
}</span>

// DeleteById - Delegates removing a buyer from the repository by their ID
// DeleteById - Delega la eliminación de un comprador del repositorio por su ID
func (s *BuyerService) DeleteById(ctx context.Context, id int) error <span class="cov0" title="0">{
        return s.repository.DeleteById(ctx, id)
}</span>

// Create - Creates a new buyer with business validation to ensure card number uniqueness
// Create - Crea un nuevo comprador con validación de negocio para asegurar la unicidad del número de tarjeta
func (s *BuyerService) Create(ctx context.Context, buyer models.Buyer) (models.Buyer, error) <span class="cov0" title="0">{
        // Business validation: Get all existing card numbers to check for duplicates
        // Validación de negocio: Obtener todos los números de tarjeta existentes para verificar duplicados
        existingCardNumbers, err := s.repository.GetCardNumberIds()
        if err != nil </span><span class="cov0" title="0">{
                return models.Buyer{}, err
        }</span>

        // Business rule: Card number must be unique across all buyers
        // Regla de negocio: El número de tarjeta debe ser único entre todos los compradores
        <span class="cov0" title="0">if slices.Contains(existingCardNumbers, buyer.CardNumberId) </span><span class="cov0" title="0">{
                return models.Buyer{}, fmt.Errorf("%w - %s %s %s", error_message.ErrAlreadyExists, "card number with id:", buyer.CardNumberId, "already exists.")
        }</span>

        // If validation passes, delegate to repository for persistence
        // Si la validación pasa, delegar al repositorio para la persistencia
        <span class="cov0" title="0">return s.repository.Create(ctx, buyer)</span>
}

// Update - Updates an existing buyer with business validation to ensure card number uniqueness
// Update - Actualiza un comprador existente con validación de negocio para asegurar la unicidad del número de tarjeta
func (s *BuyerService) Update(ctx context.Context, id int, buyer models.Buyer) (models.Buyer, error) <span class="cov0" title="0">{
        // Business validation: Get all existing card numbers to check for duplicates
        // Validación de negocio: Obtener todos los números de tarjeta existentes para verificar duplicados
        existingCardNumbers, err := s.repository.GetCardNumberIds()
        if err != nil </span><span class="cov0" title="0">{
                return models.Buyer{}, err
        }</span>

        // Business rule: Card number must be unique across all buyers (excluding current buyer)
        // Regla de negocio: El número de tarjeta debe ser único entre todos los compradores (excluyendo el comprador actual)
        <span class="cov0" title="0">if slices.Contains(existingCardNumbers, buyer.CardNumberId) </span><span class="cov0" title="0">{
                return models.Buyer{}, fmt.Errorf("%w - %s %s %s", error_message.ErrAlreadyExists, "card number with id:", buyer.CardNumberId, "already exists.")
        }</span>

        // If validation passes, delegate to repository for persistence
        // Si la validación pasa, delegar al repositorio para la persistencia
        <span class="cov0" title="0">return s.repository.Update(ctx, id, buyer)</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package services

import (
        "context"
        "fmt"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/error_message"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/responses"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/repositories"
)

var carryServiceInstance CarryService

// NewCarryService - Creates and returns a new instance of CarryServiceImpl with required repositories using singleton pattern
// NewCarryService - Crea y retorna una nueva instancia de CarryServiceImpl con los repositorios requeridos usando patrón singleton
func NewCarryService(r repositories.CarryRepository, lr repositories.LocalityRepository) CarryService <span class="cov0" title="0">{
        if carryServiceInstance != nil </span><span class="cov0" title="0">{
                return carryServiceInstance
        }</span>
        <span class="cov0" title="0">carryServiceInstance = &amp;CarryServiceImpl{carryRepository: r, localityRepository: lr}
        return carryServiceInstance</span>
}

// CarryService - Interface defining the contract for carry service operations with business logic
// CarryService - Interfaz que define el contrato para las operaciones del servicio de transportistas con lógica de negocio
type CarryService interface {
        // CreateCarry - Creates a new carry (carrier) with business validation (locality existence and CID uniqueness)
        // CreateCarry - Crea un nuevo transportista con validación de negocio (existencia de localidad y unicidad de CID)
        CreateCarry(ctx context.Context, carry models.Carry) (models.Carry, error)

        // GetCarryReportByLocality - Retrieves carry reports for all localities or a specific locality with validation
        // GetCarryReportByLocality - Obtiene reportes de transportistas para todas las localidades o una localidad específica con validación
        GetCarryReportByLocality(ctx context.Context, localityID int) ([]responses.LocalityCarryReport, error)
}

// CarryServiceImpl - Implementation of CarryService containing business logic for carry operations
// CarryServiceImpl - Implementación de CarryService que contiene la lógica de negocio para operaciones de transportistas
type CarryServiceImpl struct {
        carryRepository    repositories.CarryRepository    // Repository dependency for carry data access / Dependencia del repositorio para acceso a datos de transportistas
        localityRepository repositories.LocalityRepository // Repository dependency for locality validation / Dependencia del repositorio para validación de localidades
}

// CreateCarry - Creates a new carry with comprehensive business validation
// CreateCarry - Crea un nuevo transportista con validación integral de negocio
func (s *CarryServiceImpl) CreateCarry(ctx context.Context, carry models.Carry) (models.Carry, error) <span class="cov0" title="0">{
        // Business validation: Verify that the locality exists before creating the carry
        // Validación de negocio: Verificar que la localidad existe antes de crear el transportista
        localityExists, err := s.localityRepository.ExistById(ctx, carry.LocalityId)
        if err != nil </span><span class="cov0" title="0">{
                return models.Carry{}, fmt.Errorf("%w: %v", error_message.ErrInternalServerError, err)
        }</span>
        <span class="cov0" title="0">if !localityExists </span><span class="cov0" title="0">{
                return models.Carry{}, fmt.Errorf("%w: locality with id %d", error_message.ErrNotFound, carry.LocalityId)
        }</span>

        // Business rule: CID must be unique across all carries
        // Regla de negocio: El CID debe ser único entre todos los transportistas
        <span class="cov0" title="0">exists, err := s.carryRepository.ExistsByCid(ctx, carry.Cid)
        if err != nil </span><span class="cov0" title="0">{
                return models.Carry{}, fmt.Errorf("%w: %v", error_message.ErrInternalServerError, err)
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return models.Carry{}, fmt.Errorf("%w: resource with the provided identifier already exists", error_message.ErrAlreadyExists)
        }</span>

        // If all validations pass, delegate to repository for persistence
        // Si todas las validaciones pasan, delegar al repositorio para la persistencia
        <span class="cov0" title="0">carry, err = s.carryRepository.Create(ctx, carry)
        if err != nil </span><span class="cov0" title="0">{
                return models.Carry{}, fmt.Errorf("%w: %v", error_message.ErrInternalServerError, err)
        }</span>
        <span class="cov0" title="0">return carry, nil</span>
}

// GetCarryReportByLocality - Retrieves carry reports with optional locality validation
// GetCarryReportByLocality - Obtiene reportes de transportistas con validación opcional de localidad
func (s *CarryServiceImpl) GetCarryReportByLocality(ctx context.Context, localityID int) ([]responses.LocalityCarryReport, error) <span class="cov0" title="0">{
        // Business validation: Only validate locality existence if a specific locality ID is provided
        // Validación de negocio: Solo validar la existencia de la localidad si se proporciona un ID de localidad específico
        if localityID != 0 </span><span class="cov0" title="0">{
                exists, err := s.localityRepository.ExistById(ctx, localityID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w: %v", error_message.ErrInternalServerError, err)
                }</span>
                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w: locality with id %d", error_message.ErrNotFound, localityID)
                }</span>
        }

        // Delegate to repository for data retrieval (if localityID = 0, returns all localities)
        // Delegar al repositorio para la recuperación de datos (si localityID = 0, retorna todas las localidades)
        <span class="cov0" title="0">reports, err := s.carryRepository.GetCarryReportsByLocality(ctx, localityID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: %v", error_message.ErrInternalServerError, err)
        }</span>
        <span class="cov0" title="0">return reports, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package services

import (
        "context"
        "fmt"
        "slices"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/error_message"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/repositories"
)

var employeeServiceInstance EmployeeServiceI

// GetEmployeeService - Creates and returns a new instance of EmployeeService with the required repository using singleton pattern
// GetEmployeeService - Crea y retorna una nueva instancia de EmployeeService con el repositorio requerido usando patrón singleton
func GetEmployeeService(repository repositories.EmployeeRepositoryI) EmployeeServiceI <span class="cov0" title="0">{
        if employeeServiceInstance != nil </span><span class="cov0" title="0">{
                return employeeServiceInstance
        }</span>
        <span class="cov0" title="0">employeeServiceInstance = &amp;EmployeeService{
                repository: repository,
        }
        return employeeServiceInstance</span>
}

// EmployeeServiceI - Interface defining the contract for employee service operations with business logic
// EmployeeServiceI - Interfaz que define el contrato para las operaciones del servicio de empleados con lógica de negocio
type EmployeeServiceI interface {
        // GetAll - Retrieves all employees from the system
        // GetAll - Obtiene todos los empleados del sistema
        GetAll(ctx context.Context) (map[int]models.Employee, error)

        // GetById - Retrieves a specific employee by their ID
        // GetById - Obtiene un empleado específico por su ID
        GetById(ctx context.Context, id int) (models.Employee, error)

        // DeleteById - Removes an employee from the system by their ID
        // DeleteById - Elimina un empleado del sistema por su ID
        DeleteById(ctx context.Context, id int) error

        // Create - Creates a new employee with business validation (card number uniqueness)
        // Create - Crea un nuevo empleado con validación de negocio (unicidad del número de tarjeta)
        Create(ctx context.Context, employee models.Employee) (models.Employee, error)

        // Update - Updates an existing employee with business validation (card number uniqueness)
        // Update - Actualiza un empleado existente con validación de negocio (unicidad del número de tarjeta)
        Update(ctx context.Context, employeeId int, employee models.Employee) (models.Employee, error)
}

// EmployeeService - Implementation of EmployeeServiceI containing business logic for employee operations
// EmployeeService - Implementación de EmployeeServiceI que contiene la lógica de negocio para operaciones de empleados
type EmployeeService struct {
        repository repositories.EmployeeRepositoryI // Repository dependency for data access / Dependencia del repositorio para acceso a datos
}

// GetAll - Delegates retrieving all employees to the repository
// GetAll - Delega la obtención de todos los empleados al repositorio
func (s *EmployeeService) GetAll(ctx context.Context) (map[int]models.Employee, error) <span class="cov0" title="0">{
        return s.repository.GetAll(ctx)

}</span>

// GetById - Delegates retrieving an employee by their ID to the repository
// GetById - Delega la obtención de un empleado por su ID al repositorio
func (s *EmployeeService) GetById(ctx context.Context, id int) (models.Employee, error) <span class="cov0" title="0">{
        return s.repository.GetById(ctx, id)
}</span>

// DeleteById - Delegates removing an employee from the repository by their ID
// DeleteById - Delega la eliminación de un empleado del repositorio por su ID
func (s *EmployeeService) DeleteById(ctx context.Context, id int) error <span class="cov0" title="0">{
        return s.repository.DeleteById(ctx, id)
}</span>

// Create - Creates a new employee with business validation to ensure card number uniqueness
// Create - Crea un nuevo empleado con validación de negocio para asegurar la unicidad del número de tarjeta
func (s *EmployeeService) Create(ctx context.Context, employee models.Employee) (models.Employee, error) <span class="cov0" title="0">{
        // Business validation: Get all existing card numbers to check for duplicates
        // Validación de negocio: Obtener todos los números de tarjeta existentes para verificar duplicados
        existingCardNumbers, err := s.repository.GetCardNumberIds()
        if err != nil </span><span class="cov0" title="0">{
                return models.Employee{}, err
        }</span>

        // Business rule: Card number must be unique across all employees
        // Regla de negocio: El número de tarjeta debe ser único entre todos los empleados
        <span class="cov0" title="0">if slices.Contains(existingCardNumbers, employee.CardNumberID) </span><span class="cov0" title="0">{
                return models.Employee{}, fmt.Errorf("%w - %s %s %s", error_message.ErrAlreadyExists, "card number with id:", employee.CardNumberID, "already exists.")
        }</span>

        // If validation passes, delegate to repository for persistence
        // Si la validación pasa, delegar al repositorio para la persistencia
        <span class="cov0" title="0">return s.repository.Create(ctx, employee)</span>
}

// Update - Updates an existing employee with business validation to ensure card number uniqueness
// Update - Actualiza un empleado existente con validación de negocio para asegurar la unicidad del número de tarjeta
func (s *EmployeeService) Update(ctx context.Context, employeeId int, employee models.Employee) (models.Employee, error) <span class="cov0" title="0">{
        // Business validation: Get all existing card numbers to check for duplicates
        // Validación de negocio: Obtener todos los números de tarjeta existentes para verificar duplicados
        existingCardNumbers, err := s.repository.GetCardNumberIds()
        if err != nil </span><span class="cov0" title="0">{
                return models.Employee{}, err
        }</span>

        // Business rule: Card number must be unique across all employees (excluding current employee)
        // Regla de negocio: El número de tarjeta debe ser único entre todos los empleados (excluyendo el empleado actual)
        <span class="cov0" title="0">if slices.Contains(existingCardNumbers, employee.CardNumberID) </span><span class="cov0" title="0">{
                return models.Employee{}, fmt.Errorf("%w - %s %s %s", error_message.ErrAlreadyExists, "card number with id:", employee.CardNumberID, "already exists.")
        }</span>

        // If validation passes, delegate to repository for persistence
        // Si la validación pasa, delegar al repositorio para la persistencia
        <span class="cov0" title="0">return s.repository.Update(ctx, employeeId, employee)</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package services

import (
        "context"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/error_message"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/repositories"
)

var inboundOrdersServiceInstance InboundOrdersServiceI

// GetInboundOrdersService - Creates and returns a new instance of InboundOrdersService with required repositories using singleton pattern
// GetInboundOrdersService - Crea y retorna una nueva instancia de InboundOrdersService con los repositorios requeridos usando patrón singleton
func GetInboundOrdersService(inboundOrderRepository repositories.InboundOrderRepositoryI, employeeRepository repositories.EmployeeRepositoryI) InboundOrdersServiceI <span class="cov0" title="0">{
        if inboundOrdersServiceInstance != nil </span><span class="cov0" title="0">{
                return inboundOrdersServiceInstance
        }</span>
        <span class="cov0" title="0">inboundOrdersServiceInstance = &amp;InboundOrdersService{
                InboundOrderRepository: inboundOrderRepository,
                EmployeeRepository:     employeeRepository,
        }
        return inboundOrdersServiceInstance</span>
}

// InboundOrdersServiceI - Interface defining the contract for inbound order service operations with business logic
// InboundOrdersServiceI - Interfaz que define el contrato para las operaciones del servicio de órdenes de entrada con lógica de negocio
type InboundOrdersServiceI interface {
        // GetAllInboundOrdersReports - Retrieves inbound order reports for all employees
        // GetAllInboundOrdersReports - Obtiene reportes de órdenes de entrada para todos los empleados
        GetAllInboundOrdersReports(ctx context.Context) ([]models.InboundOrderReport, error)

        // GetInboundOrdersReportByEmployeeId - Retrieves an inbound order report for a specific employee by ID
        // GetInboundOrdersReportByEmployeeId - Obtiene un reporte de órdenes de entrada para un empleado específico por ID
        GetInboundOrdersReportByEmployeeId(ctx context.Context, id int) (models.InboundOrderReport, error)

        // Create - Creates a new inbound order with comprehensive business validation
        // Create - Crea una nueva orden de entrada con validación integral de negocio
        Create(ctx context.Context, order models.InboundOrder) (models.InboundOrder, error)
}

// InboundOrdersService - Implementation of InboundOrdersServiceI containing business logic for inbound order operations
// InboundOrdersService - Implementación de InboundOrdersServiceI que contiene la lógica de negocio para operaciones de órdenes de entrada
type InboundOrdersService struct {
        InboundOrderRepository repositories.InboundOrderRepositoryI // Repository dependency for inbound order data access / Dependencia del repositorio para acceso a datos de órdenes de entrada
        EmployeeRepository     repositories.EmployeeRepositoryI     // Repository dependency for employee validation / Dependencia del repositorio para validación de empleados
}

// GetAllInboundOrdersReports - Delegates retrieving all inbound order reports to the repository
// GetAllInboundOrdersReports - Delega la obtención de todos los reportes de órdenes de entrada al repositorio
func (s *InboundOrdersService) GetAllInboundOrdersReports(ctx context.Context) ([]models.InboundOrderReport, error) <span class="cov0" title="0">{
        return s.InboundOrderRepository.GetAllInboundOrdersReports(ctx)
}</span>

// GetInboundOrdersReportByEmployeeId - Delegates retrieving an inbound order report by employee ID to the repository
// GetInboundOrdersReportByEmployeeId - Delega la obtención de un reporte de órdenes de entrada por ID de empleado al repositorio
func (s *InboundOrdersService) GetInboundOrdersReportByEmployeeId(ctx context.Context, id int) (models.InboundOrderReport, error) <span class="cov0" title="0">{
        return s.InboundOrderRepository.GetInboundOrdersReportByEmployeeId(ctx, id)
}</span>

// Create - Creates a new inbound order with comprehensive business validation
// Create - Crea una nueva orden de entrada con validación integral de negocio
func (s *InboundOrdersService) Create(ctx context.Context, order models.InboundOrder) (models.InboundOrder, error) <span class="cov0" title="0">{
        // Business validation: Validate all required fields are provided
        // Validación de negocio: Validar que todos los campos requeridos estén proporcionados
        if order.OrderNumber == "" || order.EmployeeId == 0 || order.ProductBatchId == 0 || order.WarehouseId == 0 || order.OrderDate.IsZero() </span><span class="cov0" title="0">{
                return models.InboundOrder{}, error_message.ErrInvalidInput
        }</span>

        // Business rule: Order number must be unique across all inbound orders
        // Regla de negocio: El número de orden debe ser único entre todas las órdenes de entrada
        <span class="cov0" title="0">exist, err := s.InboundOrderRepository.ExistsByOrderNumber(ctx, order.OrderNumber)
        if err != nil </span><span class="cov0" title="0">{
                return models.InboundOrder{}, err
        }</span>
        <span class="cov0" title="0">if exist </span><span class="cov0" title="0">{
                return models.InboundOrder{}, error_message.ErrAlreadyExists
        }</span>

        // Business validation: Verify that the referenced employee exists
        // Validación de negocio: Verificar que el empleado referenciado existe
        <span class="cov0" title="0">employeeExists, err := s.EmployeeRepository.ExistEmployeeById(ctx, order.EmployeeId)
        if err != nil </span><span class="cov0" title="0">{
                return models.InboundOrder{}, err
        }</span>
        <span class="cov0" title="0">if !employeeExists </span><span class="cov0" title="0">{
                return models.InboundOrder{}, error_message.ErrDependencyNotFound
        }</span>

        // If all validations pass, delegate to repository for persistence
        // Si todas las validaciones pasan, delegar al repositorio para la persistencia
        <span class="cov0" title="0">newOrder, err := s.InboundOrderRepository.Create(ctx, order)
        if err != nil </span><span class="cov0" title="0">{
                return models.InboundOrder{}, err
        }</span>

        <span class="cov0" title="0">return newOrder, nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package services

import (
        "context"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/responses"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/repositories"
)

var localityServiceInstance LocalityService

// NewSQLLocalityService - Creates and returns a new instance of SQLLocalityService with the required repository using singleton pattern
// NewSQLLocalityService - Crea y retorna una nueva instancia de SQLLocalityService con el repositorio requerido usando patrón singleton
func NewSQLLocalityService(repo repositories.LocalityRepository) LocalityService <span class="cov0" title="0">{
        if localityServiceInstance != nil </span><span class="cov0" title="0">{
                return localityServiceInstance
        }</span>
        <span class="cov0" title="0">localityServiceInstance = &amp;SQLLocalityService{repo: repo}
        return localityServiceInstance</span>
}

// LocalityService - Interface defining the contract for locality service operations with business logic
// LocalityService - Interfaz que define el contrato para las operaciones del servicio de localidades con lógica de negocio
type LocalityService interface {
        // Save - Creates a new locality in the system with country and province management
        // Save - Crea una nueva localidad en el sistema con manejo de país y provincia
        Save(ctx context.Context, locality models.Locality) (models.Locality, error)

        // GetSellerReports - Retrieves seller reports for all localities or a specific locality by ID
        // GetSellerReports - Obtiene reportes de vendedores para todas las localidades o una localidad específica por ID
        GetSellerReports(ctx context.Context, id int) ([]responses.LocalitySellerReport, error)
}

// SQLLocalityService - Implementation of LocalityService containing business logic for locality operations
// SQLLocalityService - Implementación de LocalityService que contiene la lógica de negocio para operaciones de localidades
type SQLLocalityService struct {
        repo repositories.LocalityRepository // Repository dependency for data access / Dependencia del repositorio para acceso a datos
}

// Save - Delegates saving a locality to the repository
// Save - Delega el guardado de una localidad al repositorio
func (s *SQLLocalityService) Save(ctx context.Context, locality models.Locality) (models.Locality, error) <span class="cov0" title="0">{
        return s.repo.Save(ctx, locality)
}</span>

// GetSellerReports - Delegates retrieving seller reports to the repository
// GetSellerReports - Delega la obtención de reportes de vendedores al repositorio
func (s *SQLLocalityService) GetSellerReports(ctx context.Context, id int) ([]responses.LocalitySellerReport, error) <span class="cov0" title="0">{
        return s.repo.GetSellerReports(ctx, id)
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package services

import (
        "context"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/repositories"
)

var productBatchServiceInstance ProductBatchServiceI

// GetProductBatchService - Creates and returns a new instance of productBatchService with the required repository using singleton pattern
// GetProductBatchService - Crea y retorna una nueva instancia de productBatchService con el repositorio requerido usando patrón singleton
func GetProductBatchService(repository repositories.ProductBatchRepositoryI) ProductBatchServiceI <span class="cov0" title="0">{
        if productBatchServiceInstance != nil </span><span class="cov0" title="0">{
                return productBatchServiceInstance
        }</span>

        <span class="cov0" title="0">productBatchServiceInstance = &amp;productBatchService{
                repository: repository,
        }
        return productBatchServiceInstance</span>
}

// ProductBatchServiceI - Interface defining the contract for product batch service operations with business logic
// ProductBatchServiceI - Interfaz que define el contrato para las operaciones del servicio de lotes de productos con lógica de negocio
type ProductBatchServiceI interface {
        // Create - Creates a new product batch in the system
        // Create - Crea un nuevo lote de producto en el sistema
        Create(ctx context.Context, model *models.ProductBatch) error

        // GetProductQuantityBySectionId - Retrieves the total quantity of products in a specific section
        // GetProductQuantityBySectionId - Obtiene la cantidad total de productos en una sección específica
        GetProductQuantityBySectionId(ctx context.Context, id int) int

        // ExistsWithBatchNumber - Checks if a product batch exists with the given batch number, excluding a specific ID
        // ExistsWithBatchNumber - Verifica si existe un lote de producto con el número de lote dado, excluyendo un ID específico
        ExistsWithBatchNumber(ctx context.Context, id int, batchNumber string) bool
}

// productBatchService - Implementation of ProductBatchServiceI containing business logic for product batch operations
// productBatchService - Implementación de ProductBatchServiceI que contiene la lógica de negocio para operaciones de lotes de productos
type productBatchService struct {
        repository repositories.ProductBatchRepositoryI // Repository dependency for data access / Dependencia del repositorio para acceso a datos
}

// Create - Delegates creating a product batch to the repository
// Create - Delega la creación de un lote de producto al repositorio
func (s *productBatchService) Create(ctx context.Context, model *models.ProductBatch) error <span class="cov0" title="0">{
        return s.repository.Create(ctx, model)
}</span>

// GetProductQuantityBySectionId - Delegates retrieving product quantity by section ID to the repository
// GetProductQuantityBySectionId - Delega la obtención de cantidad de producto por ID de sección al repositorio
func (s *productBatchService) GetProductQuantityBySectionId(ctx context.Context, id int) int <span class="cov0" title="0">{
        return s.repository.GetProductQuantityBySectionId(ctx, id)
}</span>

// ExistsWithBatchNumber - Delegates checking product batch existence by batch number to the repository
// ExistsWithBatchNumber - Delega la verificación de existencia de lote de producto por número de lote al repositorio
func (s *productBatchService) ExistsWithBatchNumber(ctx context.Context, id int, batchNumber string) bool <span class="cov0" title="0">{
        return s.repository.ExistsWithBatchNumber(ctx, id, batchNumber)
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package services

import (
        "context"
        "fmt"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/error_message"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/repositories"
)

var productRecordServiceInstance ProductRecordServiceI

// NewProductRecordService - Función constructora que crea una nueva instancia del servicio con inyección de dependencias
// NewProductRecordService - Constructor function that creates a new service instance with dependency injection
func NewProductRecordService(repository repositories.IProductRecordRepository, ProductService ProductService) ProductRecordServiceI <span class="cov0" title="0">{
        if productRecordServiceInstance != nil </span><span class="cov0" title="0">{
                return productRecordServiceInstance
        }</span>
        <span class="cov0" title="0">productRecordServiceInstance = &amp;productRecordService{Repository: repository, ProductService: ProductService}
        return productRecordServiceInstance</span>
}

// ProductRecordServiceI - Interfaz que define el contrato para la lógica de negocio de registros de productos
// ProductRecordServiceI - Interface defining the contract for product record business logic
type ProductRecordServiceI interface {
        // CreateProductRecord - Crea un nuevo registro de producto con validación de negocio
        // CreateProductRecord - Creates a new product record with business validation
        CreateProductRecord(ctx context.Context, productRecord models.ProductRecord) (*models.ProductRecord, error)

        // GetReportByIdProduct - Genera un reporte para un producto específico con validación de negocio
        // GetReportByIdProduct - Generates a report for a specific product with business validation
        GetReportByIdProduct(ctx context.Context, id int64) (*models.ProductRecordReport, error)

        // GetReport - Obtiene el reporte completo de todos los registros de productos
        // GetReport - Retrieves the complete report of all product records
        GetReport(ctx context.Context) ([]*models.ProductRecordReport, error)

        // ExistProductRecordByID - Verifica si existe un registro de producto por su ID
        // ExistProductRecordByID - Checks if a product record exists by its ID
        ExistProductRecordByID(ctx context.Context, id int64) bool
}

// productRecordService - Implementación de la capa de servicio que maneja la lógica de negocio para registros de productos
// productRecordService - Service layer implementation that handles business logic for product records
type productRecordService struct {
        Repository     repositories.IProductRecordRepository // Dependencia del repositorio para acceso a datos / Repository dependency for data access
        ProductService ProductService                        // Dependencia del servicio de productos para validaciones / Product service dependency for validations
}

// CreateProductRecord - Lógica de negocio para crear registros de productos con validación
// CreateProductRecord - Business logic for creating product records with validation
func (prs *productRecordService) CreateProductRecord(ctx context.Context, productRecord models.ProductRecord) (*models.ProductRecord, error) <span class="cov0" title="0">{
        // VALIDACIÓN DE NEGOCIO: Verificar si el producto referenciado existe antes de crear un registro
        // BUSINESS VALIDATION: Check if the referenced product exists before creating a record
        exist, err := prs.ProductService.ExistById(ctx, productRecord.ProductID)

        if err != nil </span><span class="cov0" title="0">{
                // Retorna estructura vacía en caso de error de base de datos
                // Return empty struct on database error
                return &amp;models.ProductRecord{}, err
        }</span>

        // REGLA DE NEGOCIO: No se puede crear un registro para un producto que no existe
        // BUSINESS RULE: Cannot create a record for a non-existent product
        <span class="cov0" title="0">if !exist </span><span class="cov0" title="0">{
                return &amp;models.ProductRecord{}, fmt.Errorf("error: product by id : %d does not exist. %w", productRecord.ProductID, error_message.ErrDependencyNotFound)
        }</span>

        // Si la validación pasa, delega al repositorio para la persistencia de datos
        // If validation passes, delegate to repository for data persistence
        <span class="cov0" title="0">return prs.Repository.Create(ctx, &amp;productRecord)</span>
}

// GetReportByIdProduct - Lógica de negocio para generar reportes de productos con validación
// GetReportByIdProduct - Business logic for generating product reports with validation
func (prs *productRecordService) GetReportByIdProduct(ctx context.Context, id int64) (*models.ProductRecordReport, error) <span class="cov0" title="0">{
        // VALIDACIÓN DE NEGOCIO: Verificar que el producto existe antes de generar el reporte
        // BUSINESS VALIDATION: Verify product exists before generating report
        exist, err := prs.ProductService.ExistById(ctx, id)

        if err != nil </span><span class="cov0" title="0">{
                // Retorna estructura vacía en caso de error de base de datos
                // Return empty struct on database error
                return &amp;models.ProductRecordReport{}, err
        }</span>

        // REGLA DE NEGOCIO: No se puede generar reporte para un producto que no existe
        // BUSINESS RULE: Cannot generate report for non-existent product
        <span class="cov0" title="0">if !exist </span><span class="cov0" title="0">{
                return &amp;models.ProductRecordReport{}, fmt.Errorf("error: product by id : %d does not exist %w", id, error_message.ErrDependencyNotFound)
        }</span>

        // Si la validación pasa, delega al repositorio para la recuperación de datos
        // If validation passes, delegate to repository for data retrieval
        <span class="cov0" title="0">return prs.Repository.GetReportByIdProduct(ctx, id)</span>
}

// GetReport - Obtiene el reporte completo de todos los registros de productos
// GetReport - Retrieves the complete report of all product records
func (prs *productRecordService) GetReport(ctx context.Context) ([]*models.ProductRecordReport, error) <span class="cov0" title="0">{
        return prs.Repository.GetReport(ctx)
}</span>

// ExistProductRecordByID - Verifica si existe un registro de producto por su ID
// ExistProductRecordByID - Checks if a product record exists by its ID
func (prs *productRecordService) ExistProductRecordByID(ctx context.Context, id int64) bool <span class="cov0" title="0">{
        return prs.Repository.ExistProductRecordByID(ctx, id)
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package services

import (
        "context"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/repositories"
)

var productServiceInstance ProductService

// NewProductService crea una nueva instancia del servicio de productos con inyección de dependencias
// NewProductService creates a new instance of the product service with dependency injection
func NewProductService(r repositories.ProductRepository) ProductService <span class="cov0" title="0">{
        if productServiceInstance != nil </span><span class="cov0" title="0">{
                return productServiceInstance
        }</span>
        <span class="cov0" title="0">productServiceInstance = &amp;service{
                repository: r,
        }
        return productServiceInstance</span>
}

// ProductService define la interfaz para la lógica de negocio de productos
// ProductService defines the interface for product business logic
type ProductService interface {
        // GetAll obtiene todos los productos del sistema
        // GetAll retrieves all products from the system
        GetAll(ctx context.Context) ([]models.Product, error)

        // GetByID obtiene un producto específico por su ID
        // GetByID retrieves a specific product by its ID
        GetByID(ctx context.Context, id int64) (models.Product, error)

        // Create crea un nuevo producto en el sistema
        // Create creates a new product in the system
        Create(ctx context.Context, product models.Product) (models.Product, error)

        // CreateByBatch crea múltiples productos en lote para mejorar rendimiento
        // CreateByBatch creates multiple products in batch to improve performance
        CreateByBatch(ctx context.Context, products []models.Product) ([]models.Product, error)

        // Update actualiza un producto existente
        // Update updates an existing product
        Update(ctx context.Context, id int64, product models.Product) (models.Product, error)

        // Delete elimina un producto del sistema
        // Delete removes a product from the system
        Delete(ctx context.Context, id int64) error

        // ExistById verifica si un producto existe por su ID
        // ExistById checks if a product exists by its ID
        ExistById(ctx context.Context, id int64) (bool, error)
}

// service implementa la interfaz ProductService
// service implements the ProductService interface
type service struct {
        repository repositories.ProductRepository
}

// GetAll delega la obtención de todos los productos al repositorio
// GetAll delegates retrieving all products to the repository
func (s *service) GetAll(ctx context.Context) ([]models.Product, error) <span class="cov0" title="0">{
        return s.repository.GetAll(ctx)
}</span>

// GetByID delega la obtención de un producto por ID al repositorio
// GetByID delegates retrieving a product by ID to the repository
func (s *service) GetByID(ctx context.Context, id int64) (models.Product, error) <span class="cov0" title="0">{
        return s.repository.GetByID(ctx, id)
}</span>

// Create delega la creación de un nuevo producto al repositorio
// Create delegates creating a new product to the repository
func (s *service) Create(ctx context.Context, newProduct models.Product) (models.Product, error) <span class="cov0" title="0">{
        return s.repository.Create(ctx, newProduct)
}</span>

// CreateByBatch delega la creación de múltiples productos en lote al repositorio
// CreateByBatch delegates creating multiple products in batch to the repository
func (s *service) CreateByBatch(ctx context.Context, products []models.Product) ([]models.Product, error) <span class="cov0" title="0">{
        return s.repository.CreateByBatch(ctx, products)
}</span>

// Update delega la actualización de un producto al repositorio
// Update delegates updating a product to the repository
func (s *service) Update(ctx context.Context, id int64, updateProduct models.Product) (models.Product, error) <span class="cov0" title="0">{
        return s.repository.Update(ctx, id, updateProduct)
}</span>

// Delete delega la eliminación de un producto al repositorio
// Delete delegates deleting a product to the repository
func (s *service) Delete(ctx context.Context, id int64) error <span class="cov0" title="0">{
        return s.repository.Delete(ctx, id)
}</span>

// ExistById delega la verificación de existencia de un producto al repositorio
// ExistById delegates checking product existence to the repository
func (s *service) ExistById(ctx context.Context, id int64) (bool, error) <span class="cov0" title="0">{
        return s.repository.Exists(ctx, id)
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package services

import (
        "context"
        "fmt"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/error_message"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/repositories"
)

var purchaseOrderServiceInstance PurchaseOrderServiceI

// GetPurchaseOrderService creates and returns a singleton instance of PurchaseOrderService with the required repositories
// GetPurchaseOrderService crea y retorna una instancia singleton de PurchaseOrderService con los repositorios requeridos
func GetPurchaseOrderService(purchaseOrderRepository repositories.PurchaseOrderRepositoryI, buyerRepository repositories.BuyerRepositoryI, productRecordRepository repositories.IProductRecordRepository) PurchaseOrderServiceI <span class="cov0" title="0">{
        if purchaseOrderServiceInstance != nil </span><span class="cov0" title="0">{
                return purchaseOrderServiceInstance
        }</span>
        <span class="cov0" title="0">purchaseOrderServiceInstance = &amp;PurchaseOrderService{
                PurchaseOrderRepository: purchaseOrderRepository,
                BuyerRepository:         buyerRepository,
                ProductRecordRepository: productRecordRepository,
        }
        return purchaseOrderServiceInstance</span>
}

// PurchaseOrderServiceI defines the contract for purchase order service operations with business logic
// PurchaseOrderServiceI define el contrato para las operaciones de servicio de órdenes de compra con lógica de negocio
type PurchaseOrderServiceI interface {
        GetAll(ctx context.Context) (map[int]models.PurchaseOrder, error)
        GetPurchaseOrdersReport(ctx context.Context, id *int) ([]models.PurchaseOrderReport, error)
        Create(ctx context.Context, order models.PurchaseOrder) (models.PurchaseOrder, error)
}

// PurchaseOrderService implements PurchaseOrderServiceI and contains business logic for purchase order operations
// PurchaseOrderService implementa PurchaseOrderServiceI y contiene la lógica de negocio para operaciones de órdenes de compra
type PurchaseOrderService struct {
        PurchaseOrderRepository repositories.PurchaseOrderRepositoryI // Repository for purchase order data access / Repositorio para acceso a datos de órdenes de compra
        BuyerRepository         repositories.BuyerRepositoryI         // Repository for buyer validation / Repositorio para validación de compradores
        ProductRecordRepository repositories.IProductRecordRepository // Repository for product record validation / Repositorio para validación de registros de productos
}

// GetAll retrieves all purchase orders from the repository
// GetAll recupera todas las órdenes de compra del repositorio
func (s *PurchaseOrderService) GetAll(ctx context.Context) (map[int]models.PurchaseOrder, error) <span class="cov0" title="0">{
        return s.PurchaseOrderRepository.GetAll(ctx)
}</span>

// GetPurchaseOrdersReport retrieves purchase order reports with optional filtering by buyer ID
// If id is provided, returns report for that specific buyer, otherwise returns reports for all buyers
// GetPurchaseOrdersReport recupera reportes de órdenes de compra con filtrado opcional por ID de comprador
// Si se proporciona id, retorna el reporte para ese comprador específico, de lo contrario retorna reportes para todos los compradores
func (s *PurchaseOrderService) GetPurchaseOrdersReport(ctx context.Context, id *int) ([]models.PurchaseOrderReport, error) <span class="cov0" title="0">{
        if id != nil </span><span class="cov0" title="0">{
                // Get report for specific buyer / Obtener reporte para comprador específico
                reports := []models.PurchaseOrderReport{}
                report, err := s.PurchaseOrderRepository.GetPurchaseOrdersReportByBuyerId(ctx, *id)
                if err != nil </span><span class="cov0" title="0">{
                        return reports, err
                }</span>
                <span class="cov0" title="0">reports = append(reports, report)
                return reports, nil</span>
        }
        // Get reports for all buyers / Obtener reportes para todos los compradores
        <span class="cov0" title="0">return s.PurchaseOrderRepository.GetAllPurchaseOrdersReports(ctx)</span>
}

// Create creates a new purchase order with comprehensive business validation
// Validates that the order number doesn't already exist, the buyer exists, and the product record exists
// Create crea una nueva orden de compra con validación de negocio comprensiva
// Valida que el número de orden no exista, que el comprador exista, y que el registro de producto exista
func (s *PurchaseOrderService) Create(ctx context.Context, order models.PurchaseOrder) (models.PurchaseOrder, error) <span class="cov0" title="0">{
        // Validate that order number doesn't exist / Validar que el número de orden no exista
        exists, err := s.PurchaseOrderRepository.ExistPurchaseOrderByOrderNumber(ctx, order.OrderNumber)
        if err != nil </span><span class="cov0" title="0">{
                return models.PurchaseOrder{}, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return models.PurchaseOrder{}, fmt.Errorf("%w. %s %s %s", error_message.ErrAlreadyExists, "Order number ", order.OrderNumber, "already exists.")
        }</span>

        // Validate that buyer ID exists / Validar que el ID del comprador exista
        <span class="cov0" title="0">exists, err = s.BuyerRepository.ExistBuyerById(ctx, order.BuyerId)
        if err != nil </span><span class="cov0" title="0">{
                return models.PurchaseOrder{}, fmt.Errorf("%w - %s", error_message.ErrInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return models.PurchaseOrder{}, fmt.Errorf("%w. %s %d %s", error_message.ErrNotFound, "Buyer with Id", order.BuyerId, "doesn't exists.")
        }</span>

        // Validate that product record ID exists / Validar que el ID del registro de producto exista
        <span class="cov0" title="0">exists = s.ProductRecordRepository.ExistProductRecordByID(ctx, int64(order.ProductRecordId))
        if !exists </span><span class="cov0" title="0">{
                return models.PurchaseOrder{}, fmt.Errorf("%w. %s %d %s", error_message.ErrNotFound, "Product record with Id", order.ProductRecordId, "doesn't exists.")
        }</span>

        // Create the purchase order after all validations pass / Crear la orden de compra después de que todas las validaciones pasen
        <span class="cov0" title="0">return s.PurchaseOrderRepository.Create(ctx, order)</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package services

import (
        "context"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/error_message"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/repositories"
)

var sectionServiceInstance SectionServiceI

// GetSectionService creates and returns a singleton instance of sectionService with the required repository
// GetSectionService crea y retorna una instancia singleton de sectionService con el repositorio requerido
func GetSectionService(repository repositories.SectionRepositoryI) SectionServiceI <span class="cov0" title="0">{
        if sectionServiceInstance != nil </span><span class="cov0" title="0">{
                return sectionServiceInstance
        }</span>

        <span class="cov0" title="0">sectionServiceInstance = &amp;sectionService{
                repository: repository,
        }
        return sectionServiceInstance</span>
}

// SectionServiceI defines the contract for section service operations with business logic and validation
// SectionServiceI define el contrato para las operaciones de servicio de secciones con lógica de negocio y validación
type SectionServiceI interface {
        GetAll(ctx context.Context) ([]*models.Section, error)
        GetByID(ctx context.Context, id int) (*models.Section, error)
        Create(ctx context.Context, model *models.Section) error
        Update(ctx context.Context, model *models.Section) error
        DeleteByID(ctx context.Context, id int) error
        ExistWithID(ctx context.Context, id int) bool
        ExistsWithSectionNumber(ctx context.Context, id int, sectionNumber string) bool
}

// sectionService implements SectionServiceI and contains business logic for section operations
// sectionService implementa SectionServiceI y contiene la lógica de negocio para operaciones de secciones
type sectionService struct {
        repository repositories.SectionRepositoryI // Repository for section data access / Repositorio para acceso a datos de secciones
}

// GetAll retrieves all sections from the repository
// GetAll recupera todas las secciones del repositorio
func (s *sectionService) GetAll(ctx context.Context) ([]*models.Section, error) <span class="cov0" title="0">{
        return s.repository.GetAll(ctx)
}</span>

// GetByID retrieves a section by its ID with error handling for non-existent sections
// GetByID recupera una sección por su ID con manejo de errores para secciones no existentes
func (s *sectionService) GetByID(ctx context.Context, id int) (*models.Section, error) <span class="cov0" title="0">{
        if model, err := s.repository.GetByID(ctx, id); err != nil </span><span class="cov0" title="0">{
                return model, error_message.ErrNotFound
        }</span> else<span class="cov0" title="0"> {
                return model, nil
        }</span>
}

// Create creates a new section in the repository
// Create crea una nueva sección en el repositorio
func (s *sectionService) Create(ctx context.Context, model *models.Section) error <span class="cov0" title="0">{
        return s.repository.Create(ctx, model)
}</span>

// Update modifies an existing section in the repository
// Update modifica una sección existente en el repositorio
func (s *sectionService) Update(ctx context.Context, model *models.Section) error <span class="cov0" title="0">{
        return s.repository.Update(ctx, model)
}</span>

// DeleteByID removes a section by its ID with error handling for non-existent sections
// DeleteByID elimina una sección por su ID con manejo de errores para secciones no existentes
func (s *sectionService) DeleteByID(ctx context.Context, id int) error <span class="cov0" title="0">{
        if err := s.repository.DeleteByID(ctx, id); err != nil </span><span class="cov0" title="0">{
                return error_message.ErrNotFound
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ExistWithID checks if a section exists by its ID
// ExistWithID verifica si una sección existe por su ID
func (s *sectionService) ExistWithID(ctx context.Context, id int) bool <span class="cov0" title="0">{
        return s.repository.ExistWithID(ctx, id)
}</span>

// ExistsWithSectionNumber checks if a section number exists, excluding a specific ID for updates
// ExistsWithSectionNumber verifica si un número de sección existe, excluyendo un ID específico para actualizaciones
func (s *sectionService) ExistsWithSectionNumber(ctx context.Context, id int, sectionNumber string) bool <span class="cov0" title="0">{
        return s.repository.ExistsWithSectionNumber(ctx, id, sectionNumber)
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package services

import (
        "github.com/sajimenezher_meli/meli-frescos-8/internal/error_message"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/repositories"
)

var sellerServiceInstance SellerService

// NewJSONSellerService creates and returns a singleton instance of JsonSellerService with the required repository
// NewJSONSellerService crea y retorna una instancia singleton de JsonSellerService con el repositorio requerido
func NewJSONSellerService(repo repositories.SellerRepository) SellerService <span class="cov0" title="0">{
        if sellerServiceInstance != nil </span><span class="cov0" title="0">{
                return sellerServiceInstance
        }</span>
        <span class="cov0" title="0">sellerServiceInstance = &amp;JsonSellerService{
                repo: repo,
        }
        return sellerServiceInstance</span>
}

// SellerService defines the contract for seller service operations with business logic
// SellerService define el contrato para las operaciones de servicio de vendedores con lógica de negocio
type SellerService interface {
        GetAll() ([]models.Seller, error)
        GetById(id int) (models.Seller, error)
        Save(seller models.Seller) ([]models.Seller, error)
        Update(id int, seller models.Seller) ([]models.Seller, error)
        Delete(id int) error
}

// JsonSellerService implements SellerService and contains business logic for seller operations using JSON storage
// JsonSellerService implementa SellerService y contiene la lógica de negocio para operaciones de vendedores usando almacenamiento JSON
type JsonSellerService struct {
        repo repositories.SellerRepository // Repository for seller data access / Repositorio para acceso a datos de vendedores
}

// GetAll retrieves all sellers from the repository
// GetAll recupera todos los vendedores del repositorio
func (s *JsonSellerService) GetAll() ([]models.Seller, error) <span class="cov0" title="0">{
        sellers, err := s.repo.GetAll()
        return sellers, err
}</span>

// GetById retrieves a seller by its ID with business logic to search through all sellers
// Returns ErrNotFound if the seller doesn't exist
// GetById recupera un vendedor por su ID con lógica de negocio para buscar entre todos los vendedores
// Retorna ErrNotFound si el vendedor no existe
func (s *JsonSellerService) GetById(id int) (models.Seller, error) <span class="cov0" title="0">{
        // Get all sellers from repository / Obtener todos los vendedores del repositorio
        sellers, err := s.repo.GetAll()
        if err != nil </span><span class="cov0" title="0">{
                return models.Seller{}, error_message.ErrNotFound
        }</span>

        // Search for seller with matching ID / Buscar vendedor con ID coincidente
        <span class="cov0" title="0">for _, seller := range sellers </span><span class="cov0" title="0">{
                if seller.Id == id </span><span class="cov0" title="0">{
                        return seller, nil
                }</span>
        }

        // Return error if seller not found / Retornar error si el vendedor no se encuentra
        <span class="cov0" title="0">return models.Seller{}, error_message.ErrNotFound</span>
}

// Save creates a new seller in the repository
// Save crea un nuevo vendedor en el repositorio
func (s *JsonSellerService) Save(seller models.Seller) ([]models.Seller, error) <span class="cov0" title="0">{
        sellerCreated, err := s.repo.Save(seller)
        return sellerCreated, err
}</span>

// Update modifies an existing seller by ID in the repository
// Update modifica un vendedor existente por ID en el repositorio
func (s *JsonSellerService) Update(id int, seller models.Seller) ([]models.Seller, error) <span class="cov0" title="0">{
        sellerFounded, err := s.repo.Update(id, seller)
        return sellerFounded, err
}</span>

// Delete removes a seller by ID from the repository
// Delete elimina un vendedor por ID del repositorio
func (s *JsonSellerService) Delete(id int) error <span class="cov0" title="0">{
        err := s.repo.Delete(id)
        return err
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package services

import (
        "context"
        "fmt"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/error_message"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/repositories"
)

var warehouseServiceInstance WarehouseService

// NewWarehouseService creates and returns a singleton instance of WarehouseServiceImpl with the required repository
// NewWarehouseService crea y retorna una instancia singleton de WarehouseServiceImpl con el repositorio requerido
func NewWarehouseService(warehouseRepository repositories.WarehouseRepository) WarehouseService <span class="cov0" title="0">{
        if warehouseServiceInstance != nil </span><span class="cov0" title="0">{
                return warehouseServiceInstance
        }</span>
        <span class="cov0" title="0">warehouseServiceInstance = &amp;WarehouseServiceImpl{warehouseRepository: warehouseRepository}
        return warehouseServiceInstance</span>
}

// WarehouseService defines the contract for warehouse service operations with business logic and validation
// WarehouseService define el contrato para las operaciones de servicio de almacenes con lógica de negocio y validación
type WarehouseService interface {
        GetAll(ctx context.Context) ([]models.Warehouse, error)
        Create(ctx context.Context, warehouse models.Warehouse) (models.Warehouse, error)
        ValidateCodeUniqueness(ctx context.Context, code string) error
        GetById(ctx context.Context, id int) (models.Warehouse, error)
        Delete(ctx context.Context, id int) error
        Update(ctx context.Context, id int, warehouse models.Warehouse) (models.Warehouse, error)
}

// WarehouseServiceImpl implements WarehouseService and contains business logic for warehouse operations
// WarehouseServiceImpl implementa WarehouseService y contiene la lógica de negocio para operaciones de almacenes
type WarehouseServiceImpl struct {
        warehouseRepository repositories.WarehouseRepository // Repository for warehouse data access / Repositorio para acceso a datos de almacenes
}

// GetAll retrieves all warehouses from the repository
// GetAll recupera todos los almacenes del repositorio
func (s *WarehouseServiceImpl) GetAll(ctx context.Context) ([]models.Warehouse, error) <span class="cov0" title="0">{
        return s.warehouseRepository.GetAll(ctx)
}</span>

// Create creates a new warehouse in the repository
// Create crea un nuevo almacén en el repositorio
func (s *WarehouseServiceImpl) Create(ctx context.Context, warehouse models.Warehouse) (models.Warehouse, error) <span class="cov0" title="0">{
        return s.warehouseRepository.Create(ctx, warehouse)
}</span>

// ValidateCodeUniqueness validates that a warehouse code is unique in the system
// Returns an error if the code already exists or if there's an internal server error
// ValidateCodeUniqueness valida que un código de almacén sea único en el sistema
// Retorna un error si el código ya existe o si hay un error interno del servidor
func (s *WarehouseServiceImpl) ValidateCodeUniqueness(ctx context.Context, code string) error <span class="cov0" title="0">{
        // Check if warehouse code already exists / Verificar si el código de almacén ya existe
        exists, err := s.warehouseRepository.ExistsByCode(ctx, code)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %v", error_message.ErrInternalServerError, err)
        }</span>

        // Return error if code already exists / Retornar error si el código ya existe
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: warehouse code '%s' already exists", error_message.ErrAlreadyExists, code)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetById retrieves a warehouse by its ID from the repository
// GetById recupera un almacén por su ID del repositorio
func (s *WarehouseServiceImpl) GetById(ctx context.Context, id int) (models.Warehouse, error) <span class="cov0" title="0">{
        return s.warehouseRepository.GetById(ctx, id)
}</span>

// Delete removes a warehouse by its ID from the repository
// Delete elimina un almacén por su ID del repositorio
func (s *WarehouseServiceImpl) Delete(ctx context.Context, id int) error <span class="cov0" title="0">{
        return s.warehouseRepository.Delete(ctx, id)
}</span>

// Update modifies an existing warehouse with business validation for code uniqueness
// Validates code uniqueness only if the warehouse code has changed
// Update modifica un almacén existente con validación de negocio para unicidad de código
// Valida la unicidad del código solo si el código del almacén ha cambiado
func (s *WarehouseServiceImpl) Update(ctx context.Context, id int, warehouse models.Warehouse) (models.Warehouse, error) <span class="cov0" title="0">{
        // Get current warehouse to compare codes / Obtener almacén actual para comparar códigos
        currentWarehouse, err := s.warehouseRepository.GetById(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return models.Warehouse{}, err
        }</span>

        // Validate code uniqueness only if code has changed / Validar unicidad del código solo si el código ha cambiado
        <span class="cov0" title="0">if currentWarehouse.WareHouseCode != warehouse.WareHouseCode </span><span class="cov0" title="0">{
                if err := s.ValidateCodeUniqueness(ctx, warehouse.WareHouseCode); err != nil </span><span class="cov0" title="0">{
                        return models.Warehouse{}, err
                }</span>
        }

        // Update warehouse after validation / Actualizar almacén después de la validación
        <span class="cov0" title="0">return s.warehouseRepository.Update(ctx, id, warehouse)</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package tests

import (
        "context"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
        "github.com/stretchr/testify/mock"
)

// ProductServiceMock es un mock del ProductService para pruebas unitarias
// ProductServiceMock is a mock of ProductService for unit testing
type ProductServiceMock struct {
        mock.Mock
}

// GetAll simula la obtención de todos los productos
// GetAll simulates retrieving all products
func (m *ProductServiceMock) GetAll(ctx context.Context) ([]models.Product, error) <span class="cov0" title="0">{
        args := m.Called(ctx)
        return args.Get(0).([]models.Product), args.Error(1)
}</span>

// GetByID simula la obtención de un producto por su ID
// GetByID simulates retrieving a product by its ID
func (m *ProductServiceMock) GetByID(ctx context.Context, id int64) (models.Product, error) <span class="cov0" title="0">{
        args := m.Called(ctx, id)
        return args.Get(0).(models.Product), args.Error(1)
}</span>

// Create simula la creación de un nuevo producto
// Create simulates creating a new product
func (m *ProductServiceMock) Create(ctx context.Context, product models.Product) (models.Product, error) <span class="cov0" title="0">{
        args := m.Called(ctx, product)
        return args.Get(0).(models.Product), args.Error(1)
}</span>

// CreateByBatch simula la creación de múltiples productos en lote
// CreateByBatch simulates creating multiple products in batch
func (m *ProductServiceMock) CreateByBatch(ctx context.Context, products []models.Product) ([]models.Product, error) <span class="cov0" title="0">{
        args := m.Called(ctx, products)
        return args.Get(0).([]models.Product), args.Error(1)
}</span>

// Update simula la actualización de un producto existente
// Update simulates updating an existing product
func (m *ProductServiceMock) Update(ctx context.Context, id int64, product models.Product) (models.Product, error) <span class="cov0" title="0">{
        args := m.Called(ctx, id, product)
        return args.Get(0).(models.Product), args.Error(1)
}</span>

// Delete simula la eliminación de un producto
// Delete simulates deleting a product
func (m *ProductServiceMock) Delete(ctx context.Context, id int64) error <span class="cov0" title="0">{
        args := m.Called(ctx, id)
        return args.Error(0)
}</span>

// ExistById simula la verificación de existencia de un producto por ID
// ExistById simulates checking if a product exists by ID
func (m *ProductServiceMock) ExistById(ctx context.Context, id int64) (bool, error) <span class="cov0" title="0">{
        args := m.Called(ctx, id)
        return args.Bool(0), args.Error(1)
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package validations

import (
        validation "github.com/go-ozzo/ozzo-validation/v4"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
)

type ProductRecordValidation struct {
}

func GetProductRecordValidation() *ProductRecordValidation <span class="cov0" title="0">{
        return &amp;ProductRecordValidation{}
}</span>

func (v *ProductRecordValidation) ValidateProductRecordRequestStruct(r requests.ProductRecordRequest) error <span class="cov0" title="0">{
        return validation.ValidateStruct(&amp;r,
                validation.Field(&amp;r.LastUpdateDate, validation.Required),
                validation.Field(&amp;r.PurchasePrice, validation.Required),
                validation.Field(&amp;r.SalePrice, validation.Required),
                validation.Field(&amp;r.ProductID, validation.Required),
        )
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package validations

import (
        "errors"

        validation "github.com/go-ozzo/ozzo-validation/v4"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
)

// ValidateBuyerRequestStruct validates that all required fields in BuyerRequest are present
// Uses ozzo-validation to ensure CardNumberId, FirstName, and LastName are not empty
func ValidateBuyerRequestStruct(r requests.BuyerRequest) error <span class="cov0" title="0">{
        return validation.ValidateStruct(&amp;r,
                validation.Field(&amp;r.CardNumberId, validation.Required),
                validation.Field(&amp;r.FirstName, validation.Required),
                validation.Field(&amp;r.LastName, validation.Required),
        )
}</span>

// IsNotAnEmptyBuyer validates that at least one field in BuyerRequest is provided
// Used for PATCH operations where partial updates are allowed
func IsNotAnEmptyBuyer(r requests.BuyerRequest) error <span class="cov0" title="0">{
        if r.CardNumberId != "" || r.FirstName != "" || r.LastName != "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return errors.New("at least one of id_card_number, first_name, or last_name is required")</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package validations

import (
        validation "github.com/go-ozzo/ozzo-validation/v4"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
)

func ValidateCarryRequest(request requests.CarryRequest) error <span class="cov0" title="0">{
        return validation.ValidateStruct(&amp;request,
                validation.Field(&amp;request.Cid, validation.Required, validation.Length(1, 10)),
                validation.Field(&amp;request.CompanyName, validation.Required, validation.Length(1, 100)),
                validation.Field(&amp;request.Address, validation.Required, validation.Length(1, 100)),
                validation.Field(&amp;request.Telephone, validation.Required, validation.Length(1, 10)),
                validation.Field(&amp;request.LocalityId, validation.Required, validation.Min(1)),
        )
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package validations

import (
        "errors"
        validation "github.com/go-ozzo/ozzo-validation"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
)

type EmployeeValidation struct {
}

func GetEmployeeValidation() *EmployeeValidation <span class="cov0" title="0">{
        return &amp;EmployeeValidation{}
}</span>

func ValidateEmployeeRequestStruct(r requests.EmployeeRequest) error <span class="cov0" title="0">{
        return validation.ValidateStruct(&amp;r,
                validation.Field(&amp;r.CardNumberID, validation.Required),
                validation.Field(&amp;r.FirstName, validation.Required),
                validation.Field(&amp;r.LastName, validation.Required),
                validation.Field(&amp;r.WarehouseID, validation.Required),
        )
}</span>

func IsNotAnEmptyEmployee(r requests.EmployeeRequest) error <span class="cov0" title="0">{
        if r.CardNumberID != "" || r.FirstName != "" || r.LastName != "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return errors.New("at least one of id_card_number, first_name, or last_name is required")</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package validations

import (
        "fmt"
        "reflect"
        "strings"

        validation "github.com/go-ozzo/ozzo-validation/v4"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
)

// ValidateInboundOrderRequestStruct valida que todos los campos necesarios estén presentes
func ValidateInboundOrderRequestStruct(r requests.InboundOrderRequest) error <span class="cov0" title="0">{
        if isInboundOrderAttributesEmpty(r.Data) </span><span class="cov0" title="0">{
                fields := []string{}
                val := reflect.ValueOf(r.Data)
                for i := 0; i &lt; val.Type().NumField(); i++ </span><span class="cov0" title="0">{
                        fields = append(fields, val.Type().Field(i).Tag.Get("json"))
                }</span>

                <span class="cov0" title="0">return fmt.Errorf("data: cannot be blank. fields %v are required inside of data", strings.Join(fields, ", "))</span>
        }

        <span class="cov0" title="0">return validation.ValidateStruct(&amp;r.Data,
                validation.Field(&amp;r.Data.OrderNumber, validation.Required),
                validation.Field(&amp;r.Data.OrderDate, validation.Required),
                validation.Field(&amp;r.Data.EmployeeId, validation.Required),
                validation.Field(&amp;r.Data.ProductBatchId, validation.Required),
                validation.Field(&amp;r.Data.WarehouseId, validation.Required),
        )</span>
}

func isInboundOrderAttributesEmpty(d requests.InboundOrderAttributes) bool <span class="cov0" title="0">{
        return d.OrderNumber == "" &amp;&amp;
                d.OrderDate.IsZero() &amp;&amp;
                d.EmployeeId == 0 &amp;&amp;
                d.ProductBatchId == 0 &amp;&amp;
                d.WarehouseId == 0
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package validations

import (
        "github.com/sajimenezher_meli/meli-frescos-8/internal/models"
)
import validation "github.com/go-ozzo/ozzo-validation/v4"

func ValidateLocalityRequestStruct(r models.Locality) error <span class="cov0" title="0">{
        return validation.ValidateStruct(&amp;r,
                validation.Field(&amp;r.LocalityName, validation.Required),
                validation.Field(&amp;r.ProvinceName, validation.Required),
                validation.Field(&amp;r.CountryName, validation.Required),
        )
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package validations

import (
        validation "github.com/go-ozzo/ozzo-validation/v4"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
)

func GetProductBatchValidation() *ProductBatchValidation <span class="cov0" title="0">{
        return &amp;ProductBatchValidation{}
}</span>

type ProductBatchValidation struct{}

func (v ProductBatchValidation) ValidateProductBatchRequestStruc(r requests.ProductBatchRequest) error <span class="cov0" title="0">{
        return validation.ValidateStruct(&amp;r,
                validation.Field(&amp;r.BatchNumber, validation.Required),
                validation.Field(&amp;r.CurrentQuantity, validation.Required),
                validation.Field(&amp;r.CurrentTemperature, validation.Required),
                validation.Field(&amp;r.DueDate, validation.Required),
                validation.Field(&amp;r.InitialQuantity, validation.Required),
                validation.Field(&amp;r.ManufacturingDate, validation.Required),
                validation.Field(&amp;r.ManufacturingHour, validation.Required),
                validation.Field(&amp;r.MinimumTemperature, validation.Required),
                validation.Field(&amp;r.ProductID, validation.Required),
                validation.Field(&amp;r.SectionID, validation.Required),
        )
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package validations

import (
        validation "github.com/go-ozzo/ozzo-validation/v4"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
)

type ProductValidation struct {
}

func GetProductValidation() *ProductValidation <span class="cov0" title="0">{
        return &amp;ProductValidation{}
}</span>

func (v ProductValidation) ValidateProductRequestStruct(r requests.ProductRequest) error <span class="cov0" title="0">{
        return validation.ValidateStruct(&amp;r,
                validation.Field(&amp;r.ProductCode, validation.Required),
                validation.Field(&amp;r.Description, validation.Required),
                validation.Field(&amp;r.Width, validation.Required),
                validation.Field(&amp;r.Height, validation.Required),
                validation.Field(&amp;r.Length, validation.Required),
                validation.Field(&amp;r.ProductTypeID, validation.Required),
                validation.Field(&amp;r.NetWeight, validation.Required),
                validation.Field(&amp;r.ExpirationRate, validation.Required),
                validation.Field(&amp;r.RecommendedFreezingTemperature, validation.Required),
                validation.Field(&amp;r.FreezingRate, validation.Required),
                //validation.Field(&amp;r.SellerID, validation.Required), this is optional
        )
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package validations

import (
        "fmt"
        "reflect"
        "strings"

        validation "github.com/go-ozzo/ozzo-validation/v4"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
)

// ValidatePurchaseOrderRequestStruct validates that all required fields in PurchaseOrderRequest are present
// Uses ozzo-validation to ensure Data, OrderNumber, OrderDate, TrackingCode, BuyerId, and ProductRecordId are not empty
func ValidatePurchaseOrderRequestStruct(r requests.PurchaseOrderRequest) error <span class="cov0" title="0">{
        if isPurchaseOrderAttributesEmpty(r.Data) </span><span class="cov0" title="0">{
                fields := []string{}
                val := reflect.ValueOf(r.Data)
                for i := 0; i &lt; val.Type().NumField(); i++ </span><span class="cov0" title="0">{
                        fields = append(fields, val.Type().Field(i).Tag.Get("json"))
                }</span>

                <span class="cov0" title="0">return fmt.Errorf("data: cannot be blank. fields %v are neccesary inside of data", strings.Join(fields, ", "))</span>
        }

        // validation that internal fields of data are present
        <span class="cov0" title="0">return validation.ValidateStruct(&amp;r.Data,
                validation.Field(&amp;r.Data.OrderNumber, validation.Required),
                validation.Field(&amp;r.Data.OrderDate, validation.Required),
                validation.Field(&amp;r.Data.TrackingCode, validation.Required),
                validation.Field(&amp;r.Data.BuyerId, validation.Required),
                validation.Field(&amp;r.Data.ProductRecordId, validation.Required),
        )</span>
}

func isPurchaseOrderAttributesEmpty(d requests.PurchaseOrderAttributes) bool <span class="cov0" title="0">{
        return d.OrderNumber == "" &amp;&amp;
                d.OrderDate.IsZero() &amp;&amp;
                d.TrackingCode == "" &amp;&amp;
                d.BuyerId == 0 &amp;&amp;
                d.ProductRecordId == 0
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package validations

import (
        validation "github.com/go-ozzo/ozzo-validation"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
)

func GetSectionValidation() *SectionValidation <span class="cov0" title="0">{
        return &amp;SectionValidation{}
}</span>

type SectionValidation struct {
}

func (v SectionValidation) ValidateSectionRequestStruct(r requests.SectionRequest) error <span class="cov0" title="0">{
        return validation.ValidateStruct(&amp;r,
                validation.Field(&amp;r.SectionNumber, validation.Required),
                validation.Field(&amp;r.CurrentCapacity, validation.Required),
                validation.Field(&amp;r.CurrentTemperature, validation.Required),
                validation.Field(&amp;r.MaximumCapacity, validation.Required),
                validation.Field(&amp;r.MinimumCapacity, validation.Required),
                validation.Field(&amp;r.MinimumTemperature, validation.Required),
                validation.Field(&amp;r.ProductTypeID, validation.Required),
                validation.Field(&amp;r.WarehouseID, validation.Required),
        )
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package validations

import "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
import validation "github.com/go-ozzo/ozzo-validation/v4"

func ValidateSellerRequestStruct(r requests.SellerRequest) error <span class="cov0" title="0">{
        return validation.ValidateStruct(&amp;r,
                validation.Field(&amp;r.CID, validation.Required),
                validation.Field(&amp;r.CompanyName, validation.Required),
                validation.Field(&amp;r.Address, validation.Required),
                validation.Field(&amp;r.Telephone, validation.Required),
        )
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">package validations

import (
        validation "github.com/go-ozzo/ozzo-validation/v4"
        "github.com/sajimenezher_meli/meli-frescos-8/internal/handlers/requests"
)

func ValidateWarehouseRequestStruct(r requests.WarehouseRequest) error <span class="cov0" title="0">{
        return validation.ValidateStruct(&amp;r,
                validation.Field(&amp;r.Address, validation.Required),
                validation.Field(&amp;r.Telephone, validation.Required),
                validation.Field(&amp;r.WareHouseCode, validation.Required),
                validation.Field(&amp;r.MinimumCapacity, validation.Required, validation.Min(1)),
                validation.Field(&amp;r.MinimumTemperature, validation.Required),
                validation.Field(&amp;r.LocalityId, validation.Required),
        )
}</span>

func ValidateWarehousePatchRequest(r requests.WarehousePatchRequest) error <span class="cov0" title="0">{
        return validation.ValidateStruct(&amp;r,
                validation.Field(&amp;r.Address, validation.When(r.Address != nil, validation.Required)),
                validation.Field(&amp;r.Telephone, validation.When(r.Telephone != nil, validation.Required)),
                validation.Field(&amp;r.WareHouseCode, validation.When(r.WareHouseCode != nil, validation.Required)),
                validation.Field(&amp;r.MinimumCapacity, validation.When(r.MinimumCapacity != nil, validation.Required, validation.Min(1))),
                validation.Field(&amp;r.MinimumTemperature, validation.When(r.MinimumTemperature != nil, validation.Required)),
        )
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"
        "log"

        "github.com/sajimenezher_meli/meli-frescos-8/internal/config"
        tools "github.com/sajimenezher_meli/meli-frescos-8/pkg"

        _ "github.com/go-sql-driver/mysql" // MySQL driver
)

// InitDB initializes and returns a MySQL database connection
func InitDB(cfg *config.Config) *sql.DB <span class="cov0" title="0">{
        dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?parseTime=true",
                cfg.Database.DBUser, cfg.Database.DBPassword, cfg.Database.DBHost, cfg.Database.DBPort, cfg.Database.DBName)

        db, err := sql.Open("mysql", dsn)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error opening database: %v", err)
        }</span>

        <span class="cov0" title="0">err = db.Ping()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error connecting to the database: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("Successfully connected to MySQL!")
        return db</span>
}

func SelectOne(ctx context.Context, db *sql.DB, tablename string, fields []string, condition string, values ...any) *sql.Row <span class="cov0" title="0">{
        columns := tools.SliceToString(fields, ",")
        sqlStatement := fmt.Sprintf("SELECT %s FROM %s", columns, tablename)
        if condition != "" </span><span class="cov0" title="0">{
                sqlStatement = fmt.Sprintf("%s WHERE %s", sqlStatement, condition)
        }</span>

        <span class="cov0" title="0">return db.QueryRowContext(ctx, sqlStatement, values...)</span>
}

func Select(ctx context.Context, db *sql.DB, tablename string, fields []string, condition string, values ...any) (*sql.Rows, error) <span class="cov0" title="0">{
        columns := tools.SliceToString(fields, ",")
        sqlStatement := fmt.Sprintf("SELECT %s FROM %s", columns, tablename)
        if condition != "" </span><span class="cov0" title="0">{
                sqlStatement = fmt.Sprintf("%s WHERE %s", sqlStatement, condition)
        }</span>

        <span class="cov0" title="0">return db.QueryContext(ctx, sqlStatement, values...)</span>
}

func Insert(ctx context.Context, db *sql.DB, tablename string, data map[any]any) (sql.Result, error) <span class="cov0" title="0">{
        keys, values := tools.GetSlicesOfKeyAndValuesFromMap(data)
        columns := tools.SliceToString(keys, ",")
        placeholders := tools.SliceToString(tools.FillNewSlice(len(data), "?"), ",")

        sqlStatement := fmt.Sprintf("INSERT INTO %s(%s) VALUES (%s);", tablename, columns, placeholders)

        return db.ExecContext(ctx, sqlStatement, values...)
}</span>

func Delete(ctx context.Context, db *sql.DB, tablename string, condition string, values ...any) (sql.Result, error) <span class="cov0" title="0">{
        sqlStatement := fmt.Sprintf("DELETE FROM %s WHERE %s;", tablename, condition)

        return db.ExecContext(ctx, sqlStatement, values...)
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">package tools

import (
        "fmt"
        "strings"
        "time"
)

func SliceToString[T any](slice []T, delim string) string <span class="cov0" title="0">{
        return strings.Trim(strings.Join(strings.Fields(fmt.Sprint(slice)), delim), "[]")
}</span>

func FillNewSlice[T any](size int, value T) []T <span class="cov0" title="0">{
        sliceFilled := make([]T, size)
        for i := range size </span><span class="cov0" title="0">{
                sliceFilled[i] = value
        }</span>
        <span class="cov0" title="0">return sliceFilled</span>
}

func GetSlicesOfKeyAndValuesFromMap(m map[any]any) ([]any, []any) <span class="cov0" title="0">{
        keys := make([]any, 0, len(m))
        values := make([]any, 0, len(m))
        for k, v := range m </span><span class="cov0" title="0">{
                keys = append(keys, k)
                values = append(values, v)
        }</span>
        <span class="cov0" title="0">return keys, values</span>
}

func ConvertStringToDate(date string) (time.Time, error) <span class="cov0" title="0">{
        return time.Parse("2006-01-02", date)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
